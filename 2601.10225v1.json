{
    "id": "2601.10225v1",
    "title": "A Unified Framework for Kinematic Simulation of Rigid Foldable Structures",
    "authors": [
        "Dongwook Kwak",
        "Geonhee Cho",
        "Jiook Chung",
        "Jinkyu Yang"
    ],
    "abstract": "å—æŠ˜çº¸å¯å‘çš„åˆšæ€§é¢æ¿ç»“æ„ç°å·²æ¶µç›–åšæ¿ã€å‰ªçº¸åŠå¤šå±‚å®ç°å½¢å¼ï¼Œç»Ÿä¸€çš„è¿åŠ¨å­¦åˆ†æå› æ­¤å˜å¾—è‡³å…³é‡è¦ã€‚ç„¶è€Œï¼Œç›®å‰ä»ç¼ºä¹ä¸€ç§èƒ½å¤Ÿæ•´åˆå…¶é—­ç¯çº¦æŸçš„é€šç”¨æ–¹æ³•ã€‚æˆ‘ä»¬æå‡ºä¸€ç§è‡ªåŠ¨åŒ–æ–¹æ³•ï¼Œå¯ä¸ºä»»æ„åˆšæ€§å¯æŠ˜å ç»“æ„ç”Ÿæˆæ™®æ³•å¤«çº¦æŸçŸ©é˜µã€‚è¯¥å·¥å…·åŸºäºæœ€å°åŒ–æ‰©å±•æ•°æ®æ¶æ„ï¼Œæ„å»ºé¢-é“°é“¾å›¾ï¼Œæå–åŒ…å«æ‰€æœ‰çº¦æŸçš„æœ€å°ç¯åŸºï¼Œå¹¶é€šè¿‡èºæ—‹ç†è®ºç»„è£…é€Ÿåº¦çº§çº¦æŸçŸ©é˜µï¼Œä»è€Œç¼–ç æ—‹è½¬ä¸å¹³ç§»è€¦åˆçš„é—­ç¯çº¦æŸã€‚è¯¥æ¡†æ¶èƒ½è®¡ç®—å¹¶å¯è§†åŒ–å„ç±»åˆšæ€§å¯æŠ˜å ç»“æ„çš„å±•å¼€ä¸æŠ˜å è¿åŠ¨ï¼ŒåŒæ—¶æ¶ˆé™¤äº†ç¹çä¸”æ˜“å‡ºé”™çš„çº¦æŸè®¡ç®—è¿‡ç¨‹ã€‚",
    "url": "https://arxiv.org/abs/2601.10225v1",
    "html_url": "https://arxiv.org/html/2601.10225v1",
    "html_content": "Abstract\nOrigami-inspired structures with rigid panels now span thick, kirigami, and multi-sheet realizations, making unified kinematic analysis essential. Yet a general method that consolidates their loop constraints has been lacking. We present an automated approach that generates the Pfaffian constraint matrix for arbitrary rigid foldable structures (RFS). From a minimally extended data schema, the tool constructs the facetâ€“hinge graph, extracts a minimum cycle basis that captures all constraints, andâ€”via screw theoryâ€” assembles a velocity-level constraint matrix that encodes coupled rotation-translation loop closure. The framework computes and visualizes deploy/fold motions across diverse RFS, while eliminating tedious, error-prone constraint calculation.\nA Unified Framework for Kinematic Simulation of Rigid Foldable Structures\nDongwook Kwak\nDepartment of Mechanical Engineering, Seoul National University, Seoul, Republic of Korea\nume1838@snu.ac.kr\nGeonhee Cho\nDepartment of Mechanical Engineering, Seoul National University, Seoul, Republic of Korea\ngunhee236@snu.ac.kr\nJiook Chung\nDepartment of Mechanical Engineering, Seoul National University, Seoul, Republic of Korea\njiwook2000@snu.ac.kr\nJinkyu Yang\nDepartment of Mechanical Engineering, Seoul National University, Seoul, Republic of Korea\njkyang11@snu.ac.kr\nKeywords\n: rigid origami, kinematic analysis, loop closure constraints, rigid-foldable structures, screw theory, facet-hinge graph\n1.â€ƒâ€ŠIntroduction\nOrigami-inspired structures have attracted broad attention in engineering owing to their unique combination of compact stowage, large deployability, and structural reconfigurability.\nSuch properties have enabled diverse applicationsâ€”from deployable space structures\n[\n25\n,\n15\n]\nto reconfigurable robots\n[\n9\n,\n3\n]\nand adaptive architectural systems\n[\n26\n]\nâ€”where compactness and controlled motion are crucial.\nAmong these,\nrigid origami\nâ€”where each panel moves as a rigid body without bending or stretchingâ€”has become a key foundation for engineering origami design.\nThis concept naturally extends beyond the classical thin-sheet origami to a broader class of\nrigid foldable structures\n(RFSs). These include thick-panel implementations, kirigami with perforations, and multi-sheet assemblies.\nThese developments have diversified the mechanical and functional landscape of origami-inspired systems, while also amplifying the need for general kinematic analysis frameworks that can accurately capture the motion compatibility among rigid facets connected by hinges.\nIn such structures, the network of hinges connecting adjacent facets forms closed loops, and each loop imposes geometric closure constraints that restrict the feasible folding angles of the connected panels.\nDetermining the folding angles that satisfy these constraintsâ€”or, given a configuration, computing the admissible motion directionsâ€”constitutes the core problem of rigid-foldable kinematics.\nThis task is inherently challenging, as the constraints are nonlinear and strongly coupled even for relatively simple patterns.\nTo address this challenge, previous studies have attempted to compute feasible folding motions either analytically or numerically.\nAnalytic approaches can be largely categorized into two groups.\nThe first group derives explicit trigonometric relationships among folding angles within a unit cell, such as in symmetric waterbomb origami\n[\n1\n]\n, Miura and stacked Miura origami\n[\n14\n]\n, and Tachiâ€“Miura Polyhedron (TMP) patterns\n[\n22\n]\n.\nThe second group adopts a rigid-body formulation based on the Denavitâ€“Hartenberg (DH) convention. Each panel is manually assigned a local frame, and the\n4\nÃ—\n4\n4\\times 4\ntransformation matrices between adjacent panels are computed to satisfy loop closure.\nThis method has been applied to thick-panel origami and kirigami to evaluate feasible joint angles that yield identity transformations\n[\n2\n,\n20\n,\n19\n]\n.\nWhile these approaches offer analytic insight into specific geometries, their extension to general, multi-loop configurations remains intractable due to the high algebraic complexity.\nNumerical methods have aimed to generalize the analysis by constructing velocity-level constraint matrices.\n[\n17\n]\ndeveloped a numerical solver, which efficiently determines foldable configurations but focuses mainly on thin, non-perforated origami where only rotational compatibility is enforced.\nMore recently,\n[\n16\n]\nintroduced the\nCRANE\nplatform, enabling interactive kinematic simulations for arbitrary crease patterns. However, it also assumes single-layer origami and does not account for translational coupling or inter-layer constraints.\nFinite-elementâ€“based simulation approaches, including the bar-and-hinge model\n[\n10\n]\nand\nOrigami Simulator\n[\n6\n]\n, can handle large-scale folding problems at low computational cost.\nNevertheless, they allow facet deformation for numerical stability, and thus cannot strictly preserve rigid-folding kinematicsâ€”such as singularities, constraint satisfaction, and degrees of freedomâ€”required for accurate analysis of rigid foldable structures.\nComprehensive survey of kinematic modeling strategies and practical formulations of loop-closure constraints in origami and related systems can be founded in the recent review by\n[\n27\n]\n.\nThis study presents a unified computational framework for the kinematic analysis of RFSs.\nAn RFS is formulated as a spatial linkage composed of rigid facets and revolute joints.\nWe introduce a minimal yet general geometric data schema to represent arbitrary fold patterns and their inter-sheet connections.\nUsing a graph-based approach, internal loops are automatically identified to capture independent closure constraints,\nwhile the screw-theoretic formulation expresses coupled rotational and translational motions in a unified matrix form.\nTogether, these components provide a compact and scalable foundation for analyzing diverse rigid-foldable structures.\n2.â€ƒâ€ŠMethodology\n2.1\nOverview of the Framework\nFigure 1\n:\nOverview of the proposed computational pipeline for constructing the Pfaffian constraint matrix of an RFS.\nThe ultimate goal of the proposed framework is to construct the Pfaffian constraint matrix of a given RFS that encodes the velocity-level motion constraints among the hinges.\nThis matrix should capture all loop-closure relationships of the structure, ensuring that the folding motion satisfies both rotational and translational compatibility across connected facets.\nFigure\n1\nillustrates the overall computational pipeline.\nThe framework proceeds through four major stages: (i) data schema of RFS, (ii) graph construction and closed-loop extraction, (iii) screw assignment, and (iv) Pfaffian matrix assembly.\nEach stage progressively develops geometric information into a complete mathematical representation of rigid-folding motion.\nWe first define a minimal yet general representation of RFS that provides an intuitive input for users while preserving all geometric information necessary for kinematic modeling.\nThis unified representation allows both single-layer origami and multi-layer configurations to be handled consistently.\nFrom this input, a facetâ€“hinge graph is built to automatically identify independent closure loops.\nScrew axes are then assigned consistently across these loops, and all resulting constraints are assembled into a compact velocity-level formulation.\nDetailed explanations of each stage, including how the data schema operates, are provided in the following sections.\n2.2\nData Schema of Rigid Foldable Structures\nFigure 2\n:\nExamples of sheet-wise connections and their graph representation in the proposed data schema.\n(A) Hinging-type connection introducing a rotational degree of freedom in a stacked Miura origami (SMO) unit cell.\n(B) Soldering-type connection constraining relative motion in a Tachiâ€“Miura polyhedron (TMP) unit cell.\nIn the SMO case, hinging adds graph edges, whereas in the TMP case, soldering merges nodes into a single one, resulting in distinct graph representations.\nWe introduce a data schema that explicitly encodes both intra-sheet and inter-sheet relationships to systematically represent the geometric and kinematic configuration of multi-sheet RFSs.\nThis schema provides a unified and modular description of all geometric entitiesâ€”vertices, pattern edges, and facetsâ€”as well as the sheet-wise connections between them, forming the basis for graph construction and constraint analysis.\nFigure\n2\nA shows an example of the notations used in this study. Each geometric element is indexed by its sheet number\ni\ni\nand its local index\nj\nj\n:\nv\ni\nâ€‹\nj\nv_{ij}\n,\ne\ni\nâ€‹\nj\ne_{ij}\n, and\nf\ni\nâ€‹\nj\nf_{ij}\ndenote the\nj\nth\nj^{\\text{th}}\nvertex, pattern edge, and facet on the\ni\nth\ni^{\\text{th}}\nsheet, respectively.\nA vertex\nv\ni\nâ€‹\nj\nv_{ij}\nstores its 3D coordinates, e.g.,\nv\n00\n=\n[\nx\n00\n,\ny\n00\n,\nz\n00\n]\nv_{00}=[x_{00},y_{00},z_{00}]\n.\nA pattern edge\ne\ni\nâ€‹\nj\ne_{ij}\nrepresents a pair of vertex indicesâ€”for example,\ne\n00\n=\n[\nv\n00\n,\nv\n03\n]\ne_{00}=[v_{00},v_{03}]\nand\ne\n10\n=\n[\nv\n10\n,\nv\n13\n]\ne_{10}=[v_{10},v_{13}]\n.\nThe term\npattern edge\nis used here to distinguish these geometric edges from the graph edges that will be introduced later.\nEach facet\nf\ni\nâ€‹\nj\nf_{ij}\nis defined as an ordered list of vertex indices on sheet\ni\ni\n; for instance,\nf\n00\n=\n[\nv\n00\n,\nv\n01\n,\nv\n02\n,\nv\n03\n]\nf_{00}=[v_{00},v_{01},v_{02},v_{03}]\n.\nAcross different sheets, sheet-wise connections can be manually specified by assigning two facet indices and a connection typeâ€”for example,\nc\n1\n=\n[\nf\n00\n,\nf\n10\n,\nh\n]\nc_{1}=[f_{00},f_{10},h]\nfor a hinging-type connection or\nc\n1\n=\n[\nf\n00\n,\nf\n10\n,\ns\n]\nc_{1}=[f_{00},f_{10},s]\nfor a soldering-type connection.\nRepresentative examples of the hinging- and soldering-type connections and illustrated in Figure\n2\nA and Figure\n2\nB, respectively.\nThe overall schema is formally defined as follows:\nâ€¢\nVertices:\nV\n=\n[\n[\nv\n00\n,\nâ€¦\n,\nv\n0\nâ€‹\nN\nV\n,\n1\n]\n,\nâ€¦\n,\n[\nv\nm\nâ€‹\n0\n,\nâ€¦\n,\nv\nm\nâ€‹\nN\nV\n,\nm\n]\n]\nV=\\left[[v_{00},\\dots,v_{0N_{V,1}}],\\dots,[v_{m0},\\dots,v_{mN_{V,m}}]\\right]\n,\nwhere each\nv\ni\nâ€‹\nj\nâˆˆ\nâ„\n3\nv_{ij}\\in\\mathbb{R}^{3}\nrepresents the 3D coordinate of the\nj\nj\n-th vertex on the\ni\ni\n-th sheet.\nN\nV\n,\ni\n+\n1\nN_{V,i}+1\ndenotes the number of vertices on sheet\ni\ni\n.\nâ€¢\nPattern edges:\nE\n=\n[\n[\ne\n00\n,\nâ€¦\n,\ne\n0\nâ€‹\nN\nE\n,\n1\n]\n,\nâ€¦\n,\n[\ne\nm\nâ€‹\n0\n,\nâ€¦\n,\ne\nm\nâ€‹\nN\nE\n,\nm\n]\n]\nE=\\left[[e_{00},\\dots,e_{0N_{E,1}}],\\dots,[e_{m0},\\dots,e_{mN_{E,m}}]\\right]\n,\nwhere each\ne\ni\nâ€‹\nj\nâˆˆ\nâ„¤\nâ‰¥\n0\n2\ne_{ij}\\in\\mathbb{Z}_{\\geq 0}^{\\,2}\nspecifies a pair of vertex indices forming a pattern edge on sheet\ni\ni\n.\nN\nE\n,\ni\n+\n1\nN_{E,i}+1\nis the number of pattern edges on sheet\ni\ni\n.\nâ€¢\nFacets:\nF\n=\n[\n[\nf\n00\n,\nâ€¦\n,\nf\n0\nâ€‹\nN\nF\n,\n1\n]\n,\nâ€¦\n,\n[\nf\nm\nâ€‹\n0\n,\nâ€¦\n,\nf\nm\nâ€‹\nN\nF\n,\nm\n]\n]\nF=\\left[[f_{00},\\dots,f_{0N_{F,1}}],\\dots,[f_{m0},\\dots,f_{mN_{F,m}}]\\right]\n,\nwhere\nf\ni\nâ€‹\nj\nâˆˆ\nâ„¤\nâ‰¥\n0\nâ„“\nâ€‹\n(\ni\n,\nj\n)\nf_{ij}\\in\\mathbb{Z}_{\\geq 0}^{\\,\\ell(i,j)}\nlists the vertex indices defining the\nj\nj\n-th facet on sheet\ni\ni\n(with\nâ„“\nâ€‹\n(\ni\n,\nj\n)\n\\ell(i,j)\nvertices).\nN\nF\n,\ni\n+\n1\nN_{F,i}+1\nis the number of facets on sheet\ni\ni\n.\nâ€¢\nSheet-wise connections:\nC\n=\n[\nc\n1\n,\nâ€¦\n,\nc\nN\nC\n]\nC=[c_{1},\\dots,c_{N_{C}}]\n, where\nc\nÎ±\n=\n[\nf\n,\nf\n,\nx\n]\nc_{\\alpha}=[f,f,x]\nspecifies two connected facets (necessarily on different sheets) and a connection type\nx\nâˆˆ\n{\nh\n,\ns\n}\nx\\in\\{h,s\\}\n.\nHere\nx\n=\nh\nx=h\n(\nhinging\n) introduces a rotational degree of freedom along their shared boundary,\nwhile\nx\n=\ns\nx=s\n(\nsoldering\n) constrains the two facets to move as one rigid body.\nN\nC\nN_{C}\ndenotes the total number of inter-sheet connections.\nEach sheet designates its first facet as a\nseed facet\n, whose boundary orientation must be explicitly defined, either counterclockwise or clockwise.\nThis orientation determines the facet normal and thereby defines the mountainâ€“valley configuration of intra-sheet creases.\nOnce the seed facet is defined, all other facets within the same sheet are automatically aligned through shared pattern edges to ensure consistent orientation across the sheet. The resulting uniform facet orientation forms the basis for the consistent screw-direction assignment discussed in Section\n2.4\n,\nwhile additional conventionsâ€”such as connection grouping and the formal definition of a sheetâ€”are summarized in Appendix\nA.1\n.\nConceptually, one can think of this schema as a layer-wise extension of the widely used\n(\nV\n,\nE\n,\nF\n)\n(V,E,F)\nrepresentation,\naugmented with sheet indices and connection attributes to handle multi-layer RFSs.\nBy tagging all geometric elements with sheet indices and explicitly recording inter-layer connections,\nthe proposed schema generalizes the conventional single-sheet representation to handle multi-layer configurations in a unified manner.\nThis foundation allows the subsequent algorithms to be directly applied to a broad range of RFSs.\n2.3\nFacet-Hinge Graph and Loop Extraction\nFigure 3\n:\nClosure loops in patterns and cycles in graphs are in one-to-one correspondence (left: pattern, right: graph).\n(A) Facetâ€“hinge graph representation of a rigid-foldable kirigami pattern.\n(B) A complete and minimum set of closure loops obtained via the minimum cycle basis.\n(C) A complete but non-minimum loop set that contains redundant cycles.\nStarting from the data schema, we construct a\nfacetâ€“hinge graph\nthat captures the connectivity relationships among facets.\nEach facet becomes a\ngraph node\n, and intra-sheet pattern edges lying in the sheet interior serve as\ngraph edges\n, whereas boundary edges are excluded unless they participate in inter-sheet hinging connections.\nInter-sheet connections of type\nh\nh\n(hinging) introduce new graph edges, while those of type\ns\ns\n(soldering) merge the connected nodes into a single node, producing distinct graph representations for the two connection types (Figure\n2\n).\nThe resulting facetâ€“hinge graph typically contains many cycles, each corresponding to a closure loop in the RFS pattern.\nTo obtain a complete and non-redundant set of such loops, we compute a\nminimum cycle basis\n(MCB)\n[\n7\n]\n.\nThe MCB provides the smallest collection of independent cycles from which all other cycles can be formed, corresponding exactly to the independent closure loops.\nBecause the MCB minimizes the total loop length, each loop involves fewer hinge traversals, reducing the propagation of numerical error when the kinematic constraints are later assembled into the global constraint matrix.\nFigure\n3\nillustrate the one-to-one correspondence between pattern-level closure loops and graph cycles.\nEach thick black loop in Figure\n3\nB and\n3\nC denotes a closure loop in the physical pattern, and the matching cycle on the right shows its graph-level representation.\nThe red loops highlight the distinction between a minimal cycle basis and a non-minimal set: Figure\n3\nB contains a complete and minimal collection of loops, whereas Figure\n3\nC includes an additional red loop that renders the set non-minimal.\nThis redundant cycle can be expressed as a linear combination of the loops in Figure\n3\nB, confirming that it introduces no new independent constraint.\nThe numbers placed at the center of each cycle indicate the number of creases traversed by that loop.\nSumming these values yields 44 crease traversals in the minimum case and 60 in the redundant case, demonstrating that non-minimal loop sets impose unnecessary hinge evaluations during constraint propagation.\nThe graph-based formulation offers three concrete benefits:\n(i) closure loops and graph cycles are directly related, providing a purely combinatorial handle on constraint selection;\n(ii) the MCB guarantees minimality under a chosen edge weight without ad hoc bookkeeping; and\n(iii) once the graph is built, loop extraction is automatic and reproducible across large, multi-layer patterns.\nBased on the defined data schema, the facetâ€“hinge graph is constructed automatically by comparing vertex indices and vertex coordinates across both intra- and inter-sheet facets.\nThis procedure also reveals joints corresponding to hinging-type connections.\nFurther methodological details are provided in Appendix\nA.2\n.\n2.4\nScrew Assignment\nThe assignment of screw axes determines the rotation direction and polarity of fold motion across the structure.\nBuilding upon the orientation conventions defined in the data schema,\nall facet vertex loops on a given sheet share the same ordering.\nWith this consistency, the hinge directions between adjacent facets can be aligned coherently,\nproducing a continuous and conflict-free motion field across the sheet.\nThis geometric consistency enables the automatic assignment of hinge screws that generate continuous rigid-folding motions without sign conflicts. The overall concept of screw-axis alignment, governed by facet vertex loop ordering, and its effect on motion continuity is illustrated in Figure\n4\n.\nFigure 4\n:\nSchematic illustration of screw-axis orientation consistency and its influence on motion continuity.\n(A) Consistent facet orientation yields a uniform hinge motion.\n(B) Reversed orientation causes conflicting screw directions and motion discontinuity.\nThe screw-axis assignment proceeds in three deterministic steps:\n1.\nSeed facet initialization.\nA reference facet is first selected on each sheet, and its vertex order defines the positive orientation of all intra-sheet hinges.\nA positive hinge rotation is defined such that, when viewed along the facet normal, it produces a mountain fold.\n2.\nLoop-level unification.\nWithin each minimal closure loop identified from the facetâ€“hinge graph, the traversal direction is fixed according to the seed facetâ€™s orientation.\nEach hinge in the loop is assigned a space screw axis so that the rotational directions are consistent along the loop, avoiding any sign ambiguity at shared creases.\n3.\nGlobal propagation.\nBecause adjacent loops share at least one hinge, the assigned screw direction of a shared hinge is inherited by all loops containing it.\nPropagating this rule through all loops yields a globally consistent screw-axis configuration without requiring manual correction.\nThis procedure provides a method for determining all screw axes in arbitrary RFS, where no explicit local frames or parameter tuning are required.\nThe screw assignment can also be derived directly from the information defined in the data schema,\nand the detailed computational pipeline is summarized in Appendix\nA.3\n.\n2.5\nConstraint Matrix Assembly using Screw Theory\nFrom the facetâ€“hinge graph constructed in the previous section,\nall graph edges corresponding to rotational joints are identified.\nThe resulting set of screw axes forms the foundation for constructing the loop-level constraint matrices.\nCollecting all revolute motions yields the set of\nhinge variables\nÎ¸\nâˆˆ\nâ„\nn\n\\theta\\in\\mathbb{R}^{n}\nused to describe the kinematic state of the structure.\nThe holonomic loop-closure conditions among facets can be expressed purely in terms of the hinge angles\nÎ¸\n\\theta\n, making them\nscleronomic\n, i.e., independent of time.\nTaking the time derivative gives their differential, or\nPfaffian\n, form:\nA\nâ€‹\n(\nÎ¸\n)\nâ€‹\nÎ¸\nË™\n=\n0\n,\nA(\\theta)\\,\\dot{\\theta}=0,\n(1)\nwhere\nA\nâ€‹\n(\nÎ¸\n)\nA(\\theta)\nis the configuration-dependent\nPfaffian constraint matrix\n.\nThe null space of\nA\nâ€‹\n(\nÎ¸\n)\nA(\\theta)\ndefines all admissible hinge velocities\nÎ¸\nË™\n\\dot{\\theta}\n, and its rank determines the instantaneous degrees of freedom:\nDoF\n=\nn\nâˆ’\nrank\nâ€‹\n(\nA\nâ€‹\n(\nÎ¸\n)\n)\n.\n\\mathrm{DoF}=n-\\mathrm{rank}\\left(A(\\theta)\\right).\n(2)\nA nonzero DoF indicates the existence of feasible motion directions satisfying all closure constraints,\nallowing direct assessment of local foldability. In rare cases, such as singular configurations where the Jacobian of the hinge variables is ill-defined,\nthe computed\nA\nâ€‹\n(\nÎ¸\n)\nA(\\theta)\nmay yield an apparent nonzero DoF even though no actual motion exists.\nNonetheless, this formulation correctly predicts the true kinematic mobility for nearly all regular configurations encountered in practice.\nIn the following, we construct the constraint matrix using screw theory, which models each hinge as a screw motion between connected rigid facets. The mathematical backgroundâ€”covering screw representation, forward kinematics, and the space Jacobianâ€”is summarized in the Appendix\nB\n. Unlike DH parameterization, screw theory operates directly on geometric quantities such as axes and points, providing a coordinate-free and physically intuitive foundation for constraint formulation.\nFigure 5\n:\n(A) Screw assignment and traversal direction of a single minimal closure loop.\n(B) Configuration after folding motion, where the loop closure constraint is satisfied.\nAmong the\nL\nL\nminimal closure loops identified from the facetâ€“hinge graph, let the\nl\nth\nl^{\\text{th}}\nloop pass through\nn\nl\nn_{l}\ncrease lines.\nEach crease in the\nl\nth\nl^{\\text{th}}\nloop is assigned a local hinge variable\nÏ\ni\n\\rho_{i}\n, used solely for internal constraint evaluation within that loop.\nThe corresponding well-assigned space screw axis at the home position is denoted by\nÎ¾\nl\n,\ni\n\\xi_{l,i}\n(\ni\n=\n1\n,\nâ€¦\n,\nn\nl\n)\n(i=1,\\dots,n_{l})\nrepresenting the geometric configuration of the\ni\nth\ni^{\\text{th}}\nhinge in its undeformed state (Figure\n5\n).\nTo derive the loop constraint, we virtually cut the loop and unfold it into an open chain.\nThe last facet connected to the final hinge\nÎ¾\nl\n,\nn\nl\n\\xi_{l,n_{l}}\nis assumed to coincide with the first facet in the loop, fixed to the global space frame\n{\ns\n}\n\\{s\\}\n.\nThis implies that the terminal and initial facet frames coincide in the home configuration, meaning that the home transformation matrix (\nM\ns\n,\nn\nl\nM_{s,n_{l}}\n) of the end facet is the identity matrix.\nAfter folding (i.e., rotating the hinges), the configuration of the end facet must still coincide with the space frame.\nUsing the Product of Exponentials (PoE) formula, the loop closure condition is\nT\n=\ne\n[\nÎ¾\nl\n,\n1\n]\nâ€‹\nÏ\n1\nâ€‹\ne\n[\nÎ¾\nl\n,\n2\n]\nâ€‹\nÏ\n2\nâ€‹\nâ‹¯\nâ€‹\ne\n[\nÎ¾\nl\n,\nn\nl\n]\nâ€‹\nÏ\nn\nl\nâ€‹\nM\ns\n,\nn\nl\n=\nI\n4\n.\nT=e^{[\\xi_{l,1}]\\rho_{1}}e^{[\\xi_{l,2}]\\rho_{2}}\\cdots e^{[\\xi_{l,n_{l}}]\\rho_{n_{l}}}M_{s,n_{l}}=I_{4}.\n(3)\nTaking the time derivative yields\nT\nË™\n=\nâˆ‚\nT\nâˆ‚\nÏ\n1\nâ€‹\nÏ\nË™\n1\n+\nâ‹¯\n+\nâˆ‚\nT\nâˆ‚\nÏ\nn\nl\nâ€‹\nÏ\nË™\nn\nl\n=\nğŸ\n4\nÃ—\n4\n.\n\\dot{T}=\\frac{\\partial T}{\\partial\\rho_{1}}\\dot{\\rho}_{1}+\\cdots+\\frac{\\partial T}{\\partial\\rho_{n_{l}}}\\dot{\\rho}_{n_{l}}=\\mathbf{0}_{4\\times 4}.\n(4)\nDefining\nT\nj\n:\nk\n=\ne\n[\nÎ¾\nl\n,\nj\n]\nâ€‹\nÏ\nj\nâ€‹\ne\n[\nÎ¾\nl\n,\nj\n+\n1\n]\nâ€‹\nÏ\nj\n+\n1\nâ€‹\nâ‹¯\nâ€‹\ne\n[\nÎ¾\nl\n,\nk\n]\nâ€‹\nÏ\nk\nT_{j:k}=e^{[\\xi_{l,j}]\\rho_{j}}e^{[\\xi_{l,j+1}]\\rho_{j+1}}\\cdots e^{[\\xi_{l,k}]\\rho_{k}}\n,\nthe partial derivative of\nT\nT\nwith respect to\nÏ\nk\n\\rho_{k}\nbecomes\nâˆ‚\nT\nâˆ‚\nÏ\nk\n=\nT\n1\n:\nk\nâˆ’\n1\nâ€‹\n[\nÎ¾\nl\n,\nk\n]\nâ€‹\nT\nk\n:\nn\nl\n=\n[\n0\nâˆ’\nc\nl\n,\nk\nb\nl\n,\nk\np\nl\n,\nk\nc\nl\n,\nk\n0\nâˆ’\na\nl\n,\nk\nq\nl\n,\nk\nâˆ’\nb\nl\n,\nk\na\nl\n,\nk\n0\nr\nl\n,\nk\n0\n0\n0\n0\n]\n.\n\\frac{\\partial T}{\\partial\\rho_{k}}=T_{1:k-1}[\\xi_{l,k}]T_{k:n_{l}}=\\begin{bmatrix}0&-c_{l,k}&b_{l,k}&p_{l,k}\\\\\nc_{l,k}&0&-a_{l,k}&q_{l,k}\\\\\n-b_{l,k}&a_{l,k}&0&r_{l,k}\\\\\n0&0&0&0\\end{bmatrix}.\n(5)\nEach derivative matrix\nâˆ‚\nT\nâˆ‚\nÏ\nk\n\\frac{\\partial T}{\\partial\\rho_{k}}\nbelongs to the Lie algebra\ns\nâ€‹\ne\nâ€‹\n(\n3\n)\nse(3)\nand contains six independent components.\nAccordingly, the 16 scalar equations implied by the zero-matrix condition reduce to six independent constraints, corresponding to the six degrees of freedom of a rigid body in 3D space.\nBy manipulating Equation\n5\nand applying the definition of the adjoint operator (Equations\nB9\nâ€“\nB11\n), each derivative term can be compactly expressed as\nâˆ‚\nT\nâˆ‚\nÏ\nk\n=\nT\n1\n:\nk\nâˆ’\n1\nâ€‹\n[\nÎ¾\nl\n,\nk\n]\nâ€‹\nT\n1\n:\nk\nâˆ’\n1\nâˆ’\n1\nâ‹…\nT\n=\n[\nAd\nT\n1\n:\nk\nâˆ’\n1\nâ€‹\n(\nÎ¾\nl\n,\nk\n)\n]\n.\n\\frac{\\partial T}{\\partial\\rho_{k}}=T_{1:k-1}[\\xi_{l,k}]T_{1:k-1}^{-1}\\cdot T=[\\mathrm{Ad}_{T_{1:k-1}}(\\xi_{l,k})].\n(6)\nThis is identical in form to the\nk\nth\nk^{\\text{th}}\ncolumn of the space Jacobian.\nHence, the loop closure constraint for the\nl\nth\nl^{\\text{th}}\nloop can be written using the\nloop space Jacobian\n:\nJ\ns\nl\n=\n[\nÎ¾\nl\n,\n1\nAd\nT\n1\n:\n1\nâ€‹\n(\nÎ¾\nl\n,\n2\n)\nâ‹¯\nAd\nT\n1\n:\nn\nl\nâˆ’\n1\nâ€‹\n(\nÎ¾\nl\n,\nn\nl\n)\n]\n,\nJ_{s}^{l}=\\begin{bmatrix}\\xi_{l,1}&\\mathrm{Ad}_{T_{1:1}}(\\xi_{l,2})&\\cdots&\\mathrm{Ad}_{T_{1:n_{l}-1}}(\\xi_{l,n_{l}})\\end{bmatrix},\n(7)\nwhere\nT\n1\n:\ni\nT_{1:i}\ncan be recursively evaluated through the exponential coordinates of motion.\nThis formulation provides a compact and efficient representation of the six independent closure constraints for each loop.\nRe-indexing all loop Jacobians to the global hinge coordinate vector\nÎ¸\n\\theta\nyields the configuration-dependent Pfaffian constraint matrix:\nA\nâ€‹\n(\nÎ¸\n)\nâ€‹\nÎ¸\nË™\n=\n[\nA\n1\nA\n2\nâ‹®\nA\nL\n]\nâ€‹\nÎ¸\nË™\n=\n0\n,\nA\nâ€‹\n(\nÎ¸\n)\nâˆˆ\nâ„\n6\nâ€‹\nL\nÃ—\nn\n.\nA(\\theta)\\dot{\\theta}=\\begin{bmatrix}A_{1}\\\\\nA_{2}\\\\\n\\vdots\\\\\nA_{L}\\end{bmatrix}\\dot{\\theta}=0,\\qquad A(\\theta)\\in\\mathbb{R}^{6L\\times n}.\n(8)\nwhere each\nA\nl\nA_{l}\ncorresponds to the loop Jacobian\nJ\ns\nl\nJ_{s}^{l}\nmapped to the appropriate global indices.\nThrough the use of screw-theoretic operators and adjoint transformations, the entire constraint formulation can thus be derived systematically and expressed in a unified coordinate.\nIn the case of non-perforated, single-sheet origami patterns, where all creases in a loop intersect at a common vertex,\nthe translational components of each loop constraint become linearly dependent on the rotational ones.\nThis special case can be rigorously derived within the same screw-theoretic framework and is summarized in Appendix\nB.4\n.\n3.â€ƒâ€Š Results and Discussion\nAcross all tested configurations, the proposed framework successfully generated valid constraint matrices and computed feasible folding angles for a wide variety of rigid-foldable structures, demonstrating robustness across diverse geometric complexities and structural configurations. Rather than focusing on solver performance alone, our open-source algorithm provides an integrated pipeline that takes pattern geometry encoded by the proposed data schema as input, computes equilibrium folding-angle trajectories by following prescribed crease neutral angles and stiffness distributions, and exports both numerical angle trajectories and corresponding visualizations within a single workflow.\nTo clarify how these feasible folding trajectories are obtained, we first summarize the underlying principle of the constraint-matrixâ€“based solver introduced by\n[\n8\n]\n, upon which our framework directly builds.\nAs schematically illustrated in Figure\n6\nA, the\nn\nn\n-dimensional hinge-variable space contains a lower-dimensional constraint-satisfying region defined by loop-closure conditions.\nThis region, referred to here as the\nreachable space\nand depicted in ivory, represents all admissible rigid-folding configurations.\nAlthough this reachable space cannot be explicitly identified or enumerated in high-dimensional settings, feasible folding trajectories can be explored by steering the configuration within it using prescribed neutral angles and joint stiffnesses.\nGiven a target neutral angle\nÎ¸\nÂ¯\n\\bar{\\theta}\n(red star in Figure\n6\nA) and assigned crease stiffness values, an initial update direction\nÎ”\nâ€‹\nÎ¸\ni\n0\n\\Delta\\theta_{i}^{0}\nis computed from the current configuration.\nThis direction reflects the energetic tendency toward the target configuration but does not, in general, satisfy the loop-closure constraints.\nThe solver therefore iteratively projects this update onto the reachable space, yielding a constraint-consistent increment that guides the configuration along a feasible folding trajectory.\nBy varying the target neutral angle\nÏ•\nÂ¯\n\\bar{\\phi}\n(blue star) and stiffness distribution, the same framework can reach multiple distinct configurations that all satisfy the closure constraints, revealing the multiplicity of admissible folding paths.\nThe local update mechanism is illustrated in Figures\n6\nB and\n6\nC.\nAt a converged configuration\nÎ¸\ni\nâˆ—\n\\theta_{i}^{*}\n, the reachable space is locally approximated by a linearized constraint plane characterized directly by the constraint matrix\nA\nâ€‹\n(\nÎ¸\ni\nâˆ—\n)\nA(\\theta_{i}^{*})\n.\nAn initial unconstrained update toward the target neutral angle, denoted\nÎ”\nâ€‹\nÎ¸\ni\n0\n\\Delta\\theta_{i}^{0}\n, is first computed based on energetic preference and is depicted as an open black arrow.\nBecause this update generally violates loop-closure constraints, it is orthogonally projected onto the linearized constraint plane (solid black line), producing a constraint-consistent increment\nÎ”\nâ€‹\nÎ¸\ni\n1\n\\Delta\\theta_{i}^{1}\n, shown as a filled black triangular arrow, which satisfies\nA\nâ€‹\n(\nÎ¸\ni\nâˆ—\n)\nâ€‹\nÎ”\nâ€‹\nÎ¸\ni\n1\n=\n0\nA(\\theta_{i}^{*})\\,\\Delta\\theta_{i}^{1}=0\n.\nResidual constraint violations are subsequently reduced through a Newtonâ€“Raphson iteration, visualized as the dotted trajectory converging toward the ideal reachable space.\nThe final converged update, indicated by a red triangular arrow, defines the next admissible configuration\nÎ¸\ni\n+\n1\nâˆ—\n\\theta_{i+1}^{*}\n.\nThis local projection-and-correction process is repeated iteratively to generate a continuous folding trajectory that remains fully consistent with loop-closure constraints.\nFigure 6\n:\nConstraint-matrixâ€“based feasible folding trajectory computation.\n(A) Conceptual illustration of exploring feasible trajectories within the reachable space embedded in the\nn\nn\n-dimensional hinge-variable space.\n(B) Local update at a converged configuration: an unconstrained energetic update\nÎ”\nâ€‹\nÎ¸\ni\n0\n\\Delta\\theta_{i}^{0}\n(open black arrow) is projected onto the linearized constraint plane (solid black line), yielding a constraint-consistent increment\nÎ”\nâ€‹\nÎ¸\ni\n1\n\\Delta\\theta_{i}^{1}\n(filled black arrow), followed by Newtonâ€“Raphson correction (dotted path) toward the next admissible configuration (red arrow).\n(C) Equivalent representation of the local update process viewed in the reduced plane spanned by\nÎ”\nâ€‹\nÎ¸\ni\n0\n\\Delta\\theta_{i}^{0}\nand\nÎ”\nâ€‹\nÎ¸\ni\n1\n\\Delta\\theta_{i}^{1}\n, highlighting the geometric relationship between unconstrained updates, constraint projection, and convergence.\nBuilding on this principle, we explored feasible folding trajectories by systematically varying the prescribed neutral angles and joint stiffness distributions.\nOur open-source implementation accepts a rigid-foldable pattern together with user-defined neutral angles and stiffness values, automatically computes constraint-consistent folding angles, and provides direct visualization of the resulting configurations.\nFigure\n7\npresents representative visualization results across diverse rigid-foldable structures, highlighting the range of geometric complexity, kinematic challenges, and folding behaviors that can be handled within a unified framework.\nFigure\n7\nA shows a triangular Resch pattern, a class of tessellated rigid origami known to deform between two distinct flat states\n[\n13\n,\n18\n,\n24\n]\n.\nWhile these end states are well documented, the transitional folding behavior connecting them is far less intuitive, and the kinematics of large Resch tessellations remain relatively unexplored.\nDespite the presence of 552 creases, the proposed framework robustly constructed the constraint matrix and successfully computed feasible folding trajectories across a wide range of intermediate configurations.\nBy adjusting the neutral angles and stiffness values assigned to individual creases, the solver revealed multiple distinct folding paths leading to the same final flat configuration.\nIn the upper row of Figure\n7\nA, all creases are activated uniformly, producing a rounded triangular shape with curvature developing along three principal directions before returning to a flat state.\nIn contrast, the lower row illustrates a trajectory in which curvature develops predominantly along a single direction: the pattern rolls cylindrically around an axis connecting opposite edges of the hexagonal boundary before reaching the fully folded flat state.\nBecause neutral angles and stiffness values are assigned directly using edge indices generated during tessellation, this process remains intuitive and readily automatable even for large-scale patterns.\nFigure\n7\nB presents a square pop-up kirigami mechanism consisting of a central square facet connected to four identical legs, each composed of five creases\n[\n23\n]\n.\nBased on geometric observation, estimated neutral angles were assigned to the creases with uniform stiffness across the structure.\nThe first row of Figure\n7\nB shows an axis-symmetric deployed configuration obtained by assigning identical neutral angles to creases of the same type on each leg.\nStarting from this axis-symmetric deployed state, we deliberately broke the symmetry to explore alternative feasible deformation modes.\nIn the second row of Figure\n7\nB, the leftmost image corresponds to the symmetric reference configuration, which is treated as a new initial state.\nBy guiding the solver toward the flat configuration as a new terminal state and biasing intermediate updates to selectively lower certain legs while elevating others, multiple asymmetric configurations were obtained.\nIn these visualizations, the semi-transparent ivory geometry denotes the symmetric reference configuration, while the colored geometries (red and blue) represent two distinct asymmetric modes.\nThe black arrow indicates the normal vector of the central square facet in the symmetric state, aligned with the vertical\nz\nz\n-axis, whereas the colored arrows indicate the corresponding normals in the asymmetric configurations.\nIn one mode, the central plate tilts forward relative to the viewing direction, while in the other it tilts laterally to the right.\nSuch symmetry-breaking deployable motions are especially difficult to analyze analytically, as they involve coupled rotations and translations that invalidate simple trigonometric descriptions.\nIn contrast, the proposed algorithm successfully captured the full loop-closure constraints and identified feasible folding configurations within the nonlinear reachable space while maintaining low residual errors, thereby preserving structural integrity throughout the deformation.\nFigure\n7\nC demonstrates a stacked Miura origami tessellation, representing a hinging-type multi-sheet structure defined using the extended data schema\n[\n14\n]\n.\nFor such configurations, manually identifying all independent closed loops is not only tedious but also highly error-prone; omission of even a single loop can distort the entire constraint relationship and invalidate feasible-angle computation.\nMoreover, traversing constraints across multiple sheets requires explicit treatment of translational components in loop-closure conditions, similar to kirigami structures, and the introduction of additional side hinges in three-dimensional layouts further complicates sign conventions.\nUsing the proposed data schema, each sheet-level pattern is generated independently, and inter-sheet hinging connections are specified directly between facet pairs.\nThe framework maps these relationships into a facetâ€“hinge graph and automatically extracts a minimal set of independent closure loops by computing the shortest cycles required for complete constraint enforcement.\nAdditional hinges arising between sheets are detected automatically, and their sign conventions and joint orientations are consistently assigned based on vertex-index ordering.\nAs shown in Figure\n7\nC, the framework robustly constructed constraint matrices for a structure with 144 creases and successfully identified feasible configurations despite the system possessing only a single degree of freedom and an extremely narrow reachable space.\nFigure\n7\nD presents a TMP tessellation, corresponding to soldering-type connections with zero separation distance\n[\n21\n]\n.\nAs in stacked Miura origami, this structure involves multiple sheets connected across layers, and therefore shares similar challenges in identifying closed loops and constructing constraint matrices that correctly couple rotational and translational motion.\nIn this case, soldered facet pairs are treated as a single rigid body, and no additional hinges are introduced.\nThe facetâ€“hinge graph correctly collapses these facets into unified nodes, yielding an exact yet reduced kinematic representation.\nBecause mountainâ€“valley sign conventions are inherited directly from the data schema and applied consistently on a per-sheet basis, feasible folding motions can be predicted purely from the sign pattern of the hinge variables.\nFigure\n7\nE illustrates thick-panel implementations of the Miura and Yoshimura patterns generated using a hinge-shifting technique.\nHere, pairs of facets are specified as soldered with a finite offset distance, representing thick panels connected by shifted hinges.\nWhen such soldered face pairs are parallel and separated by a finite offset, the framework automatically generates the necessary side panels and corresponding kinematic constraints from the geometric definition, without requiring explicit specification of auxiliary faces.\nBoth thick Miura and thick Yoshimura patterns yielded valid folding trajectories, demonstrating that the proposed formulation naturally accommodates thickness effects while preserving rigid-foldability.\nFigure 7\n:\nFolding simulations across representative rigid-foldable structures.\n(A) A 4-orbit triangular Resch pattern exhibiting distinct folding trajectories.\n(B) A square pop-up kirigami mechanism. Top: axis-symmetric deploy motion. Bottom: two asymmetric modes (red and blue) compared with the symmetric configuration (ivory).\n(C) A stacked Miura origami tessellation.\nFigure 8\n:\nContinuation of Figure\n7\n.\n(D) A TMP tessellation with soldered facets.\n(E) Thick-panel implementations of the Miura and Yoshimura patterns generated via hinge shifting.\nThese results demonstrate that the proposed framework can robustly construct constraint matrices and recover feasible folding trajectories across a wide spectrum of rigid-foldable structures, including large-scale tessellations, kirigami with translational motion, multi-sheet assemblies, and thick-panel implementations.\nTo understand how such generality and robustness are achieved with minimal user intervention, we next discuss the underlying data schema and modeling philosophy that distinguish the proposed approach from existing representations.\nWhile the widely adopted FOLD format\n[\n5\n]\nprovides an efficient and portable representation of origami geometry, it requires explicit per-edge type assignments (e.g., mountain, valley, or unknown) and pairwise layer-order specifications between faces.\nSimilarly, robotic modeling frameworks such as the URDF (Unified Robot Description Format)\n[\n12\n]\noffer standardized descriptions of articulated mechanisms but are inherently limited to tree-structured kinematic chains.\nTo represent mechanisms with closed loops, extensions such as URDF+\n[\n4\n]\nintroduce explicit loop-joint and coupling declarations, together with parsers that reconstruct the corresponding closure constraints.\nHowever, these approaches still depend on user-defined identification of which joints complete the kinematic cycles, rather than inferring those loops and constraints directly from the geometry itself.\nTaken together, these geometry- and mechanism-level representations rely heavily on manual annotationsâ€”whether edge and layer assignments in FOLD or loop-joint declarations in URDF+.\nIn contrast, our schema eliminates this manual step by defining mountain folds as positive and valley folds as negative hinge rotations, while automatically extracting loop structures from the given geometric information.\nThis enables global consistency of folding motion to emerge naturally without additional user input, substantially reducing modeling effort while preserving full kinematic fidelity.\nMoreover, the schema remains compatible with common visualization standards such as the VTK format, allowing seamless transfer between analysis and rendering environments.\nWhile the proposed data schema provides a compact and expressive description of geometry and connectivity, a principled kinematic formulation is still required to translate this information into enforceable motion constraints.\nTo this end, we employ screw theory to derive a unified, velocity-level representation of rigid-folding kinematics directly from the geometric primitives encoded in the schema.\nSpecifically, the following formulation expresses rigid-folding kinematics in a compact and coordinate-free manner.\nBecause rigid-body transformations and their adjoint mappings belong to the same Lie algebraic structure, configuration updates, velocity propagation, and constraint construction can all be expressed within a unified operator framework.\nOnce a configuration\nÎ¸\n\\theta\nis specified, the corresponding Jacobianâ€”and therefore the rows of the Pfaffian constraint matrixâ€”are obtained directly through adjoint transformations.\nEach row has a clear geometric interpretation as a local rigid-body constraint, enhancing both the intuitiveness and transparency of the formulation. Unlike conventional trigonometric or DH approaches that rely on manually defined local coordinates, this method operates directly on geometric primitives in initial configuration encoded in a minimal data schema.\n4.â€ƒâ€Š Conclusion\nThis study presented a unified kinematic framework for RFSs that systematically integrates geometric data, graph analogy, and screw-based constraint formulation.\nHere we explain three unique aspects of our unified framework for rigid foldable origami simulations.\nFirst, the proposed data schema directly encodes facets, hinges, and their inter-sheet connections in a compact and extensible form.\nThis representation eliminates the need for explicit mountainâ€“valley or pairwise face-order assignments, since hinge rotations are defined consistently by sign conventions and sheet-wise orientation.\nSuch structure allows straightforward extension to multi-layer and thick-panel configurations without modifying the underlying formulation.\nSecond, the facetâ€“hinge graph provides an explicit representation of kinematic connectivity.\nBy extracting a minimum cycle basis, the method identifies a complete yet non-redundant set of closure loops that capture all independent kinematic constraints.\nThis graph-theoretic perspective ensures scalability to large, tessellated foldable systems where explicit constraint definition would otherwise be intractable.\nThird, screw alignment along each loop enables the automatic construction of the configuration-dependent constraint matrix.\nBy integrating rotational and translational motion within a single representation, the framework provides a compact, coordinate-free means to compute the Pfaffian constraint matrix and analyze feasible folding directions at any configuration.\nTogether, these components form a unified and geometrically intuitive approach for modeling the kinematics of rigid-foldable structures, offering both conceptual clarity and computational scalability.\nDespite these advantages, several limitations remain.\nThe current formulation assumes perfectly rigid panels and idealized hinges, neglecting elastic deformations that may arise in physical implementations.\nIn addition, for mechanisms with a single degree of freedom but many interconnected hinges, the feasible motion subspace can be extremely narrow, making configuration search computationally demanding.\nWhile the constraint matrix characterizes instantaneous admissible motions, it does not by itself guarantee global reachability across the entire configuration space.\nNevertheless, the automated construction of\nA\nâ€‹\n(\nÎ¸\n)\nA(\\theta)\nsignificantly simplifies this search process, serving as a powerful tool for exploring feasible folding motions and initializing more advanced numerical solvers.\nFinally, while screw theory provides strong geometric and physical intuition, it can be computationally demanding for large-scale systems.\nThis observation motivates future work on developing more numerically efficient formulations that retain the same geometric foundation while improving scalability for high-dimensional simulations.\nBeyond kinematic analysis, the proposed formulation also opens clear directions for future dynamic studies.\nBecause the constraint matrix is expressed explicitly at the velocity level, it naturally provides a foundation for dynamic simulation, control, and optimization frameworks that incorporate inertia, actuation, and hinge torsion effects.\nConflicts of Interest\nThe authors declare no conflict of interest.\nAuthor Contributions\nDongwook Kwak\n: Conceptualization, Methodology, Software, Writing-original draft, Visualization.\nGeonhee Cho\n: Methodology, Software, Visualization, Writing-review & editing.\nJiook Chung\n: Software, Visualization, Writing-review & editing.\nJinkyu Yang\n: Supervision, Funding Acquisition, Writing-review & editing\nFunding\nWe acknowledge the support from Air Force Office of Scientific Research (FA2386-24-1-4051), SNU-IAMD, SNU-IOER, and National Research Foundation grants funded by the Korean government (2023R1A2C2003705 and 2022H1D3A2A03096579).\nData Availability\nAll codes, example files, and usage demonstrations developed in this study are publicly available as open-source resources on our GitHub repository:\nhttps://github.com/dongwookkwak/Kinematic_Simulation_of_Rigid_Foldable_Structures\n.\nThe repository provides complete implementations of the proposed pipeline, along with reproducible examples for constructing and analyzing rigid-foldable structuresâ€™ kinematics.\nAcknowledgments\nWe thank Professor Tomohiro Tachi (University of Tokyo) and Professor Glaucio Paulinoâ€™s team (Princeton University) for their valuable discussions.\nReferences\n[1]\nY. Chen, H. Feng, J. Ma, R. Peng, and Z. You\n(2016)\nSymmetric waterbomb origami\n.\nProceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences\n472\n(\n2190\n),\npp.Â 20150846\n.\nExternal Links:\nDocument\nCited by:\nÂ§1\n.\n[2]\nY. Chen, R. Peng, and Z. You\n(2015)\nOrigami of thick panels\n.\nScience\n349\n(\n6246\n),\npp.Â 396â€“400\n.\nExternal Links:\nDocument\n,\nLink\n,\nhttps://www.science.org/doi/pdf/10.1126/science.aab2870\nCited by:\nÂ§1\n.\n[3]\nZ. Chen, B. Tighe, and J. Zhao\n(2022-08)\nOrigami-inspired modules enable a reconfigurable robot with programmable shapes and motions\n.\nIEEE/ASME Transactions on Mechatronics\n27\n,\npp.Â 1â€“10\n.\nExternal Links:\nDocument\nCited by:\nÂ§1\n.\n[4]\nM. Chignoli, J. Slotine, P. M. Wensing, and S. Kim\n(2024)\nURDF+: an enhanced urdf for robots with kinematic loops\n.\nIn\n2024 IEEE-RAS 23rd International Conference on Humanoid Robots (Humanoids)\n,\nVol.\n,\npp.Â 197â€“204\n.\nExternal Links:\nDocument\nCited by:\nÂ§3\n.\n[5]\nJ. S. K. Erik D. Demaine and R. J. Lang\n(2016)\nA new file standard to represent folded structures\n.\nIn\nAbstracts from the 26th Fall Workshop on Computational Geometry\n,\nBrandeis University, Waltham, MA\n.\nCited by:\nÂ§3\n.\n[6]\nA. Ghassaei, E. D. Demaine, and N. Gershenfeld\n(2018)\nFast, interactive origami simulation using gpu computation\n.\nOrigami\n7\n,\npp.Â 1151â€“1166\n.\nCited by:\nÂ§1\n.\n[7]\nJ. D. Horton\n(1987)\nA polynomial-time algorithm to find the shortest cycle basis of a graph\n.\nSIAM Journal on Computing\n16\n(\n2\n),\npp.Â 358â€“366\n.\nExternal Links:\nDocument\nCited by:\nÂ§2.3\n.\n[8]\nY. Hu and H. Liang\n(2020)\nFolding simulation of rigid origami with lagrange multiplier method\n.\nInternational Journal of Solids and Structures\n202\n,\npp.Â 552â€“561\n.\nExternal Links:\nISSN 0020-7683\n,\nDocument\n,\nLink\nCited by:\nÂ§3\n.\n[9]\nE. Lerner, Z. Chen, and J. Zhao\n(2024-10)\nReconfigurable origami with variable stiffness joints for adaptive robotic locomotion and grasping\n.\nPhilosophical Transactions A\n382\n,\npp.\n.\nExternal Links:\nDocument\nCited by:\nÂ§1\n.\n[10]\nK. Liu and G. H. Paulino\n(2017-10)\nNonlinear mechanics of non-rigid origami: an efficient computational approachâ€ \n.\nProceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences\n473\n(\n2206\n),\npp.Â 20170348\n.\nExternal Links:\nISSN 1364-5021\n,\nDocument\n,\nLink\n,\nhttps://royalsocietypublishing.org/rspa/article-pdf/doi/10.1098/rspa.2017.0348/365835/rspa.2017.0348.pdf\nCited by:\nÂ§1\n.\n[11]\nK. M. Lynch and F. C. Park\n(2017)\nModern robotics: mechanics, planning, and control\n.\n1st edition\n,\nCambridge University Press\n,\nUSA\n.\nExternal Links:\nISBN 1107156300\nCited by:\nAppendix B\n.\n[12]\nM. Quigley, B. Gerkey, and W. D. Smart\n(2015)\nProgramming robots with ros: a practical introduction to the robot operating system\n.\n1st edition\n,\nOâ€™Reilly Media, Inc.\n.\nExternal Links:\nISBN 1449323898\nCited by:\nÂ§3\n.\n[13]\nR. D. Resch and H. Christiansen\n(1970)\nThe design and analysis of kinematic folded plate systems\n.\nProceedings of IASS Symposium on Folded Plates and Prismatic Structures\n.\nCited by:\nÂ§3\n.\n[14]\nM. Schenk and S. D. Guest\n(2013)\nGeometry of miura-folded metamaterials\n.\nProceedings of the National Academy of Sciences\n110\n(\n9\n),\npp.Â 3276â€“3281\n.\nCited by:\nÂ§1\n,\nÂ§3\n.\n[15]\nH. Sun, C. Zhao, K. Wang, H. Zhao, M. Hongye, L. Zhang, J. Xue, and L. Zhang\n(2024-01)\nShape editing of kirigami-inspired thick-panel deployable structure\n.\nMechanism and Machine Theory\n191\n,\npp.Â 105471\n.\nExternal Links:\nDocument\nCited by:\nÂ§1\n.\n[16]\nK. Suto, Y. Noma, K. Tanimichi, K. Narumi, and T. Tachi\n(2023-09)\nCrane: an integrated computational design platform for functional, foldable, and fabricable origami products\n.\nACM Trans. Comput.-Hum. Interact.\n30\n(\n4\n).\nExternal Links:\nISSN 1073-0516\n,\nLink\n,\nDocument\nCited by:\nÂ§1\n.\n[17]\nT. Tachi\n(2009)\nSimulation of rigid origami\n.\nOrigami 4\n,\npp.Â 175\n.\nCited by:\nÂ§B.4\n,\nÂ§1\n.\n[18]\nT. Tachi\n(2013)\nDesigning freeform origami tessellations by generalizing reschâ€™s patterns\n.\nJournal of mechanical design\n135\n(\n11\n),\npp.Â 111006\n.\nCited by:\nÂ§3\n.\n[19]\nC. Wang, D. Zhang, J. Li, Y. Li, and X. Zhang\n(2024)\nDeployment dynamics of thick panel miura-origami\n.\nAerospace Science and Technology\n144\n,\npp.Â 108795\n.\nExternal Links:\nISSN 1270-9638\n,\nDocument\n,\nLink\nCited by:\nÂ§1\n.\n[20]\nF. Yang, M. Zhang, J. Ma, Z. You, Y. Yu, Y. Chen, and G. H. Paulino\n(2022)\nDesign of single degree-of-freedom triangular resch patterns with thick-panel origami\n.\nMechanism and Machine Theory\n169\n,\npp.Â 104650\n.\nExternal Links:\nISSN 0094-114X\n,\nDocument\n,\nLink\nCited by:\nÂ§1\n.\n[21]\nH. Yasuda and J. Yang\n(2015)\nReentrant origami-based metamaterials with negative poissonâ€™s ratio and bistability\n.\nPhys. Rev. Lett.\n114\n,\npp.Â 185502\n.\nExternal Links:\nDocument\n,\nLink\nCited by:\nÂ§3\n.\n[22]\nH. Yasuda, T. Yein, T. Tachi, K. Miura, and M. Taya\n(2013)\nFolding behaviour of tachiâ€“miura polyhedron bellows\n.\nProceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences\n469\n(\n2159\n),\npp.Â 20130351\n.\nCited by:\nÂ§1\n.\n[23]\nT. Yoneda and H. Wada\n(2022)\nStructure, design, and mechanics of a pop-up origami with cuts\n.\nPhysical Review Applied\n17\n(\n2\n),\npp.Â L021004\n.\nExternal Links:\nDocument\nCited by:\nÂ§3\n.\n[24]\nY. Yu, Y. Chen, and G. Paulino\n(2023)\nProgramming curvatures by unfolding of the triangular resch pattern\n.\nInternational Journal of Mechanical Sciences\n238\n,\npp.Â 107861\n.\nExternal Links:\nISSN 0020-7403\n,\nDocument\n,\nLink\nCited by:\nÂ§3\n.\n[25]\nY. Zhang, M. Li, Y. Chen, R. Peng, and X. Zhang\n(2023-01)\nThick-panel origami-based parabolic cylindrical antenna\n.\nMechanism and Machine Theory\n182\n,\npp.Â 105233\n.\nExternal Links:\nDocument\nCited by:\nÂ§1\n.\n[26]\nY. Zhu and E. Filipov\n(2024-03)\nLarge-scale modular and uniformly thick origami-inspired adaptable and load-carrying structures\n.\nNature Communications\n15\n,\npp.\n.\nExternal Links:\nDocument\nCited by:\nÂ§1\n.\n[27]\nY. Zhu, M. Schenk, and E. Filipov\n(2022-07)\nA review on origami simulations: from kinematics, to mechanics, towards multi-physics\n.\nApplied Mechanics Reviews\n74\n,\npp.\n.\nExternal Links:\nDocument\nCited by:\nÂ§1\n.\nAppendix\nAppendix A\nComputational Pipeline for Kinematic Constraint Generation\nThe kinematic analysis of an arbitrary Rigid Foldable Structure (RFS) is automated through a computational pipeline that transforms a geometric definition into a complete velocity-level constraint matrix. This process ensures that all kinematic dependencies, including coupled rotation and translation, are systematically captured. The pipeline proceeds through four principal stages: graph construction from the data schema, minimal loop extraction, consistent screw assignment, and final matrix assembly using screw theory.\nA.1\nConvention for Data Schema\nEach sheet designates a seed facet whose orientation (clockwise or counterclockwise) serves as the reference for the entire sheet.\nAll facets within a sheet must be defined as valid, non-self-intersecting polygons, and their vertex indices must be ordered consistently in a single direction so that the sheet maintains a uniform orientation.\nOnce the seed facet is defined, the orientations of all remaining facets are automatically aligned through shared pattern edges:\nfor each pair of adjacent facets, the shared edge must appear in opposite vertex order within their respective vertex lists\n(e.g.,\n[\nâ‹¯\n,\nv\na\n,\nv\nb\n,\nâ‹¯\n]\n[\\cdots,v_{a},v_{b},\\cdots]\nin one facet and\n[\nâ‹¯\n,\nv\nb\n,\nv\na\n,\nâ‹¯\n]\n[\\cdots,v_{b},v_{a},\\cdots]\nin its neighbor).\nThis opposite ordering enables the algorithm to infer and propagate consistent facet orientations across the sheet based solely on vertex indices,\nensuring that all hinge rotations follow a coherent mountainâ€“valley convention without additional user input.\nWhen multiple facets from one sheet are connected to another sheet, all such connections must share the same connection type\nx\nâˆˆ\n{\nh\n,\ns\n}\nx\\in\\{h,s\\}\n.\nFor example, if facet\nf\n00\nf_{00}\nof sheet 0 and facet\nf\n10\nf_{10}\nof sheet 1 are joined through a hinging-type connection (\nx\n=\nh\nx=h\n),\nall remaining facet pairs between the same two sheets must also be of type\nh\nh\n.\nMixed connection typesâ€”such as\n[\nf\n00\n,\nf\n10\n,\nh\n]\n[f_{00},f_{10},h]\nand\n[\nf\n01\n,\nf\n11\n,\ns\n]\n[f_{01},f_{11},s]\nbetween the same sheet pairâ€”are not permitted.\nIn such cases, the sheet should instead be divided into separate sub-sheets with distinct connection types.\nFor hinging-type connections (\nx\n=\nh\nx=h\n), an identical edge with coincident vertex coordinates must exist between the two facets.\nIf no such shared edge is found, the connection is deemed invalid.\nIf multiple coincident edges are detected between the same facet pair, the user may explicitly specify which edge index serves as the active hinge.\nThat selected edge is treated as the valid rotational joint, while all other overlapping edges are regarded as non-hinging pattern edges.\nIf the user does not specify an active hinge, multiple coincident hinging edges are automatically treated as a soldering-type connection, and an error is reported.\nIn all cases, one facet pair must correspond to at most one hinging edge.\nFor cylindrical, spherical, or otherwise closed-topology patterns, the geometry may be divided into two or more sheets along non-creasing boundaries.\nThese boundary edges can then be reconnected using hinging-type links, enabling the framework to assign consistent mountainâ€“valley conventions within each sheet while maintaining global kinematic consistency.\nHowever, mountainâ€“valley labeling cannot be intuitively preserved across multiple sheets in three-dimensional space,\nbecause the distinction between â€œtopâ€ and â€œbottomâ€ depends on the observerâ€™s perspective and the local embedding of each sheet.\nAs a result, the same physical rotation may appear as a mountain fold in one viewpoint and a valley fold in another.\nTo address this, the algorithm checks inter-sheet consistency and, whenever a discrepancy arises, reports the positive hinge-axis orientation associated with each user-specified connection record\n[\nf\n1\n,\nf\n2\n,\nh\n]\n[f_{1},f_{2},h]\n.\nBy explicitly printing the screw direction from facet\nf\n1\nf_{1}\ntoward\nf\n2\nf_{2}\n, the framework enables users to confirm how the sign of a hinge variable corresponds to the actual folding motion.\nThis provides both intuitive interpretability and geometric traceability of inter-sheet connections.\nFacet pairs sharing only a single vertex or forming self-intersecting boundaries are excluded as invalid configurations when they belong to the same sheet (intra-sheet case).\nHowever, if such contacts occur between different sheets (inter-sheet case), they are automatically interpreted as soldering-type connections.\nBefore graph construction, the framework automatically verifies the validity of the data schema by checking\n(i) consistency of connection types, (ii) alignment of facet orientations inherited from each seed facet, and (iii) the presence of closed-loop validity.\nA.2\nFacet-Hinge Graph Construction from Data Schema\nThe pipeline commences with the RFS Information Data Schema, the minimal geometric input. This schema is a layer-wise extension of the conventional (V, E, F, C) representation, explicitly defining vertices (\nv\ni\nâ€‹\nj\nv_{ij}\n), pattern edges (\ne\ni\nâ€‹\nj\ne_{ij}\n), and facets (\nf\ni\nâ€‹\nj\nf_{ij}\n) on a per-sheet basis. Crucially, it also includes a list of sheet-wise connections (\nc\nÎ±\nc_{\\alpha}\n) that specify how different layersâ€™ facets interact. This input is algorithmically converted into a Facet-Hinge Graph. In this graph, each facet\nf\ni\nâ€‹\nj\nf_{ij}\nis represented as a node.\nGraph edges are created based on connectivity:\n1.\nIntra-sheet connections:\nThe algorithm identifies shared pattern edges. Since each facet\nf\ni\nâ€‹\nj\nf_{ij}\nis an ordered list of vertex indices, and its orientation (e.g., CW or CCW) is defined consistently from a seed facet, a shared boundary between two adjacent facets is algorithmically identified by finding an oppositely ordered vertex pair (e.g.,\n(\nv\na\n,\nv\nb\n)\n(v_{a},v_{b})\nin one facetâ€™s list and\n(\nv\nb\n,\nv\na\n)\n(v_{b},v_{a})\nin the otherâ€™s). This shared edge becomes a graph edge. The 3D vertex coordinates\nv\na\n,\nv\nb\nâˆˆ\nâ„\n3\nv_{a},v_{b}\\in\\mathbb{R}^{3}\ndirectly define the initial screw parameters for this hinge: the rotation axis is computed as\nÏ‰\n=\n(\nv\nb\nâˆ’\nv\na\n)\n/\nâ€–\nv\nb\nâˆ’\nv\na\nâ€–\n\\omega=(v_{b}-v_{a})/\\|v_{b}-v_{a}\\|\n, and a point on the axis is\nq\n=\nv\na\nq=v_{a}\n(or\nv\nb\nv_{b}\n).\n2.\nInter-sheet connections:\nThe connection list\nc\nÎ±\nc_{\\alpha}\nspecifies two facet indices and a type\nx\nâˆˆ\n{\nh\n,\ns\n}\nx\\in\\{h,s\\}\n. If the type is\nx\n=\ns\nx=s\n(soldering), no screw is required, as the corresponding facet nodes are simply merged into a single node. If the type is\nx\n=\nh\nx=h\n(hinging), the algorithm performs a geometric comparison of the 3D coordinates of the vertices for both facets to identify shared boundary edges. A kinematic ambiguity arises if the facets share two or more non-collinear edges; hinging along multiple distinct axes would lock the relative motion, effectively creating a soldered connection. Therefore, if the geometric comparison identifies multiple potential hinge edges, the algorithm make user select only one of them to define the single inter-sheet screw axis. A new graph edge, representing this single revolute joint, is then created between the facet nodes.\nThis automated conversion translates the geometric data into a topological representation of kinematic connectivity, with all necessary screw parameters derived directly from the vertex coordinates.\nA.3\nGlobal Screw Assignment\nOnce the independent loops are identified via the MCB, the set of hinges (graph edges) that participate in these basis loops are identified as the kinematically active screws. Hinges not belonging to any loop in the MCB are kinematically irrelevant and excluded from the set of\nn\nn\njoint variables,\nÎ¸\n\\theta\n. Each of these\nn\nn\nactive screws must be assigned a consistent screw axis\nÎ¾\ni\n\\xi_{i}\nto represent its rotational motion. This step is critical for avoiding sign conflicts in the global constraint equations.\nThis assignment process relies on a fundamental precondition: the RFS, and all its constituent loops, must be\norientable\n. This ensures that a globally consistent â€˜frontâ€™ and â€˜backâ€™ (or â€˜mountainâ€™/â€˜valleyâ€™) can be defined without encountering a topological contradiction (e.g., a MÃ¶bius strip). Given this precondition, the assignment is a two-stage process:\n1.\nBase Orientation (BO) Establishment:\nA globally consistent relative orientation is algorithmically established. This is possible because the graph formed by the\nL\nL\nminimal cycles (where cycles are nodes and shared hinges are edges) is a connected graph. Therefore, a single seed facet in one minimal cycle is chosen to fix its traversal direction. This assignment propagates deterministically through the entire connected graph: once a hingeâ€™s orientation (\nÎ¾\ni\n\\xi_{i}\n) is fixed, it forces the traversal direction of any other cycle in the MCB that contains it. This process repeats until all\nn\nn\nactive screws possess an internally consistent relative orientation\n2.\nSheet Polarity Application:\nThe established BO is reconciled with the user-defined sheet polarity. The data schema allows a seed facet per sheet, which defines the userâ€™s desired â€˜positiveâ€™ rotation (e.g., mountain fold). The algorithm applies this per-sheet definition as a sign correction to the BO, subject to a validity check:\nâ€¢\nValid Sheet:\nA sheet is valid if all its constituent hinges are â€˜in-phaseâ€™ (i.e., must move in the same relative direction) according to the globally established BO. The userâ€™s seed can then validly assign a single polarity (e.g., â€˜all mountainâ€™ or â€˜all valleyâ€™) to this entire group.\nâ€¢\nInvalid Sheet:\nA sheet is invalid if it attempts to group hinges that the BO has already determined must move in â€˜opposite-phaseâ€™. Such a definition is topologically contradictory, as it commands kinematically opposed elements to move as one.\nThe framework assumes all user-defined sheets are valid. The final set of\nn\nn\nscrew axes\n{\nÎ¾\ni\n}\n\\{\\xi_{i}\\}\nthus reflects both the global kinematic consistency (from the BO) and the desired local folding polarity (from the valid sheet seeds).\nAppendix B\nScrew Theory for Rigid Body Motions\nThis section introduces the mathematical foundation for describing rigid body motions and spatial kinematics using Lie group and Lie algebra formulations. Based on the Chaslesâ€“Mozzi theorem, we demonstrate that any rigid motion can be expressed as a screw motion, compactly encoded by a 6-dimensional screw axis. Using exponential coordinates, we provide closed-form expressions for transformations, which naturally lead to the Product of Exponentials (PoE) formulation for forward kinematics. We then introduce spatial velocities (twists) and adjoint mappings that enable frame transformations of motion representations. This framework also leads to the definition of the space Jacobian, which maps joint velocities to the space twist.\nTogether, these tools form a coherent foundation for analyzing the rigid body kinematics of any rigid and foldable structures. The notations and formulations used in the following sections are based on the framework presented in\n[\n11\n]\n, which also provides further details on the theoretical foundations of this approach.\nB.1\nExponential Coordinate Representations\nRigid body motion in three-dimensional space is commonly represented as an element of the Special Euclidean group\nS\nâ€‹\nE\nâ€‹\n(\n3\n)\nSE(3)\n, which combines rotation and translation in a single homogeneous transformation matrix. Consider two coordinate frames\n{\n1\n}\n\\{1\\}\nand\n{\n2\n}\n\\{2\\}\n. As illustrated in Figure\nB1\nA, the transformation from frame\n{\n1\n}\n\\{1\\}\nto frame\n{\n2\n}\n\\{2\\}\ncan be expressed as:\nT\n1\n,\n2\n=\n[\nR\n1\n,\n2\np\n1\n,\n2\n0\n1\n]\nâˆˆ\nS\nâ€‹\nE\nâ€‹\n(\n3\n)\n,\nT_{1,2}=\\begin{bmatrix}R_{1,2}&p_{1,2}\\\\\n0&1\\end{bmatrix}\\in SE(3),\n(B1)\nwhere\nR\n1\n,\n2\nâˆˆ\nS\nâ€‹\nO\nâ€‹\n(\n3\n)\nR_{1,2}\\in SO(3)\nis a\n3\nÃ—\n3\n3\\times 3\nrotation matrix belonging to the Special Orthogonal group, and\np\n1\n,\n2\nâˆˆ\nâ„\n3\np_{1,2}\\in\\mathbb{R}^{3}\nis a translation vector.\nFor convenience, the transformation\nT\n1\n,\n2\nT_{1,2}\nis often denoted as the pair\n(\nR\n1\n,\n2\n,\np\n1\n,\n2\n)\n(R_{1,2},p_{1,2})\n. The subscripts\n1\n,\n2\n{1,2}\nindicate that this transformation maps coordinates from frame\n{\n1\n}\n\\{1\\}\n(the source frame) to frame\n{\n2\n}\n\\{2\\}\n(the target frame).\nFigure B1\n:\nRigid body motion (A) Rigid body motion represented by transformation from frame\n{\n1\n}\n\\{1\\}\nto frame\n{\n2\n}\n\\{2\\}\n(B) Rigid body motion represented as a screw motion from frame\n{\n1\n}\n\\{1\\}\nto frame\n{\n2\n}\n\\{2\\}\nAccording to the Chaslesâ€“Mozzi theorem, any rigid body motion can be represented as a screw motion, illustrated in Figure\nB1\n(B). The screw motion consists of a rotation about a fixed axis and a translation along that axis. The amount of translation per unit rotation is called the pitch, denoted by\nh\nh\n, which is equal to the ratio of linear speed to angular speed. In the case of a pure rotation (e.g., a revolute joint), the pitch\nh\nh\nbecomes zero.\nA screw motion is characterized by a\nscrew axis\nÎ¾\nâˆˆ\nâ„\n6\n\\xi\\in\\mathbb{R}^{6}\n, a 6-dimensional vector that combines rotational and translational motion:\nÎ¾\n=\n[\nÏ‰\nv\n]\nâˆˆ\nâ„\n6\n,\n\\xi=\\begin{bmatrix}\\omega\\\\\nv\\end{bmatrix}\\in\\mathbb{R}^{6},\n(B2)\nwhere\nÏ‰\nâˆˆ\nâ„\n3\n\\omega\\in\\mathbb{R}^{3}\nis a vector representing the axis of rotation, and\nv\nâˆˆ\nâ„\n3\nv\\in\\mathbb{R}^{3}\nis computed as\nv\n=\nâˆ’\nÏ‰\nÃ—\nq\n+\nh\nâ€‹\nÏ‰\n,\nv=-\\omega\\times q+h\\omega,\n(B3)\nwith\nq\nq\nbeing any point on the screw axis in the reference frame and\nh\nh\ndenoting the pitch.\nThe 4-by-4 matrix representation of the screw\nÎ¾\n\\xi\nis an element of the Lie algebra\ns\nâ€‹\ne\nâ€‹\n(\n3\n)\nse(3)\n:\n[\nÎ¾\n]\n=\n[\n[\nÏ‰\n]\nv\n0\n0\n]\nâˆˆ\ns\nâ€‹\ne\nâ€‹\n(\n3\n)\n,\n[\\xi]=\\begin{bmatrix}[\\omega]&v\\\\\n0&0\\end{bmatrix}\\in se(3),\n(B4)\nwhere\n[\nÏ‰\n]\nâˆˆ\ns\nâ€‹\no\nâ€‹\n(\n3\n)\n[\\omega]\\in so(3)\nis the skew-symmetric matrix corresponding to\nÏ‰\n=\n(\nÏ‰\n1\n,\nÏ‰\n2\n,\nÏ‰\n3\n)\n\\omega=(\\omega_{1},\\omega_{2},\\omega_{3})\n:\n[\nÏ‰\n]\n=\n[\n0\nâˆ’\nÏ‰\n3\nÏ‰\n2\nÏ‰\n3\n0\nâˆ’\nÏ‰\n1\nâˆ’\nÏ‰\n2\nÏ‰\n1\n0\n]\n.\n[\\omega]=\\begin{bmatrix}0&-\\omega_{3}&\\omega_{2}\\\\\n\\omega_{3}&0&-\\omega_{1}\\\\\n-\\omega_{2}&\\omega_{1}&0\\end{bmatrix}.\n(B5)\nDepending on whether the rotational component\nÏ‰\n\\omega\nis nonzero, a screw motion falls into one of two cases.\nWhen\nâ€–\nÏ‰\nâ€–\n=\n1\n\\|\\omega\\|=1\n, corresponding to a screw motion with rotation, the rigid-body transformation for a motion magnitude\nÎ¸\n\\theta\ncan be computed using the matrix exponential:\nT\nâ€‹\n(\nÎ¸\n)\n=\ne\n[\nÎ¾\n]\nâ€‹\nÎ¸\n=\n[\ne\n[\nÏ‰\n]\nâ€‹\nÎ¸\nG\nâ€‹\n(\nÎ¸\n)\nâ€‹\nv\n0\n1\n]\n.\nT(\\theta)=e^{[\\xi]\\theta}=\\begin{bmatrix}e^{[\\omega]\\theta}&G(\\theta)v\\\\\n0&1\\end{bmatrix}.\nThe rotation matrix\ne\n[\nÏ‰\n]\nâ€‹\nÎ¸\ne^{[\\omega]\\theta}\nis given by Rodriguesâ€™ formula:\ne\n[\nÏ‰\n]\nâ€‹\nÎ¸\n=\nI\n3\n+\nsin\nâ¡\nÎ¸\nâ€‹\n[\nÏ‰\n]\n+\n(\n1\nâˆ’\ncos\nâ¡\nÎ¸\n)\nâ€‹\n[\nÏ‰\n]\n2\n.\ne^{[\\omega]\\theta}=I_{3}+\\sin\\theta[\\omega]+(1-\\cos\\theta)[\\omega]^{2}.\nThe matrix\nG\nâ€‹\n(\nÎ¸\n)\nG(\\theta)\ncouples the translational part of the motion and is defined as:\nG\nâ€‹\n(\nÎ¸\n)\n=\nI\n3\nâ€‹\nÎ¸\n+\n(\n1\nâˆ’\ncos\nâ¡\nÎ¸\n)\nâ€‹\n[\nÏ‰\n]\n+\n(\nÎ¸\nâˆ’\nsin\nâ¡\nÎ¸\n)\nâ€‹\n[\nÏ‰\n]\n2\n,\nG(\\theta)=I_{3}\\theta+(1-\\cos\\theta)[\\omega]+(\\theta-\\sin\\theta)[\\omega]^{2},\nwhere\nI\nk\nI_{k}\ndenotes the\nk\nÃ—\nk\nk\\times k\nidentity matrix.\nIn contrast, when\nâ€–\nÏ‰\nâ€–\n=\n0\n\\|\\omega\\|=0\n, the screw represents a pure translation. In this case,\nâ€–\nv\nâ€–\n=\n1\n\\|v\\|=1\n, where\nv\nv\nis a unit vector that describes the translation direction. The transformation can be further reduced to:\nT\nâ€‹\n(\nÎ¸\n)\n=\n[\nI\n3\nv\nâ€‹\nÎ¸\n0\n1\n]\n.\nT(\\theta)=\\begin{bmatrix}I_{3}&v\\theta\\\\\n0&1\\end{bmatrix}.\nIn this context,\nS\nâ€‹\nE\nâ€‹\n(\n3\n)\nSE(3)\nand\nS\nâ€‹\nO\nâ€‹\n(\n3\n)\nSO(3)\nare Lie groups representing smooth manifolds of rigid body transformationsâ€”\nS\nâ€‹\nE\nâ€‹\n(\n3\n)\nSE(3)\nfor combined rotation and translation, and\nS\nâ€‹\nO\nâ€‹\n(\n3\n)\nSO(3)\nfor pure rotation. Their associated Lie algebras,\ns\nâ€‹\ne\nâ€‹\n(\n3\n)\nse(3)\nand\ns\nâ€‹\no\nâ€‹\n(\n3\n)\nso(3)\n, correspond to instantaneous rigid body motions. The matrices\n[\nÏ‰\n]\nâˆˆ\ns\nâ€‹\no\nâ€‹\n(\n3\n)\n[\\omega]\\in so(3)\nand\n[\nÎ¾\n]\nâˆˆ\ns\nâ€‹\ne\nâ€‹\n(\n3\n)\n[\\xi]\\in se(3)\nlie in these Lie algebras, and the exponential map provides the bridge from these algebraic structures to the finite rigid body motions described by the Lie groups.\nB.2\nForward Kinematics and Product of Exponentials\nFigure B2\n:\nPre-multiplying the transformation matrix operates in the fixed frame\nIn Figure\nB2\n, let\n{\ns\n}\n\\{s\\}\ndenote a fixed space frame and\n{\nb\n}\n\\{b\\}\na moving body frame. The configuration of the body frame relative to the space frame is represented by the transformation matrix\nT\ns\n,\nb\nâˆˆ\nS\nâ€‹\nE\nâ€‹\n(\n3\n)\nT_{s,b}\\in SE(3)\n. When a transformation matrix\nT\nT\nis applied via pre-multiplication, it is interpreted as a transformation with respect to the fixed space frame. For example, in the figure, if\nT\n=\nRot\nâ€‹\n(\nz\n,\nÎ¸\n)\nT=\\mathrm{Rot}(z,\\theta)\nrepresents a rotation about the\nz\nz\n-axis, then pre-multiplying\nT\nT\nto\nT\ns\n,\nb\nT_{s,b}\nyields\nT\ns\n,\nb\nâ€²\n=\nT\nâ€‹\nT\ns\n,\nb\nT_{s,b^{\\prime}}=T\\,T_{s,b}\n, which corresponds to rotating the body frame\n{\nb\n}\n\\{b\\}\nabout the global\nZ\nZ\n-axis of the space frame.\nFigure B3\n:\nExample of an open-chain origami (A) the home position (B) after crease rotation\nNow, Consider the open-chain rigid origami structure shown in Figure\nB3\n, which consists of four facets connected by three joints. The leftmost square facet is fixed to the ground and serves as the space frame; thus, it is not counted as part of the kinematic chain. The remaining three facets are treated as rigid links.\nThe configuration in which all crease (or joint) angles are zero, i.e.,\nÎ¸\n=\n(\n0\n,\n0\n,\n0\n)\n\\theta=(0,0,0)\n, is referred to as the\nhome position\n. This typically corresponds to the initial unfolded pattern of a rigid-foldable structure, which is assumed to be known a priori. The home position provides a convenient and systematic way to initialize the model, as the screw axes and local facet frames can be derived directly from geometric informationâ€”namely, vertex coordinates and the connectivity among edges and facets. Since this geometric representation encodes the entire structural topology, the home configuration serves as a general and extensible foundation for automating screw parameter computation and coordinate frame assignment.\nIn this configuration, the screw axis definitions become straightforward. Since all creases are modeled as revolute joints, the screw pitch is\nh\n=\n0\nh=0\nfor all cases. The screw axis information defined in the space frame at the home positionâ€”hereafter referred to as the\nhome position space screw axes\nâ€”is summarized in Table\nB1\n.\nTable B1\n:\nExample of screw axis assignment in home position\nJoint\ni\ni\nÏ‰\ni\n\\omega_{i}\nq\ni\nq_{i}\nv\ni\n=\nâˆ’\nÏ‰\ni\nÃ—\nq\ni\nv_{i}=-\\omega_{i}\\times q_{i}\n1\n(\n0\n,\n1\n,\n0\n)\n(0,1,0)\n(\n1\n,\n0\n,\n0\n)\n(1,0,0)\n(\n0\n,\n0\n,\n1\n)\n(0,0,1)\n2\n(\n0\n,\nâˆ’\n1\n,\n0\n)\n(0,-1,0)\n(\n2\n,\n0\n,\n0\n)\n(2,0,0)\n(\n0\n,\n0\n,\nâˆ’\n2\n)\n(0,0,-2)\n3\n(\nâˆ’\n1\n/\n2\n,\n1\n/\n2\n,\n0\n)\n(-1/\\sqrt{2},1/\\sqrt{2},0)\n(\n3\n,\n0\n,\n0\n)\n(3,0,0)\n(\n0\n,\n0\n,\n3\n/\n2\n)\n(0,0,3/\\sqrt{2})\nEach facet may be assigned an arbitrary local coordinate frame, as long as transformations are properly defined. Let\nM\ns\n,\n3\nM_{s,3}\ndenote the transformation matrix of the third facet in the home position. These matrices are referred to as the\nhome position transformation matrices\n, denoted by\nM\ns\n,\ni\nM_{s,i}\n.\nNow consider the case where the creases are rotated by an amount\n(\nÎ¸\n1\n,\nÎ¸\n2\n,\nÎ¸\n3\n)\n(\\theta_{1},\\theta_{2},\\theta_{3})\n, resulting in the configuration shown in Figure\nB3\nB. After the crease rotations, the new transformation matrix of the third facet,\nT\ns\n,\n3\nT_{s,3}\n, is given by:\nT\ns\n,\n3\n=\ne\n[\nÎ¾\n1\n]\nâ€‹\nÎ¸\n1\nâ€‹\ne\n[\nÎ¾\n2\n]\nâ€‹\nÎ¸\n2\nâ€‹\ne\n[\nÎ¾\n3\n]\nâ€‹\nÎ¸\n3\nâ€‹\nM\ns\n,\n3\n.\nT_{s,3}=e^{[\\xi_{1}]\\theta_{1}}e^{[\\xi_{2}]\\theta_{2}}e^{[\\xi_{3}]\\theta_{3}}M_{s,3}.\n(B6)\nThis expression follows from the property of pre-multiplying transformation matrices. It is known as the\nProduct of Exponentials\n(PoE) formula and provides a straightforward method for computing forward kinematics.\nMore generally, for an open chain with\nn\nn\njoints (and\nn\nn\ncorresponding links), the forward kinematics using the PoE formulation becomes:\nT\ns\n,\nn\n=\ne\n[\nÎ¾\n1\n]\nâ€‹\nÎ¸\n1\nâ€‹\ne\n[\nÎ¾\n2\n]\nâ€‹\nÎ¸\n2\nâ€‹\nâ‹¯\nâ€‹\ne\n[\nÎ¾\nn\n]\nâ€‹\nÎ¸\nn\nâ€‹\nM\ns\n,\nn\n,\nT_{s,n}=e^{[\\xi_{1}]\\theta_{1}}e^{[\\xi_{2}]\\theta_{2}}\\cdots e^{[\\xi_{n}]\\theta_{n}}M_{s,n},\n(B7)\nwhere the lower index of each screw axis indicates proximity to the base or space frame, and the higher index indicates proximity to the end-effector or terminal linkage.\nAlthough the Denavitâ€“Hartenberg (DH) convention can also be used to describe the forward kinematics of an open chain with\nn\nn\njoints using a minimal set of\n4\nâ€‹\nn\n4n\nparameters, it requires strict rules for attaching frames to each link. In contrast, the PoE formulation offers greater flexibility in frame assignment and is therefore preferred in this work.\nB.3\nSpace Twist and Jacobian\nFor an arbitrary moving body frame observed from the space frame, the transformation matrix is denoted as\nT\ns\n,\nb\nâ€‹\n(\nt\n)\nâˆˆ\nS\nâ€‹\nE\nâ€‹\n(\n3\n)\nT_{s,b}(t)\\in SE(3)\n. The spatial velocity of the bodyâ€”also referred to as the\nspace twist\nâ€”can be expressed as:\n[\nğ’±\ns\n]\n=\n[\n[\nÏ‰\ns\n]\nv\ns\n0\n0\n]\n=\nT\nË™\ns\n,\nb\nâ€‹\nT\ns\n,\nb\nâˆ’\n1\nâˆˆ\ns\nâ€‹\ne\nâ€‹\n(\n3\n)\n,\n[\\mathcal{V}_{s}]=\\begin{bmatrix}[\\omega_{s}]&v_{s}\\\\\n0&0\\end{bmatrix}=\\dot{T}_{s,b}T_{s,b}^{-1}\\in se(3),\n(B8)\nwhere\nğ’±\ns\n=\n[\nÏ‰\ns\nv\ns\n]\nâˆˆ\nâ„\n6\n\\mathcal{V}_{s}=\\begin{bmatrix}\\omega_{s}\\\\\nv_{s}\\end{bmatrix}\\in\\mathbb{R}^{6}\nis the twist vector expressed in the space frame\n{\ns\n}\n\\{s\\}\n.\nThe bracket operator\n[\nâ‹…\n]\n[\\cdot]\nmaps a 3-vector to a\n3\nÃ—\n3\n3\\times 3\nskew-symmetric matrix in\ns\nâ€‹\no\nâ€‹\n(\n3\n)\nso(3)\n, and a 6-vector to a\n4\nÃ—\n4\n4\\times 4\nmatrix in\ns\nâ€‹\ne\nâ€‹\n(\n3\n)\nse(3)\n. That is, for a twist\nğ’±\ns\nâˆˆ\nâ„\n6\n\\mathcal{V}_{s}\\in\\mathbb{R}^{6}\n,\n[\nğ’±\ns\n]\nâˆˆ\ns\nâ€‹\ne\nâ€‹\n(\n3\n)\n[\\mathcal{V}_{s}]\\in se(3)\nis its matrix representation.\nNote that a twist encodes the instantaneous motion of a rigid body and lies in the Lie algebra\ns\nâ€‹\ne\nâ€‹\n(\n3\n)\nse(3)\n. A unit screw axis can be viewed as a normalized twist direction associated with a particular rigid body motion.\nPhysically,\nÏ‰\ns\n\\omega_{s}\nrepresents the angular velocity of the body frame with respect to the space frame, and\nv\ns\nv_{s}\nis the linear velocity of the point on the body that instantaneously coincides with the origin of\n{\ns\n}\n\\{s\\}\n.\nThe\nadjoint mapping\nis an operator that enables the transformation of twists (or screw axes) across different reference frames. It serves two primary purposes: (1) expressing the same twist in a different reference frame, and (2) transforming a twist that has been displaced by a sequence of rigid body motions.\nFor an arbitrary homogeneous transformation matrix\nT\na\n,\nb\n=\n(\nR\na\n,\nb\n,\np\na\n,\nb\n)\nT_{a,b}=(R_{a,b},p_{a,b})\n, the adjoint operator\nAd\nT\na\n,\nb\n:\nâ„\n6\nâ†’\nâ„\n6\n\\mathrm{Ad}_{T_{a,b}}:\\mathbb{R}^{6}\\rightarrow\\mathbb{R}^{6}\nis defined as:\nğ’±\na\n=\nAd\nT\na\n,\nb\nâ€‹\n(\nğ’±\nb\n)\n=\n[\nAd\nT\na\n,\nb\n]\nâ€‹\nğ’±\nb\n,\n\\mathcal{V}_{a}=\\mathrm{Ad}_{T_{a,b}}(\\mathcal{V}_{b})=[\\mathrm{Ad}_{T_{a,b}}]\\mathcal{V}_{b},\n(B9)\nwhere\n[\nAd\nT\na\n,\nb\n]\n=\n[\nR\na\n,\nb\n0\n[\np\na\n,\nb\n]\nâ€‹\nR\na\n,\nb\nR\na\n,\nb\n]\nâˆˆ\nâ„\n6\nÃ—\n6\n.\n[\\mathrm{Ad}_{T_{a,b}}]=\\begin{bmatrix}R_{a,b}&0\\\\\n[p_{a,b}]R_{a,b}&R_{a,b}\\end{bmatrix}\\in\\mathbb{R}^{6\\times 6}.\n(B10)\nFor twists represented in\ns\nâ€‹\ne\nâ€‹\n(\n3\n)\nse(3)\n, the adjoint operator satisfies the following similarity transformation:\n[\nğ’±\na\n]\n=\nT\na\n,\nb\nâ€‹\n[\nğ’±\nb\n]\nâ€‹\nT\na\n,\nb\nâˆ’\n1\n.\n[\\mathcal{V}_{a}]=T_{a,b}[\\mathcal{V}_{b}]T^{-1}_{a,b}.\n(B11)\nAs an example, the same twist can be expressed in a different frame. The\nbody twist\n, which is the spatial velocity expressed in the body frame, is defined as:\n[\nğ’±\nb\n]\n=\nT\ns\n,\nb\nâˆ’\n1\nâ€‹\nT\nË™\ns\n,\nb\nâˆˆ\ns\nâ€‹\ne\nâ€‹\n(\n3\n)\n.\n[\\mathcal{V}_{b}]=T_{s,b}^{-1}\\dot{T}_{s,b}\\in se(3).\n(B12)\nOnce the transformation matrix\nT\ns\n,\nb\nT_{s,b}\nis known, the body twist\nğ’±\nb\n\\mathcal{V}_{b}\nis related to the space twist\nğ’±\ns\n\\mathcal{V}_{s}\nthrough the adjoint transformation:\nğ’±\nb\n=\nAd\nT\nb\n,\ns\nâ€‹\n(\nğ’±\ns\n)\n,\n\\mathcal{V}_{b}=\\mathrm{Ad}_{T_{b,s}}(\\mathcal{V}_{s}),\n(B13)\nwhere\nT\nb\n,\ns\n=\nT\ns\n,\nb\nâˆ’\n1\nT_{b,s}=T_{s,b}^{-1}\n. If\nT\ns\n,\nb\n=\n(\nR\n,\np\n)\nT_{s,b}=(R,p)\nis given as\nthen its inverse is computed as\nT\nb\n,\ns\n=\nT\ns\n,\nb\nâˆ’\n1\n=\n(\nR\nT\n,\nâˆ’\nR\nT\nâ€‹\np\n)\n.\nT_{b,s}=T_{s,b}^{-1}=(R^{T},-R^{T}p).\n(B14)\nAs another example, consider Figure\nB3\n(B). The screw axis of the third crease, transformed after the first and second crease rotations, becomes:\nÎ¾\n3\nâ€²\n=\nAd\ne\n[\nÎ¾\n1\n]\nâ€‹\nÎ¸\n1\nâ€‹\ne\n[\nÎ¾\n2\n]\nâ€‹\nÎ¸\n2\nâ€‹\n(\nÎ¾\n3\n)\n.\n\\xi_{3}^{\\prime}=\\mathrm{Ad}_{e^{[\\xi_{1}]\\theta_{1}}e^{[\\xi_{2}]\\theta_{2}}}(\\xi_{3}).\n(B15)\nThe\nspace Jacobian\nJ\ns\nâˆˆ\nâ„\n6\nÃ—\nn\nJ_{s}\\in\\mathbb{R}^{6\\times n}\nmaps the joint velocity vector\nÎ¸\nË™\nâˆˆ\nâ„\nn\n\\dot{\\theta}\\in\\mathbb{R}^{n}\nto the space twist through the relation:\nğ’±\ns\n=\nJ\ns\nâ€‹\nÎ¸\nË™\n.\n\\mathcal{V}_{s}=J_{s}\\dot{\\theta}.\n(B16)\nBy directly substituting the PoE formula (Equation\nB7\n) into the definition of the space twist (Equation\nB8\n), the\ni\nth\ni^{\\text{th}}\ncolumn of the space Jacobian is given by:\nJ\ns\n,\ni\n=\nÎ¾\ni\nâ€²\n=\nAd\ne\n[\nÎ¾\n1\n]\nâ€‹\nÎ¸\n1\nâ€‹\nâ‹¯\nâ€‹\ne\n[\nÎ¾\ni\nâˆ’\n1\n]\nâ€‹\nÎ¸\ni\nâˆ’\n1\nâ€‹\n(\nÎ¾\ni\n)\n.\nJ_{s,i}=\\xi_{i}^{\\prime}=\\mathrm{Ad}_{e^{[\\xi_{1}]\\theta_{1}}\\cdots e^{[\\xi_{i-1}]\\theta_{i-1}}}(\\xi_{i}).\n(B17)\nB.4\nRotation Formulation for Non-Perforated Loops\nFigure B4\n:\nGeometric interpretation of common\nq\nq\n-point assumption in Tachiâ€™s loop closure method\nFor rigid origami without perforations,\n[\n17\n]\nproposed a loop closure constraint method using only rotational components, based on the DH convention.\nIn our formulation, this corresponds to a special case in which all creases in a loop intersect at a common point\nq\nq\nin the space frame, as illustrated in Figure\nB4\n.\nFrom the\nl\nth\nl^{\\text{th}}\nloop, the\ni\nth\ni^{\\text{th}}\ncolumn of the space Jacobian is given by:\nJ\ns\n,\ni\nl\n=\nAd\nT\n1\n:\ni\nâˆ’\n1\nâ€‹\n(\nÎ¾\nl\n,\ni\n)\n,\nJ_{s,i}^{l}=\\mathrm{Ad}_{T_{1:i-1}}(\\xi_{l,i}),\n(B18)\nwhere\nT\n1\n:\ni\nâˆ’\n1\n=\n[\nR\n1\n:\ni\nâˆ’\n1\np\n1\n:\ni\nâˆ’\n1\n0\n1\n]\n,\nÎ¾\nl\n,\ni\n=\n[\nÏ‰\nl\n,\ni\nv\nl\n,\ni\n]\n.\nT_{1:i-1}=\\begin{bmatrix}R_{1:i-1}&p_{1:i-1}\\\\\n0&1\\end{bmatrix},\\quad\\xi_{l,i}=\\begin{bmatrix}\\omega_{l,i}\\\\\nv_{l,i}\\end{bmatrix}.\n(B19)\nThe rotation matrix\nR\n1\n:\ni\nR_{1:i}\ncan also be constructed recursively via the exponential map of each joint rotation:\nR\n1\n:\ni\n=\ne\n[\nÏ‰\nl\n,\n1\n]\nâ€‹\nÏ\n1\nâ€‹\ne\n[\nÏ‰\nl\n,\n2\n]\nâ€‹\nÏ\n2\nâ€‹\nâ‹¯\nâ€‹\ne\n[\nÏ‰\nl\n,\ni\n]\nâ€‹\nÏ\ni\n.\nR_{1:i}=e^{[\\omega_{l,1}]\\rho_{1}}e^{[\\omega_{l,2}]\\rho_{2}}\\cdots e^{[\\omega_{l,i}]\\rho_{i}}.\n(B20)\nBy definition,\nv\nl\n,\ni\n=\nâˆ’\nÏ‰\nl\n,\ni\nÃ—\nq\n=\nâˆ’\n[\nÏ‰\nl\n,\ni\n]\nâ€‹\nq\nv_{l,i}=-\\omega_{l,i}\\times q=-[\\omega_{l,i}]q\n, and thus the Jacobian column simplifies to:\nJ\ns\n,\ni\nl\n=\n[\nR\n1\n:\ni\nâˆ’\n1\nâ€‹\nÏ‰\nl\n,\ni\n[\nq\n]\nâ€‹\nR\n1\n:\ni\nâˆ’\n1\nâ€‹\nÏ‰\nl\n,\ni\n]\n.\nJ_{s,i}^{l}=\\begin{bmatrix}R_{1:i-1}\\omega_{l,i}\\\\\n[q]R_{1:i-1}\\omega_{l,i}\\end{bmatrix}.\n(B21)\nThis result shows that the bottom three rows (representing linear velocity) are linearly dependent on the top three rows (representing angular velocity), thereby justifying the redundancy of the translational components in the loop constraint.\nTherefore, when the loop is non-perforated and all creases in the loop intersect at a common vertex\nq\nq\n, the truncated loop space Jacobian\nJ\ns\nl\n,\nâˆ—\nâˆˆ\nâ„\n3\nÃ—\nn\nJ_{s}^{l,*}\\in\\mathbb{R}^{3\\times n}\ncan be defined as:\nJ\ns\nl\n,\nâˆ—\n=\n[\nÏ‰\nl\n,\n1\nR\n1\n:\n1\nâ€‹\nÏ‰\nl\n,\n2\nâ‹¯\nR\n1\n:\nn\nl\nâˆ’\n1\nâ€‹\nÏ‰\nl\n,\nn\nl\n]\n.\nJ_{s}^{l,*}=\\begin{bmatrix}\\omega_{l,1}&R_{1:1}\\omega_{l,2}&\\cdots&R_{1:n_{l}-1}\\omega_{l,n_{l}}\\end{bmatrix}.\n(B22)\nThis Jacobian can be globally indexed by mapping each column to the corresponding crease variable in\nÎ¸\n\\theta\n, while filling the columns corresponding to non-participating creases with zero vectors.\nConsequently, if the structure contains\nL\no\nL_{o}\nnon-perforated (origami-type) loops and\nL\nk\nL_{k}\nperforated (kirigami-type) loops, such that the total number of loops is\nL\n=\nL\no\n+\nL\nk\nL=L_{o}+L_{k}\n, then the full constraint matrix\nA\nâ€‹\n(\nÎ¸\n)\nA(\\theta)\nhas the dimension:\nA\nâ€‹\n(\nÎ¸\n)\nâˆˆ\nâ„\n(\n3\nâ€‹\nL\no\n+\n6\nâ€‹\nL\nk\n)\nÃ—\nn\n.\nA(\\theta)\\in\\mathbb{R}^{(3L_{o}+6L_{k})\\times n}.\n(B23)",
    "preview_text": "Origami-inspired structures with rigid panels now span thick, kirigami, and multi-sheet realizations, making unified kinematic analysis essential. Yet a general method that consolidates their loop constraints has been lacking. We present an automated approach that generates the Pfaffian constraint matrix for arbitrary rigid foldable structures (RFS). From a minimally extended data schema, the tool constructs the facet-hinge graph, extracts a minimum cycle basis that captures all constraints, and assembles a velocity-level constraint matrix via screw theory that encodes coupled rotation and translation loop closure. The framework computes and visualizes deploy and fold motions across diverse RFS while eliminating tedious and error-prone constraint calculations.\n\nAbstract\nOrigami-inspired structures with rigid panels now span thick, kirigami, and multi-sheet realizations, making unified kinematic analysis essential. Yet a general method that consolidates their loop constraints has been lacking. We present an automated approach that generates the Pfaffian constraint matrix for arbitrary rigid foldable structures (RFS). From a minimally extended data schema, the tool constructs the facetâ€“hinge graph, extracts a minimum cycle basis that captures all constraints, andâ€”via screw theoryâ€” assembles a velocity-level constraint matrix that encodes coupled rotation-translation loop closure. The framework computes and visualizes deploy/fold motions across diverse RFS, while eliminating tedious, error-prone constraint calculation.\nA Unified Framework for Kinematic Simulation of Rigid Foldable Structures\nDongwook Kwak\nDepartment of Mechanical Engineering, Seoul National University, Seoul, Republic of Korea\nume1838@snu.ac.kr\nGeonhee Cho\nDepartment of Mechanical Engineering, Seoul National University, Seoul, Republic of Korea\ngunhee236@snu.ac.kr\nJiook Chung\nDepartment of Mechanical Engineering, Seoul National University, Seoul, Republic of Korea\njiwook2000@snu.ac.kr\nJinkyu Yang\nDepar",
    "is_relevant": false,
    "relevance_score": 1.0,
    "extracted_keywords": [
        "kinematic simulation",
        "rigid foldable structures",
        "origami",
        "constraint matrix",
        "screw theory"
    ],
    "one_line_summary": "è¯¥è®ºæ–‡æå‡ºäº†ä¸€ç§ç”¨äºåˆšæ€§å¯æŠ˜å ç»“æ„è¿åŠ¨å­¦æ¨¡æ‹Ÿçš„ç»Ÿä¸€æ¡†æ¶ï¼Œä¸“æ³¨äºçº¦æŸçŸ©é˜µç”Ÿæˆå’Œè¿åŠ¨å¯è§†åŒ–ï¼Œä¸å¼ºåŒ–å­¦ä¹ ã€æ‰©æ•£æ¨¡å‹ç­‰å…³é”®è¯æ— å…³ã€‚",
    "detailed_summary": "",
    "qa_pairs": [],
    "is_hidden": false,
    "is_starred": false,
    "flag": true,
    "published_date": "2026-01-15T09:38:42Z",
    "created_at": "2026-01-20T17:49:54.340747",
    "updated_at": "2026-01-20T17:49:54.340759",
    "recommend": 0
}