{
    "id": "2601.14840v1",
    "title": "Implementing Knowledge Representation and Reasoning with Object Oriented Design",
    "authors": [
        "Abdelrhman Bassiouny",
        "Tom Schierenbeck",
        "Sorin Arion",
        "Benjamin Alt",
        "Naren Vasantakumaar",
        "Giang Nguyen",
        "Michael Beetz"
    ],
    "abstract": "本文介绍了KRROOD框架，该框架旨在弥合现代软件工程与知识表示与推理系统之间的集成鸿沟。尽管面向对象编程已成为开发复杂应用的标准范式，但现有的知识表示与推理框架通常依赖外部本体和专用语言，难以与命令式代码集成。KRROOD通过将知识视为基于原生类结构的一级编程抽象，有效衔接了逻辑编程与面向对象编程范式。我们在OWL2Bench基准测试和人机任务学习场景中对系统进行评估，实验结果表明KRROOD在保持高性能的同时，能够满足现实自主系统所需的表达性推理需求。",
    "url": "https://arxiv.org/abs/2601.14840v1",
    "html_url": "https://arxiv.org/html/2601.14840v1",
    "html_content": "Implementing Knowledge Representation and Reasoning with Object Oriented Design\nAbdelrhman Bassiouny\nTom Schierenbeck\nSorin Arion\nBenjamin Alt\nNaren Vasantakumaar\nGiang Nguyen&Michael Beetz\nAICOR Institute for Artificial Intelligence\nUniversity of Bremen\nBremen, Germany\nbassioun@uni-bremen.de,\ntom_sch@uni-bremen.de,\nsorin@uni-bremen.de,\nbenjamin.alt@uni-bremen.de,\nnaren@uni-bremen.de,\nhoanggia@uni-bremen.de,\nbeetz@cs.uni-bremen.de\nAbstract\nThis paper introduces KRROOD, a framework designed to bridge the integration gap between modern software engineering and\nknowledge representation and reasoning\n(\nKR&R\n) systems. While\nobject-oriented programming\n(\nOOP\n) is the standard for developing complex applications, existing\nKR&R\nframeworks often rely on external ontologies and specialized languages that are difficult to integrate with imperative code. KRROOD addresses this by treating knowledge as a first-class programming abstraction using native class structures, bridging the gap between the logic programming and OOP paradigms. We evaluate the system on the OWL2Bench benchmark and a human-robot task learning scenario. Experimental results show that KRROOD achieves strong performance while supporting the expressive reasoning required for real-world autonomous systems.\n1\nIntroduction\nIntelligent autonomous systems benefit from internal models to interpret their environment, reason about task requirements, and select actions that robustly achieve goals. The\nknowledge representation and reasoning\n(\nKR&R\n) paradigm provides interpretable structures and inference mechanisms that support generalization across tasks and domains. Decades of research demonstrate that explicit knowledge models enable tractable problem solving through abstraction, modularity and explanation at the knowledge level\nDelgrande\net al.\n(\n2024\n); Newell (\n1982\n)\n. Yet for roboticists and domain experts deploying intelligent systems in real-world settings, the practical adoption of\nKR&R\ndepends not only on representational adequacy but on the seamless integration of knowledge structures with perception, planning, control and application logic\nTöberg\net al.\n(\n2024\n)\n.\nThis integration challenge exposes a gap between two programming paradigms. The dominant paradigm for building complex software systems is\nobject-oriented programming\n(\nOOP\n), which provides modularity, data validation, and scalable development practices. In contrast,\nKR&R\nsystems typically rely on logic programming, and operate under fundamentally different assumptions about completeness, openness and execution semantics. As a consequence, developers must maintain two separate representational systems that do not share execution models or tooling ecosystems\nLedvinka and Křemen (\n2020\n)\n, leading to an object-ontological equivalent of the Object-Relational Impedance Mismatch\nIreland and Bowers (\n2015\n)\n. This mismatch is particularly acute in Python-based\nartificial intelligence\n(\nAI\n) systems, where perception, planning, and learning APIs increasingly converge, but no actively maintained\nKR&R\nframework provides native, object-oriented integration of both knowledge representation and advanced reasoning capabilities\nAbicht (\n2023\n)\n.\nFigure 1\n:\nThe\nKRROOD\nframework provides representations and tooling for native, object-oriented\nKR&R\nin Python.\nBeyond being an engineering inconvenience, this mismatch reflects a deeper tension in knowledge systems research. Frames\nMinsky (\n1974\n)\n, scripts\nSchank and Abelson (\n1977\n)\n, and languages such as FRL\nRoberts and Goldstein (\n1977\n)\nand KRL\nBobrow and Winograd (\n1977\n)\nwere designed to support reasoning over structured objects. Modern\nOOP\ninherits this tradition but has diverged from modern\nKR&R\ntooling, which has come to increasingly rely on external reasoners and\ndescription logic\n(\nDL\n) formalisms that treat knowledge as a resource separate from application logic\nBuoncompagni and Mastrogiovanni (\n2024\n)\n.\nThis paper argues that bridging this paradigm gap requires treating knowledge as a\nfirst-class programming abstraction\nrather than an external resource. It introduces\nKnowledge Representation and Reasoning with Object Oriented Design\n(\nKRROOD\n), a framework that unifies\nKR&R\ncapabilities within an\nOOP\nPython architecture and makes expressive\nKR&R\naccessible within standard software development workflows. We make five core contributions:\n1.\nAn interpretation of Python datastructures as knowledge representation that treats domain entities as structured objects directly accessible to application code.\n2.\nEntity Query Language\n(\nEQL\n), a declarative querying language for Python data structures that extends upon well-established conjunctive query languages while remaining tractable and decidable.\n3.\n\\Acp\nrdr for consistent incremental knowledge update and maintenance through expert interaction during system runtime.\n4.\nORMatic, a persistence layer that transparently stores, indexes, and retrieves knowledge objects while maintaining alignment between domain models and data schemas.\n5.\nOntomatic, a tool for automatic migration of knowledge represented in the\nWeb Ontology Language\n(\nOWL\n) into object-oriented Python data structures.\nTaken together, they bridge the paradigm gap between application programming and\nKR&R\nby enabling engineers to seamlessly\nprogram with knowledge\n.\nWe validate the capabilities and performance of\nKRROOD\non OWL2Bench\nSingh\net al.\n(\n2020\n)\nand a human-robot task learning scenario.\nKRROOD\nis fully open-source\n1\n1\n1\nSource code:\nhttps://github.com/cram2/cognitive_robot_abstract_machine\nand integrated into a robot cognitive architecture\nBeetz\net al.\n(\n2025\n)\n, providing foundational capabilities for hybrid physical\nAI\n.\n2\nRelated Work\nThe mismatch between the representations used in\nKR&R\nand those used in application programming has been identified as a core challenge in knowledge engineering\nLedvinka and Křemen (\n2020\n); Baset and Stoffel (\n2018\n); Banse\net al.\n(\n2024\n)\n.\n\\Ac\noom systems address the structural correspondence between application objects and their representations in knowledge bases. In Java, JOPA\nLedvinka\net al.\n(\n2016\n)\n, Jastor\nSzekely and Betz (\n2009\n)\n, KOMMA\nWenzel (\n2010\n)\n, and the OWLAPI\nHorridge and Bechhofer (\n2011\n)\noffer programmatic ontology access with varying degrees of object integration. Owlready2\nLamy (\n2017\n)\nis a Python equivalent. More recent frameworks such as OWLOOP\nBuoncompagni and Mastrogiovanni (\n2024\n)\nextend this line of work by mapping OWL axioms into\nOOP\nhierarchies with polymorphism support, allow downstream applications to use ontologies in protocol buffers\nBanse\net al.\n(\n2024\n)\nor project ontology information into vector spaces for downstream\nmachine learning\n(\nML\n) models\nZhapa-Camacho\net al.\n(\n2023\n)\n. These frameworks facilitate programmatic ontology access, but delegate inference to external reasoners and do not support rule-based reasoning.\nExternal reasoners such as RacerPro\nHaarslev\net al.\n(\n2012\n)\n, HermiT\nGlimm\net al.\n(\n2014\n)\n, RDFox\nNenov\net al.\n(\n2015\n)\nand MORe\nArmas Romero\net al.\n(\n2012\n)\nprovide sound and complete inference for various\nDL\nfragments. Most modern\nKR&R\nsystems such as DeepOnto\nHe\net al.\n(\n2024\n)\nrely on reasoning as a batch process over serialized ontology files: applications must export domain state, invoke the reasoner and parse results. This separation forces developers to maintain parallel representations of domain knowledge and synchronize state across system boundaries, complicating development and maintenance. KERAIA\nVarey\net al.\n(\n2025\n)\nis a recent self-contained knowledge system with dynamic aggregation and context-sensitive inheritance. However, it introduces its own representation language (KSYNTH), and integrating it into\nOOP\napplications reintroduces the impedance mismatch at the system boundary.\n2.1\nKRR as a Native Programming Abstraction\nThe vision of treating knowledge as a native programming construct has historical roots in frames\nMinsky (\n1974\n)\n, FRL\nRoberts and Goldstein (\n1977\n)\n, and KRL\nBobrow and Winograd (\n1977\n)\n, which were designed to support reasoning over structured objects. Systems such as ErgoAI\nKifer and Knowledge (\n2018\n)\nand KnowRob\nBeetz\net al.\n(\n2018\n)\nrealized this vision by providing built-in reasoning through Prolog’s unification mechanism. However, they also reintroduce the impedance mismatch at the system boundary, requiring developers to context-switch between paradigms. Logic programming libraries for Python embed Datalog or probabilistic inference, but do not provide object-oriented knowledge representation\nCarbonnelle (\n2020\n); Dries\net al.\n(\n2015\n)\n.\nOWLAPY\nBaci\net al.\n(\n2025\n)\nis perhaps closest in spirit to\nKRROOD\n: it models OWL entities as first-class Python objects and provides both Python-native and external reasoners. However, reasoning operates over\nOWL\nconstructs rather than application domain objects, requiring developers to maintain a mapping between the two. OWLAPY also does not support rule-based reasoning or integrated persistence.\nNo existing framework unifies object-oriented representation, expressive querying, native rule-based reasoning and persistence within a single abstraction.\n\\Ac\nkrrood addresses this gap by treating knowledge as a first-class programming construct accessible via native Python mechanisms.\n3\nEQL: A Python-Based Query and Logical Axiomatization Language\nWe address the paradigm gap by proposing an object-oriented, Python-native representation of knowledge. In\nKRROOD\n, concepts are represented as classes, relations between concepts are captured by class attributes and n-ary functions, and taxonomic relations are modeled through inheritance. Although this representation differs structurally from First-Order Logic (FOL), for example, a Python class definition does not explicitly encode axioms, it is sufficiently flexible to allow arbitrary class methods that express statements holding generally for the class, as demonstrated by the experiments in Section\n7\n.\nQueries over this knowledge can be formulated over classes, their instances, and their attributes.\nTo make this object-oriented knowledge representation practically usable as a\nKR&R\nsystem, a mechanism is required that allows structured access to classes, instances, and their relations, while preserving the flexibility of the underlying Python execution model. This motivates a native query language that supports both declarative retrieval and procedural reasoning. We propose\nEQL\n, a declarative query interface for knowledge retrieval and axiomatization within Python applications.\n3.1\nGrammar and Example Queries\nThe syntax of\nEQL\nfollows in spirit conjunctive database query languages with a Select-Where-From pattern, but adds declarative syntactical elements to facilitate\nKR&R\napplications.\nEQL\nstatements are\ndescriptions of entities\n, rather than imperative programming commands (see Listing\n1\n).\nSimilar to tables in SQL and nodes/edges in graph query languages,\nEQL\nhas\nvariables\nas the atomic data holders. Variables are symbolic representations of Python objects that represent a set of values. They can be an arbitrary set of values or values of a specific class. Attributes of objects represented by variables can be accessed exactly as they are accessed on the objects themselves, but return symbolic representations of the attributes rather than their concrete value.\nAn\nEQL\nvariable is constructed from a\ntype\n(a class), a\ndomain\n(a set of values), or both:\nvar = variable(Type, Domain)\nExplicit domain specification enables queries to operate over program-computed sets, e. g., sets produced by methods of an object, rather than exhaustive class extensions, distinguishing\nEQL\nfrom traditional database query languages.\nThis design permits the integration of domain-specific computation into query evaluation. Variables in\nEQL\nrepresent symbolic constraints over value sets, while program variables may be used directly as literals when denoting constants.\nAn\nEQL\nquery follows the structure:\nquery = ResultProcessor(EntityDescriptor)\nThe\nresult processor\napplies either\naggregation\n(e.g.,\nsum\n,\ncount\n) or\nquantification\nto the retrieved entities. Quantifiers constrain the cardinality of results:\na\n/\nan\npermits zero or more matching entities (existential quantification), while\nthe\nenforces uniqueness.\nAn\nentity descriptor\nspecifies retrieval constraints analogous to the Select-Where clause in SQL. The descriptor\nentity(variable)\nretrieves a single entity, while\nset_of(var1, var2, ...)\nretrieves entity tuples. Constraints are specified through\nwhere(cond1, cond2, ...)\n, which accepts conjunctive conditions over entity attributes.\nListing\n1\nfinds all persons of age 20:\nListing 1:\nA simple entity query\n⬇\n1\np\n=\nvariable\n(\nPerson\n)\n2\nquery\n=\nan\n(\nentity\n(\np\n).\nwhere\n(\np\n.\nage\n==\n20))\nListing\n2\nshows a nested query with domain specification, quantification (universal and existential), multiple selected variables, and indexing of collections. The query selects robot and capability pairs where the robot possesses the capability, satisfies part-size constraints, and has sufficiently dexterous hands that have at least 5 fingers; variable definitions are omitted.\nListing 2:\nA more complex query\n⬇\n1\nquery\n=\na\n(\nset_of\n(\nrobot\n,\ncapability\n).\nwhere\n(\n2\ncontains\n(\nrobot\n.\ncapabilities\n,\ncapability\n),\n3\nrobot\n.\nparts\n.\nsize\n[0]\n<=\n1,\n4\nfor_all\n(\narm\n,\ncount\n(\narm\n.\nfingers\n)\n>=\n5))))\n3.2\nSemantics of\nEQL\nEQL is grounded in the well-established framework of conjunctive queries, which correspond to the existential, conjunction-only fragment of\nFirst Order Logic\n(\nFOL\n).\nTo increase expressiveness while retaining executability,\nEQL\nextends conjunctive queries with three carefully chosen features. First,\nEQL\nsupports\nunions of conjunctive queries\n, allowing disjunctive pattern matching (e.g., querying entities that satisfy one of several alternative conditions). Second, it adopts\nnegation as failure\n, interpreting negation operationally as the absence of derivable evidence in the knowledge base. Third, it provides a\nrestricted form of universal quantification\n, interpreted over the active domain of entities currently present in the knowledge base.\nThese choices reflect the closed-world assumptions commonly adopted in databases and robotic world models, where the knowledge base represents the agent’s current belief state. While they are not as expressive as full\nFOL\n, they preserve decidability, tractability, and align the semantics of the language with the requirements of real-world\nAI\nsystems.\n4\nPython Native Rule Based Reasoning\nRule-based reasoning has been used extensively in domains that require correctness, explainability, and extensibility. The advantages of rule-based systems come at the cost of ease of maintenance: As the size of the knowledge base increases, the probability of conflict between rules also increases\nCompton and Kang (\n2021\n)\n. A range of conflict-resolution strategies have been proposed, including specificity- and recency-based rule selection\nBrachman and Levesque (\n2004\n)\n. However, these strategies are inherently heuristic: while they may reduce the likelihood of rule conflicts, they do not eliminate them.\nRipple Down Rule\n(\nRDR\n)s\nCompton and Kang (\n2021\n)\noffer a pragmatic solution by building the knowledge base rule by rule from available data using expert supervision. While rules are being added, conflicts are automatically detected and the expert is prompted to resolve them by answering one basic question: What are the conditions that differentiate these two conflicting rules? The system then automatically places the answer as a refinement rule in the appropriate place in the rule tree.\nThere are three established types of\nRDR\ns: SingleClassRDRs infer concetps that are mutually exclusive; MultiClassRDRs infer non mutually exclusive concepts; and GeneralRDRs, which can contain multiple different\nRDR\ntrees for the inference of different concepts.\nRDR\ntrees are run until no extra inference is produced, making use of intermediate inferences for further activation of rules that may use them, thus inferring higher level concepts from them.\nKRROOD\ncontributes a Python-native\nRDR\nimplementation that makes use of object-oriented design and the Python ecosystem. Additionally, it extends\nRDRs\nwith features that increase its maintainability and expressiveness.\n4.1\nRDR Extensions in KRROOD\nThe\nKRROOD\nRDR\nimplementation provides three key extensions to the traditional formalism:\nFlexible case representation.\nCases may be arbitrary Python objects, enabling direct integration with\nOOP\ndomain models. Python functions can be annotated to define\nRDRs\n, with function inputs as case descriptions and outputs as inferred conclusions.\nExpressive rule conditions.\nRule conditions are executable Python code rather than a specialized language. This enables direct use of domain-specific APIs and eliminates knowledge duplication across formalisms.\nMaintainable rule representation.\nRule bases are materialized as auto-generated Python modules comprising both the tree structure and logic. These modules are independently executable and support direct user modification, enabling maintenance as domain models evolve within standard development workflows.\nInteractive rule writing.\nThe\nRDR\nprompt opens an editor with template code of a function that takes the case as input and expects a conclusion of the given type as output. The expert then writes the rule in the function body, utilizing the full capabilities of the Python language and leveraging IDE support.\nIn addition,\nRDR\ntrees can be directly defined using\nEQL\n. In Listing\n3\n, the initial tree contains a single rule that infers that the parent body of a fixed connection is a\nDrawer\nwhen the child body of the connection is of type\nHandle\n. When a new case matches this rule but corresponds to a\nDoor\nrather than a\nDrawer\n,\nRDR\nrequests a distinguishing condition from the expert. The expert specifies that a\nDoor\nhas a body larger than\n1\n​\nm\n1\\,m\n. The rule tree is then automatically refined by adding this condition as a child rule, which overrides the original conclusion and infers a\nDoor\nwhen the refinement condition holds.\nListing 3:\nRDR tree with Refinement using EQL\n⬇\n1\nfixed_connection\n=\nvariable\n(\nFixedConnection\n)\n2\nchild\n=\nfixed_connection\n.\nchild\n3\nparent\n=\nfixed_connection\n.\nparent\n4\nwith\nHasType\n(\nchild\n,\nHandle\n):\n5\nAdd\n(\ninference\n(\nDrawer\n)(\ncontainer\n=\nparent\n))\n6\nwith\nrefinement\n(\nparent\n.\nsize\n>\n1):\n7\nAdd\n(\ninference\n(\nDoor\n)(\nbody\n=\nparent\n))\n5\nOntomatic: OWL Conversion\nKRROOD\nprovides tool support for the automatic conversion of OWL representations into\nobject-oriented design\n(\nOOD\n) data structures. Ontomatic, the OWL adapter of\nKRROOD\n, converts\nOWL\nontologies in two phases. The first phase involves generating the classes and properties to represent the T-Box, including inference of subsumption between classes, inference of domains and ranges of properties, and conversion of\nOWL\naxioms into an equivalent\nEQL\nrepresentation. Two prominent challenges are addressed in this phase:\nNon-disjoint sibling classes.\nIn\nOWL\n, sibling classes are not necessarily disjoint, allowing an individual to belong to multiple sibling classes simultaneously. This contrasts with object-oriented inheritance.\nTo bridge this mismatch, we model overlapping class membership using a Role pattern: a persistent entity represents the individual’s identity (URI), and role-specific classes reference it via composition rather than inheritance. This allows an individual to assume multiple roles concurrently, in line with OntoClean modeling principles\nGuarino and Welty (\n2004\n)\n. Roles can either be explicitly defined in the ontology by adding a\nroleFor\nproperty, or they can be implied through disjointness constraints.\nExpressing axioms.\nOWL\naxioms expressed as class descriptions and restrictions cannot be fully captured through class structures alone, as inheritance hierarchies encode only taxonomic relationships and attribute ranges rather than complex constraints involving chained attributes or quantified conditions. We address this limitation by encoding axioms as class-level methods that implement verification predicates using\nEQL\n. These predicates operate over arbitrary domain instances and support existential and universal quantification. Listing\n4\nillustrates the\nOOD\nrepresentation of the constraint from OWL2Bench (DL profile) that a\nLeisureStudent\nis a student that takes at most one course. This is represented in OWL as an intersection of subclass of\nStudent\n, and an\nonProperty\nrestriction on the\ntakesCourse\nproperty with a\nmaxQualifiedCardinality\nof 1 of class\nCourse\n.\nListing 4:\nClass with EQL Axiom\n⬇\n1\nclass\nLeisureStudent\n(\nStudent\n):\n2\n@classmethod\n3\ndef\naxiom\n(\ncls\n,\ncandidate\n):\n4\nreturn\n(\n5\nexists\n(\nIsSubClassOrRole\n(\ncandidate\n.\ntypes\n,\nStudent\n)),\n6\nHasProperty\n(\ncandidate\n,\nTakesCourse\n),\n7\ncount\n(\nIsSubClassOrRole\n(\ncandidate\n.\ntakes_course\n.\ntypes\n,\nCourse\n))\n<=\n1\n8\n)\nIn a second phase, Ontomatic loads individuals as instances of the generated classes. The appropriate types for each instance are inferred using explicitly declared types, assigned properties and class axioms.\nTo improve performance, on-time forward chaining is applied to all properties except those that are both transitive and symmetric, as handling these properties eagerly leads to a substantial increase in reasoning time (from  15 seconds to around 100 minutes in our experiments). To preserve completeness, a final post-processing step extracts the induced subgraphs of symmetric-transitive properties and computes their weakly connected components. Within each component, all node pairs are inferred to be related, thereby recovering the missing relations and completing the inference.\n6\nORMatic: Object-Relational Mapping and Persistence\n\\Ac\nkrr applications require robust persistence solutions to manage the complex, evolving states of domain knowledge. While Python dataclasses offer a high-fidelity representation of structured data, the challenge extends beyond simple integration and involves maintaining referential integrity and schema synchronization across the application lifecycle. Without a dedicated abstraction layer, systems risk “schema drift” and the fragmentation of domain logic.\n\\Ac\norm addresses these risks by providing a declarative framework that enforces data constraints, manages complex relational networks, and ensures the persistent state’s alignment with the application knowledge model.\nThe design of ORMatic,\nKRROOD\n’s persistance layer, is guided by several core principles intended to streamline the development of knowledge-based systems. Primarily, the system emphasizes maintainability and scalability, ensuring the persistence layers ability to grow alongside the application. ORMatic was designed with\nML\ncompatibility\nin mind: A modern\nKR&R\nsystem should allow for direct use of its data for machine learning, which most often requires tabular data as input\nKleppmann (\n2019\n)\n.\nAnother critical requirement is\nnon-interference\n: the tool should not dictate the structure of domain-specific logic\nDavis\net al.\n(\n1993\n)\n. By minimizing the object-relational impedance mismatch\nNeward (\n2006\n)\n, ORMatic allows developers and\nAI\nagents to use standard Python\nOOP\npatterns.\nA further requirement is the strict alignment with SOLID principles, particularly the\nSingle Responsibility Principle (SRP)\n. In many traditional\nobject-relational mapping\n(\nORM\n) implementations, the failure to separate the\nData Access Objects\nfrom the domain class forces domain objects to handle their own persistence routines. This violation of SRP often introduces side effects, that interfere with domain-specific logic, slowing down execution and causing unexpected behavior. ORMatic avoids this by maintaining a clean separation between the logic used for computation and the structures used for storage.\nORMatic provides sensible defaults while remaining extensible through customizable mappings and supports a variety of database backends to suit different infrastructure needs. These requirements were discovered in episodic memory components for cognitive architectures\nBeetz\net al.\n(\n2025\n)\n.\nIn complex software systems, specific parts of the domain model will likely require persistence logic or conversion routines that differ from the automatically generated defaults.\nORMatic provides a structured framework to define alternative persistence specifications or specialized serialization routines. These custom definitions are integrated into the global persistence pipeline, ensuring that developers can achieve full customization while still using dataclasses as the primary framework for defining information.\nORMatic functions as a translation and generation layer between Python domain models and relational storage. The system automatically generates an SQLAlchemy interface that mirrors the structure and behavior of existing Python classes. To facilitate data movement, it provides built-in routines to convert domain objects into\nDAOs\nand back automatically.\nThis is different to many existing solutions that require extra definitions for data schemas and validation, (e. g. SQLAlchemy\n2\n2\n2\nhttps://www.sqlalchemy.org/\n, Pydantic\n3\n3\n3\nhttps://docs.pydantic.dev/latest/\n, peewee\n4\n4\n4\nhttps://docs.peewee-orm.com/en/latest/index.html\n). ORMatic operates entirely within the application’s existing dataclasses (see Fig.\n1\n).\nThis approach ensures that the data model and the domain model remain identical, reducing the cognitive load on the developer and eliminating synchronization errors. By utilizing SQL as a backend, ORMatic benefits from the reliability and query capabilities of established relational database engines.\n7\nExperiments\nThis chapter evaluates\nKRROOD\nas an integrated\nKR&R\nsystem on OWL2Bench and a robotic task learning application. The experiments show that\nDL\nstatements can be expressed directly on object-oriented knowledge structures, preserving ontological semantics while operating entirely within an\nOOD\nparadigm. The evaluation, therefore, addresses not only expressivity but also whether such an approach is competitive in terms of loading, reasoning, and querying performance.\n7.1\nOWL2Bench Benchmarks\nWe evaluate\nKRROOD\non the OWL2Bench benchmark with the OWL 2 RL profile\nSingh\net al.\n(\n2020\n)\n.\n5\n5\n5\nThe experiments can be reproduced at\nhttps://github.com/tomsch420/krrood_experiments\n.\nThe experimental setup utilizes a machine running Ubuntu 24.04.3 LTS, equipped with a 11th Gen Intel® Core™ i7-11700k processor and 32 GB of RAM.\nAn object-oriented model (referenced as\nKRROOD\nin Tables\n1\nand\n2\n) is auto-generated from the OWL2Bench ontology using Ontomatic, with only minor changes related to the Role pattern: A few classes were modified to explicitly mention that they are roles and not just subclasses, to handle the issues arising from (non) disjoint sibling classes discussed in Section\n5\n. From the generated classes, an\nORM\ninterface is automatically derived using ORMatic and the data is persisted in a PostgreSQL database. To assess the impact of materializing object-oriented data structures on query performance, we include SQLAlchemy on that PostgreSQL data as a baseline in the query experiment (Table\n2\n). SQLAlchemy is not compared in reasoning (Table\n1\n), as it does not support reasoning on its own.\n7.1.1\nLoading and Reasoning\nLoading and reasoning performance is compared across six systems: KRROOD, owlready2 with Pellet, Protégé with Pellet, GraphDB with OWL RL (Optimized), and RDFlib with owlrl.\nPerformance is measured for initial reasoning over raw data and re-reasoning over previously materialized inferences (“Reasoning Reasoned” in Table\n1\n), as incremental reasoning is a common workflow. HermiT was excluded due to consistent memory failures.\nThe results are presented in Table\n1\n. RDFlib with owlrl failed to terminate within 180 minutes. Protégé with Pellet demonstrates the fastest reasoning (5.5s raw, 22s reasoned) but requires approximately 5 GB for reasoning and 25 GB for RDF/XML export, limiting scalability. owlready2 reasons less efficient (203.9s raw) and exhausts memory when reasoning over materialized data. GraphDB exhibits consistent performance (1820s raw, 1606s reasoned) with stable memory usage across ontology scales, making it the most reliable alternative to\nKRROOD\nfor large-scale reasoning.\nKRROOD\nreasoning performance (8.3s raw, 127.9s reasoned) remains competitive while providing native integration with application logic, a capability absent in all other systems. This trade-off is appropriate for applications requiring runtime introspection, procedural reasoning, or tight coupling between knowledge and domain behavior, as required in robotics tasks (see Section\n7.2\n).\n7.1.2\nQuerying\nIn a second experiment, we measured the execution times of all queries in the OWL 2 RL profile from OWL2Bench. To ensure consistency, we verified that every framework returned the same set of entities. Protégé failed to terminate on Query 20. To mitigate the impact of the long runtime of Query 20 on the overall assessment, we report the geometric mean across all queries. Q12 was omitted because it would require modeling\nResearchGroup\nas a subclass of both Organization and Person, which violates the Liskov Substitution Principle. A\nResearchGroup\ncannot safely substitute for a Person.\nThe results are shown in Table\n2\n. SQLAlchemy achieves the fastest performance in most individual cases and maintains the best geometric mean, demonstrating its utility within the KRROOD architecture, especially for large queries. KRROOD with EQL, while not always the fastest, provides fully capable domain objects, which is a requirement for native integration into cognitive systems architectures and is not achieved by any other framework. Conversely, RDFlib, owlready2, and Protégé appear less competitive in this context, leaving GraphDB as the most viable alternative to KRROOD when query speed is the primary concern and having domain objects is not necessary.\nFramework\nLoading + Reasoning\nRaw\nLoading + Reasoning\nReasoned\nKRROOD\n8.32\n8.32\n127.89\n127.89\nRDFLib\n36.011\n36.011\n>\n10800\n>10800\nowlready2\n203.914\n203.914\no. o. m.\nProtege\n5.465\n\\mathbf{5.465}\n22.032\n\\mathbf{22.032}\nGraphDB\n1820\n1820\n1606\n1606\nTable 1\n:\nLoading and reasoning times for different frameworks in seconds. The raw data contains 54,897 statements. The reasoned data contains 1,502,966 statements.\nQuery\nResults\nSQLAlchemy\nGraphDB\nEQL\nRDFLib\nowlready2\nProtege\nQ2\n7421\n3.78\n±\n0.24\n\\mathbf{3.78\\pm 0.24}\n20.02\n±\n4.74\n20.02\\pm 4.74\n58.77\n±\n0.96\n58.77\\pm 0.96\n99.90\n±\n18.08\n99.90\\pm 18.08\n142.37\n±\n18.19\n142.37\\pm 18.19\n1620.4\n±\n74.08\n1620.4\\pm 74.08\nQ3\n55\n0.58\n±\n0.36\n\\mathbf{0.58\\pm 0.36}\n2.69\n±\n0.58\n2.69\\pm 0.58\n2.11\n±\n0.20\n2.11\\pm 0.20\n2.91\n±\n0.84\n2.91\\pm 0.84\n43.32\n±\n0.75\n43.32\\pm 0.75\n15.7\n±\n1.418\n15.7\\pm 1.418\nQ4\n2486\n86.22\n±\n250.70\n86.22\\pm 250.70\n8.67\n±\n1.22\n\\mathbf{8.67\\pm 1.22}\n29.31\n±\n1.40\n29.31\\pm 1.40\n34.61\n±\n0.73\n34.61\\pm 0.73\n90.57\n±\n0.48\n90.57\\pm 0.48\n17.9\n±\n5.238\n17.9\\pm 5.238\nQ5\n20\n1.33\n±\n0.43\n1.33\\pm 0.43\n2.72\n±\n0.77\n2.72\\pm 0.77\n1.52\n±\n0.12\n1.52\\pm 0.12\n2.30\n±\n0.58\n2.30\\pm 0.58\n7.15\n±\n0.22\n7.15\\pm 0.22\n0.5\n±\n1.581\n\\mathbf{0.5\\pm 1.581}\nQ7\n1684\n1.28\n±\n0.10\n\\mathbf{1.28\\pm 0.10}\n6.65\n±\n0.35\n6.65\\pm 0.35\n10.01\n±\n0.43\n10.01\\pm 0.43\n24.65\n±\n0.62\n24.65\\pm 0.62\n113.44\n±\n1.29\n113.44\\pm 1.29\n4193.2\n±\n341.577\n4193.2\\pm 341.577\nQ8\n6\n0.54\n±\n0.22\n\\mathbf{0.54\\pm 0.22}\n2.46\n±\n0.33\n2.46\\pm 0.33\n1.77\n±\n0.06\n1.77\\pm 0.06\n1.99\n±\n0.12\n1.99\\pm 0.12\n43.25\n±\n0.77\n43.25\\pm 0.77\n12.8\n±\n1.229\n12.8\\pm 1.229\nQ10\n666\n0.80\n±\n0.09\n\\mathbf{0.80\\pm 0.09}\n4.63\n±\n1.69\n4.63\\pm 1.69\n23.75\n±\n0.88\n23.75\\pm 0.88\n13.01\n±\n0.22\n13.01\\pm 0.22\n75.16\n±\n0.95\n75.16\\pm 0.95\n17.1\n±\n1.370\n17.1\\pm 1.370\nQ11\n2422\n1.52\n±\n0.07\n\\mathbf{1.52\\pm 0.07}\n8.81\n±\n1.55\n8.81\\pm 1.55\n35.18\n±\n1.49\n35.18\\pm 1.49\n32.24\n±\n0.66\n32.24\\pm 0.66\n76.62\n±\n0.38\n76.62\\pm 0.38\n20.8\n±\n1.317\n20.8\\pm 1.317\nQ15\n21\n0.51\n±\n0.18\n\\mathbf{0.51\\pm 0.18}\n2.41\n±\n0.31\n2.41\\pm 0.31\n14.30\n±\n0.52\n14.30\\pm 0.52\n2.37\n±\n0.33\n2.37\\pm 0.33\n31.13\n±\n1.94\n31.13\\pm 1.94\n12.5\n±\n0.85\n12.5\\pm 0.85\nQ16\n21\n0.49\n±\n0.11\n\\mathbf{0.49\\pm 0.11}\n2.36\n±\n0.14\n2.36\\pm 0.14\n1.73\n±\n0.05\n1.73\\pm 0.05\n2.21\n±\n0.10\n2.21\\pm 0.10\n27.57\n±\n0.84\n27.57\\pm 0.84\n12.6\n±\n1.174\n12.6\\pm 1.174\nQ19\n858\n4.25\n±\n0.19\n4.25\\pm 0.19\n3.94\n±\n0.21\n\\mathbf{3.94\\pm 0.21}\n4.74\n±\n0.25\n4.74\\pm 0.25\n11.11\n±\n0.42\n11.11\\pm 0.42\n49.11\n±\n0.42\n49.11\\pm 0.42\n5.6\n±\n0.843\n5.6\\pm 0.843\nQ20\n1311932\n626.28\n±\n259.77\n\\mathbf{626.28\\pm 259.77}\n2779.74\n±\n95.42\n2779.74\\pm 95.42\n7926.19\n±\n151.63\n7926.19\\pm 151.63\n28957.92\n±\n456.97\n28957.92\\pm 456.97\n1764.62\n±\n24.80\n1764.62\\pm 24.80\n>\n60000.0\n>60000.0\nQ21\n145\n18.21\n±\n25.90\n18.21\\pm 25.90\n30.05\n±\n80.55\n30.05\\pm 80.55\n61.12\n±\n17.09\n61.12\\pm 17.09\n63.08\n±\n69.27\n63.08\\pm 69.27\n11.11\n±\n11.00\n\\mathbf{11.11\\pm 11.00}\n11038.1\n±\n450.084\n11038.1\\pm 450.084\nQ22\n106\n10.45\n±\n1.46\n10.45\\pm 1.46\n3.15\n±\n0.51\n\\mathbf{3.15\\pm 0.51}\n288.94\n±\n20.58\n288.94\\pm 20.58\n1625.85\n±\n37.89\n1625.85\\pm 37.89\n6.23\n±\n0.19\n6.23\\pm 0.19\n554.9\n±\n24.324\n554.9\\pm 24.324\nGeom. Mean\n—\n3.39\n\\mathbf{3.39}\n8.07\n8.07\n19.72\n19.72\n26.45\n26.45\n49.82\n49.82\n78.33\n78.33\nTable 2:\nOWL2Bench (RL profile) query performance across frameworks. The results column displays the number of data points returned and is consistent across all frameworks. The framework-specific columns show the time in milliseconds averaged over 10 runs and the standard deviation.\n7.2\nApplication: Interactive Robot Task Understanding\nTo assess the suitability of\nKRROOD\nfor\nKR&R\napplications in physical intelligence systems, we conducted a series of human-robot interactive task learning experiments. A human demonstrates pick-and-insert actions using a Montessori box, and the robot learns to reproduce the task by observing object–hole insertion patterns and selecting its own actions accordingly (see Fig.\n2\n).\nFigure 2\n:\nA virtual robot performing an object insertion learned from human demonstration, with the human interacting through a\nVR\ninterface.\nAction annotation and reasoning are handled by Segmind, an interactive robot-learning framework based on\nKRROOD\n, which represents agents, actions, and interaction relations symbolically to enable logical inference and explainable decision-making. The experiments were implemented in Multiverse\n6\n6\n6\nhttps://github.com/Multiverse-Framework/Multiverse\nNguyen and Beetz (\n2024\n)\n, which records complete interaction scenarios via a\nVR\nheadset with hand tracking. Visual rendering is performed in Unreal Engine 5, while physics simulation is handled by MuJoCo\nTodorov\net al.\n(\n2012\n)\n, with all interaction data recorded for analysis.\nThe interaction follows a demonstration, feedback, and generalization loop. The human first demonstrates a correct object insertion, after which the robot attempts the task based on the observed action. Upon failure, the robot requests a corrective demonstration through audio and infers the object–hole matching constraint. Using this inferred rule, the robot successfully completes the insertion task for the remaining objects.\n7\n7\n7\nA video of the experiment, experiment code, and an interactive simulation environment will be provided online after double-blind review.\nDuring task execution, Segmind continuously identifies objects and events relevant to the task. The robot infers new task-relevant knowledge using previously learned inference rules stored as\nRDR\ntrees. The\nRDR\ntrees are contextual by design. For example, a single tree may encode the sequence of dynamic events required to recognize a\nPickUp\naction. Each tree can contain multiple rules corresponding to different situations encountered during the robot’s operation. These rules are incrementally constructed through interaction with the human, who answers the robot’s queries during learning. Reasoning in this framework goes beyond simple rule matching by allowing individual rules to invoke different reasoning mechanisms, such as geometric reasoning (e.g., shapes or holes), spatial reasoning (e.g., containment), and physics-based reasoning. This heterogeneity is supported by the flexible design of the RDR implementation.\nListing\n5\nillustrates a portion of the RDR tree in Segmind that annotates\nPickUp\n-related events. A rule detects a\nLossOfContactEvent\ninvolving a support object, where contact events are inferred via physics-based collision reasoning in the Multiverse simulation. This leads to a\nLossOfSupport\ninference. Using a General RDR, the tree is re-evaluated until no new inferences are produced, allowing refinement rules to fire in subsequent passes. As a result, the event is classified as a\nPickUpEvent\n, unless a refinement rule determines that the object is falling.\nListing 5:\nPart of the RDR tree for event annotation\n⬇\n1\nevent\n=\nvariable_from\n(\ndomain\n=\nnew_events\n)\n2\nwith\nHasType\n(\nevent\n,\nLossOfContactEvent\n)\n3\n&\nHasType\n(\nevent\n.\nother_body\n,\nSupport\n):\n4\nAdd\n(\ninference\n(\nLossOfSupportEvent\n)(\nbody\n=\nevent\n.\nbody\n,\nsupport\n=\nevent\n.\nother_body\n))\n5\nwith\nHasType\n(\nevent\n,\nLossOfSupportEvent\n):\n6\nAdd\n(\ninference\n(\nPickUpEvent\n)(\nbody\n=\nevent\n.\nbody\n))\n7\nwith\nrefinement\n(\nEqual\n(\nevent\n.\nbody\n.\nacceleration\n,\nGRAVITY_ACC\n):\n8\nAdd\n(\ninference\n(\nFallingEvent\n)(\nbody\n=\nevent\n.\nbody\n))\nAt any point during execution, queries can be issued about the robot’s current knowledge of the world, and about how specific events were inferred. Such explanations are enabled by two core capabilities of\nKRROOD\n: (i) the ability to trace which rules contributed to a given conclusion, and (ii) the ability of\nEQL\nto access domain knowledge represented as class data structures, including the inference rules themselves.\n8\nDiscussion and Conclusion\nThis paper introduces\nKRROOD\n, a Python-native\nKR&R\nsystem built on\nOOD\nprinciples. The experiments indicate that treating knowledge as a first-class abstraction in Python can bridge the representational gap between\nKR&R\ntooling and application-centric software engineering.\nCapabilities.\nKRROOD\nenables hybrid AI systems by representing knowledge as Python domain objects that are directly usable by application code. This allows\nEQL\npredicates and\nRDR\nrule conditions to invoke domain procedures (e.g., geometry, kinematics, simulation) and avoids reliance on external reasoners, while supporting end-to-end introspection and explanation during execution\nBeetz\net al.\n(\n2025\n); Mania\net al.\n(\n2024\n); Alt\net al.\n(\n2023\n); Stelter\net al.\n(\n2022\n)\n. Second, the combination of\nEQL\nwith ORMatic enables knowledge engineering with\nOOP\nand efficient relational persistence with manageable overheads.\nKRROOD\nincurs higher loading costs due to object materialization, but provides competitive reasoning and query capabilities.\nLimitations.\nEQL\nmakes several principled operational choices (e.g. negation-as-failure and active-domain universal quantification) that align with closed-world assumptions common in physical\nAI\napplications, but differ from open-world\nDL\nsemantics. Allowing arbitrary Python code in predicates and rules increases practical expressivity but weakens static guarantees such as worst-case runtime and termination. Likewise, Ontomatic preserves most OWL-DL semantics but cannot be fully lossless in general due to modeling mismatches (e.g., non-disjoint sibling classes). Large-scale deployments may incur high memory and latency costs from materializing rich object graphs, though reasoning with\nKRROOD\nis orders of magnitude more memory-efficient than OWL-based alternatives.\nFuture work.\nPromising directions include defining stricter\nEQL\nfragments with explicit complexity bounds, as well as developing hybrid materialization strategies that instantiate only task-relevant subgraphs on demand.\n\\Ac\nkrrood will be evaluated on large-scale, long horizon experiments on intelligent robot task planning and control, human-robot task learning and explainable machine learning.\nReferences\nK. Abicht (2023)\nOWL reasoners still useable in 2023\n.\narXiv preprint arXiv:2309.06888\n.\nCited by:\n§1\n.\nB. Alt, F. K. Kenfack, A. Haidu, D. Katic, R. Jäkel, and M. Beetz (2023)\nKnowledge-driven robot program synthesis from human vr demonstrations\n.\narXiv preprint arXiv:2306.02739\n.\nCited by:\n§8\n.\nA. Armas Romero, B. Cuenca Grau, and I. Horrocks (2012)\nMORe: modular combination of owl reasoners for ontology classification\n.\nIn\nInternational Semantic Web Conference\n,\npp. 1–16\n.\nCited by:\n§2\n.\nA. Baci, L. Friedrichs, C. Demir, and A. N. Ngomo (2025)\nOWLAPY: a pythonic framework for owl ontology engineering\n.\narXiv preprint arXiv:2511.08232\n.\nCited by:\n§2.1\n.\nC. Banse, A. Schneider, and I. Kunz (2024)\nOwl2proto: enabling semantic processing in modern cloud micro-services\n.\narXiv preprint arXiv:2411.06562\n.\nCited by:\n§2\n.\nS. Baset and K. Stoffel (2018)\nObject-oriented modeling with ontologies around: a survey of existing approaches\n.\nInternational Journal of Software Engineering and Knowledge Engineering\n28\n(\n11n12\n),\npp. 1775–1794\n.\nCited by:\n§2\n.\nM. Beetz, D. Beßler, A. Haidu, M. Pomarlan, A. K. Bozcuoğlu, and G. Bartels (2018)\nKnow rob 2.0—a 2nd generation knowledge processing framework for cognition-enabled robotic agents\n.\nIn\n2018 IEEE international conference on robotics and automation (ICRA)\n,\npp. 512–519\n.\nCited by:\n§2.1\n.\nM. Beetz, G. Kazhoyan, and D. Vernon (2025)\nRobot manipulation in everyday activities with the cram 2.0 cognitive architecture and generalized action plans\n.\nCognitive Systems Research\n,\npp. 101375\n.\nCited by:\n§1\n,\n§6\n,\n§8\n.\nD. G. Bobrow and T. Winograd (1977)\nAn overview of krl, a knowledge representation language\n.\nCognitive science\n1\n(\n1\n),\npp. 3–46\n.\nCited by:\n§1\n,\n§2.1\n.\nR. Brachman and H. Levesque (2004)\nKnowledge representation and reasoning\n.\nElsevier\n.\nCited by:\n§4\n.\nL. Buoncompagni and F. Mastrogiovanni (2024)\nOWLOOP: interfaces for mapping owl axioms into oop hierarchies\n.\narXiv preprint arXiv:2404.09305\n.\nCited by:\n§1\n,\n§2\n.\nP. Carbonnelle (2020)\nPyDatalog\n.\nExternal Links:\nLink\nCited by:\n§2.1\n.\nP. Compton and B. H. Kang (2021)\nRipple-down rules: the alternative to machine learning\n.\n1 edition\n,\nChapman and Hall/CRC\n.\nExternal Links:\nDocument\n,\nISBN 9780367501425\nCited by:\n§4\n,\n§4\n.\nR. Davis, H. Shrobe, and P. Szolovits (1993)\nWhat is a knowledge representation?\n.\nAI magazine\n14\n(\n1\n),\npp. 17–17\n.\nCited by:\n§6\n.\nJ. P. Delgrande, B. Glimm, T. Meyer, M. Truszczynski, and F. Wolter (2024)\nCurrent and future challenges in knowledge representation and reasoning (dagstuhl perspectives workshop 22282)\n.\nDagstuhl Manifestos\n10\n(\n1\n),\npp. 1–61\n.\nCited by:\n§1\n.\nA. Dries, A. Kimmig, W. Meert, J. Renkens, G. Van den Broeck, J. Vlasselaer, and L. De Raedt (2015)\nProblog2: probabilistic logic programming\n.\nIn\nJoint european conference on machine learning and knowledge discovery in databases\n,\npp. 312–315\n.\nCited by:\n§2.1\n.\nB. Glimm, I. Horrocks, B. Motik, G. Stoilos, and Z. Wang (2014)\nHermiT: an owl 2 reasoner\n.\nJournal of automated reasoning\n53\n(\n3\n),\npp. 245–269\n.\nCited by:\n§2\n.\nN. Guarino and C. A. Welty (2004)\nAn overview of ontoclean\n.\nIn\nHandbook on Ontologies\n,\nS. Staab and R. Studer (Eds.)\n,\npp. 151–171\n.\nExternal Links:\nISBN 978-3-540-24750-0\n,\nDocument\n,\nLink\nCited by:\n§5\n.\nV. Haarslev, K. Hidde, R. Möller, and M. Wessel (2012)\nThe racerpro knowledge representation and reasoning system\n.\nSemantic Web\n3\n(\n3\n),\npp. 267–277\n.\nCited by:\n§2\n.\nY. He, J. Chen, H. Dong, I. Horrocks, C. Allocca, T. Kim, and B. Sapkota (2024)\nDeeponto: a python package for ontology engineering with deep learning\n.\nSemantic Web\n15\n(\n5\n),\npp. 1991–2004\n.\nCited by:\n§2\n.\nM. Horridge and S. Bechhofer (2011)\nThe owl api: a java api for owl ontologies\n.\nSemantic web\n2\n(\n1\n),\npp. 11–21\n.\nCited by:\n§2\n.\nC. Ireland and D. Bowers (2015)\nExposing the myth: object-relational impedance mismatch is a wicked problem\n.\nIn\nDBKDA 2015, The Seventh International Conference on Advances in Databases, Knowledge, and Data Applications\n,\npp. 21–26\n.\nCited by:\n§1\n.\nM. Kifer and C. Knowledge (2018)\nERGOAI reasoner user’s manual\n.\nCited by:\n§2.1\n.\nM. Kleppmann (2019)\nDesigning data-intensive applications\n.\nEnglish\n.\nCited by:\n§6\n.\nJ. Lamy (2017)\nOwlready: ontology-oriented programming in python with automatic classification and high level constructs for biomedical ontologies\n.\nArtificial intelligence in medicine\n80\n,\npp. 11–28\n.\nCited by:\n§2\n.\nM. Ledvinka, B. Kostov, and P. Křemen (2016)\nJOPA: efficient ontology-based information system design\n.\nIn\nEuropean Semantic Web Conference\n,\npp. 156–160\n.\nCited by:\n§2\n.\nM. Ledvinka and P. Křemen (2020)\nA comparison of object-triple mapping libraries\n.\nSemant. Web\n11\n(\n3\n),\npp. 483–524\n.\nExternal Links:\nISSN 1570-0844\n,\nLink\n,\nDocument\nCited by:\n§1\n,\n§2\n.\nP. Mania, S. Stelter, G. Kazhoyan, and M. Beetz (2024)\nAn open and flexible robot perception framework for mobile manipulation tasks\n.\nIn\n2024 IEEE International Conference on Robotics and Automation (ICRA)\n,\npp. 17445–17451\n.\nCited by:\n§8\n.\nM. Minsky (1974)\nA framework for representing knowledge\n.\nCited by:\n§1\n,\n§2.1\n.\nY. Nenov, R. Piro, B. Motik, I. Horrocks, Z. Wu, and J. Banerjee (2015)\nRDFox: a highly-scalable rdf store\n.\nIn\nInternational Semantic Web Conference\n,\npp. 3–20\n.\nCited by:\n§2\n.\nT. Neward (2006)\nThe vietnam of computer science\n.\nThe Blog Ride, Ted Newards Technical Blog\n.\nCited by:\n§6\n.\nA. Newell (1982)\nThe knowledge level\n.\nArtificial intelligence\n18\n(\n1\n),\npp. 87–127\n.\nCited by:\n§1\n.\nG. Nguyen and M. Beetz (2024)\nMultiverse\nExternal Links:\nLink\n,\nDocument\nCited by:\n§7.2\n.\nR. B. Roberts and I. P. Goldstein (1977)\nThe frl primer.\n.\nTechnical report\nCited by:\n§1\n,\n§2.1\n.\nR. C. Schank and R. P. Abelson (1977)\nScripts, plans, goals, and understanding: an inquiry into human knowledge structures\n.\nHillsdale, NJ: Lawrence Erlbaum Associates\n.\nCited by:\n§1\n.\nG. Singh, S. Bhatia, and R. Mutharaju (2020)\nOWL2Bench: a benchmark for owl 2 reasoners\n.\nIn\nInternational semantic web conference\n,\npp. 81–96\n.\nCited by:\n§1\n,\n§7.1\n.\nS. Stelter, G. Bartels, and M. Beetz (2022)\nAn open-source motion planning framework for mobile manipulators using constraint-based task space control with linear mpc\n.\nIn\n2022 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)\n,\npp. 1671–1678\n.\nCited by:\n§8\n.\nB. Szekely and J. Betz (2009)\nJastor: typesafe, ontology driven rdf access from java\n.\nAvavilable online: http://jastor. sourceforge. net/. Last accessed\n.\nCited by:\n§2\n.\nJ. Töberg, A. Ngonga Ngomo, M. Beetz, and P. Cimiano (2024)\nCommonsense knowledge in cognitive robotics: a systematic literature review\n.\nFrontiers in Robotics and AI\n11\n,\npp. 1328934\n.\nCited by:\n§1\n.\nE. Todorov, T. Erez, and Y. Tassa (2012)\nMujoco: a physics engine for model-based control\n.\nIn\n2012 IEEE/RSJ international conference on intelligent robots and systems\n,\npp. 5026–5033\n.\nCited by:\n§7.2\n.\nS. R. Varey, A. Di Stefano, and T. A. Han (2025)\nKERAIA: an adaptive and explainable framework for dynamic knowledge representation and reasoning\n.\narXiv preprint arXiv:2505.04313\n.\nCited by:\n§2\n.\nK. Wenzel (2010)\nKOMMA: an application framework for ontology-based software systems\n.\nSemantic Web–Interoperability, Usability, Applicability\n1\n,\npp. 1–10\n.\nCited by:\n§2\n.\nF. Zhapa-Camacho, M. Kulmanov, and R. Hoehndorf (2023)\nMOWL: python library for machine learning with biomedical ontologies\n.\nBioinformatics\n39\n(\n1\n),\npp. btac811\n.\nCited by:\n§2\n.",
    "preview_text": "This paper introduces KRROOD, a framework designed to bridge the integration gap between modern software engineering and Knowledge Representation & Reasoning (KR&R) systems. While Object-Oriented Programming (OOP) is the standard for developing complex applications, existing KR&R frameworks often rely on external ontologies and specialized languages that are difficult to integrate with imperative code. KRROOD addresses this by treating knowledge as a first-class programming abstraction using native class structures, bridging the gap between the logic programming and OOP paradigms. We evaluate the system on the OWL2Bench benchmark and a human-robot task learning scenario. Experimental results show that KRROOD achieves strong performance while supporting the expressive reasoning required for real-world autonomous systems.\n\nImplementing Knowledge Representation and Reasoning with Object Oriented Design\nAbdelrhman Bassiouny\nTom Schierenbeck\nSorin Arion\nBenjamin Alt\nNaren Vasantakumaar\nGiang Nguyen&Michael Beetz\nAICOR Institute for Artificial Intelligence\nUniversity of Bremen\nBremen, Germany\nbassioun@uni-bremen.de,\ntom_sch@uni-bremen.de,\nsorin@uni-bremen.de,\nbenjamin.alt@uni-bremen.de,\nnaren@uni-bremen.de,\nhoanggia@uni-bremen.de,\nbeetz@cs.uni-bremen.de\nAbstract\nThis paper introduces KRROOD, a framework designed to bridge the integration gap between modern software engineering and\nknowledge representation and reasoning\n(\nKR&R\n) systems. While\nobject-oriented programming\n(\nOOP\n) is the standard for developing complex applications, existing\nKR&R\nframeworks often rely on external ontologies and specialized languages that are difficult to integrate with imperative code. KRROOD addresses this by treating knowledge as a first-class programming abstraction using native class structures, bridging the gap between the logic programming and OOP paradigms. We evaluate the system on the OWL2Bench benchmark and a human-robot task learning scenario. Experimental results show that KRROOD",
    "is_relevant": false,
    "relevance_score": 0.0,
    "extracted_keywords": [
        "Knowledge Representation",
        "Reasoning",
        "Object-Oriented Design",
        "KRROOD",
        "OOP",
        "logic programming",
        "human-robot task learning"
    ],
    "one_line_summary": "这篇论文介绍了一个名为KRROOD的框架，旨在通过面向对象设计桥接知识表示与推理系统与现代软件工程之间的集成鸿沟。",
    "detailed_summary": "",
    "qa_pairs": [],
    "is_hidden": false,
    "is_starred": false,
    "flag": true,
    "published_date": "2026-01-21T10:14:29Z",
    "created_at": "2026-01-27T15:53:19.192332",
    "updated_at": "2026-01-27T15:53:19.192339"
}