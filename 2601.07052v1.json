{
    "id": "2601.07052v1",
    "title": "RSLCPP -- Deterministic Simulations Using ROS 2",
    "authors": [
        "Simon Sagmeister",
        "Marcel Weinmann",
        "Phillip Pitschi",
        "Markus Lienkamp"
    ],
    "abstract": "ä»¿çœŸåœ¨ç°å®ä¸–ç•Œæœºå™¨äººæŠ€æœ¯ä¸­è‡³å…³é‡è¦ï¼Œå®ƒä¸ºä»äººå½¢æœºå™¨äººåˆ°è‡ªåŠ¨é©¾é©¶æ±½è½¦å’Œæ— äººæœºç­‰å„ç±»åº”ç”¨çš„å¼€å‘æä¾›äº†å®‰å…¨ã€å¯æ‰©å±•ä¸”é«˜æ•ˆçš„ç¯å¢ƒã€‚å°½ç®¡æœºå™¨äººæ“ä½œç³»ç»Ÿï¼ˆROSï¼‰å·²åœ¨å­¦æœ¯ç•Œå’Œå·¥ä¸šç•Œè¢«å¹¿æ³›é‡‡çº³ä¸ºè¿™äº›æœºå™¨äººåº”ç”¨çš„æ”¯æŸ±ï¼Œä½†å…¶å¼‚æ­¥å¤šè¿›ç¨‹è®¾è®¡ä½¿å¾—å¯å¤ç°æ€§å˜å¾—å¤æ‚ï¼Œå°¤å…¶æ˜¯åœ¨ä¸åŒç¡¬ä»¶å¹³å°ä¹‹é—´ã€‚å½“è®¡ç®—æ—¶é—´å’Œé€šä¿¡å»¶è¿Ÿå­˜åœ¨å·®å¼‚æ—¶ï¼Œæ— æ³•ä¿è¯å›è°ƒæ‰§è¡Œçš„ç¡®å®šæ€§ã€‚è¿™ç§å¯å¤ç°æ€§çš„ç¼ºå¤±ç»™ç§‘å­¦åŸºå‡†æµ‹è¯•å’ŒæŒç»­é›†æˆå¸¦æ¥äº†å›°éš¾ï¼Œè€Œè¿™äº›é¢†åŸŸæ°æ°éœ€è¦ä¸€è‡´çš„ç»“æœã€‚ä¸ºè§£å†³è¿™ä¸€é—®é¢˜ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§ä½¿ç”¨ROS 2èŠ‚ç‚¹åˆ›å»ºç¡®å®šæ€§ä»¿çœŸçš„æ–¹æ³•ã€‚æˆ‘ä»¬å¼€å‘çš„C++ç‰ˆROSä»¿çœŸåº“ï¼ˆRSLCPPï¼‰å®ç°äº†è¿™ä¸€æ–¹æ³•ï¼Œä½¿å¾—ç°æœ‰èŠ‚ç‚¹èƒ½å¤Ÿç»„åˆæˆä»¿çœŸä¾‹ç¨‹ï¼Œæ— éœ€ä»»ä½•ä»£ç ä¿®æ”¹å³å¯è·å¾—å¯å¤ç°çš„ç»“æœã€‚æˆ‘ä»¬é€šè¿‡åˆæˆåŸºå‡†æµ‹è¯•å’ŒçœŸå®æœºå™¨äººç³»ç»Ÿæµ‹è¯•è¯æ˜ï¼Œè¯¥æ–¹æ³•åœ¨ä¸åŒCPUå’Œæ¶æ„ä¸Šå‡èƒ½äº§ç”Ÿå®Œå…¨ä¸€è‡´çš„ç»“æœã€‚RSLCPPå·²åœ¨https://github.com/TUMFTM/rslcppå¼€æºã€‚",
    "url": "https://arxiv.org/abs/2601.07052v1",
    "html_url": "https://arxiv.org/html/2601.07052v1",
    "html_content": "RSLCPP - Deterministic Simulations Using\nROSÂ 2\nSimon Sagmeister\n1\n, Marcel Weinmann\n1\n, Phillip Pitschi\n2\n, and Markus Lienkamp\n1\n*This work was funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) â€“ 469341384\n1\nTechnical University of Munich, Germany; School of Engineering & Design, Department of Mobility Systems Engineering, Institute of Automotive Technology\n2\nTechnical University of Munich, Germany; School of Engineering & Design, Department of Engineering Physics and Computation, Institute of Automatic Control\nCorresponding author:\nsimon.sagmeister@tum.de\nAbstract\nSimulation is crucial in real-world robotics, offering safe, scalable, and efficient environments for developing applications, ranging from humanoid robots to autonomous vehicles and drones.\nWhile the Robot Operating System (\nROS\n) has been widely adopted as the backbone of these robotic applications in both academia and industry, its asynchronous, multiprocess design complicates reproducibility, especially across varying hardware platforms. Deterministic callback execution cannot be guaranteed when computation times and communication delays vary.\nThis lack of reproducibility complicates scientific benchmarking and continuous integration, where consistent results are essential.\nTo address this, we present a methodology to create deterministic simulations using\nROSÂ 2\nnodes. Our ROS Simulation Library for C++ (\nrslcpp\n) implements this approach, enabling existing nodes to be combined into a simulation routine that yields reproducible results without requiring any code changes.\nWe demonstrate that our approach yields identical results across various CPUs and architectures when testing both a synthetic benchmark and a real-world robotics system.\nrslcpp\nis open-sourced at\nhttps://github.com/TUMFTM/rslcpp\n.\nThis work has been submitted to the IEEE for possible publication. Copyright may be transferred without notice, after which this version may no longer be accessible.\nI\nIntroduction\nModern robotics is a rapidly growing field that has garnered significant attention from both academia and industry in recent years\n[\n1\n,\n2\n]\n. The Robot Operating System (\nROS\n)\n[\n3\n,\n4\n]\nis a popular middleware and software framework that enables the development and deployment of modular robotic systems. It has been widely adopted across a broad range of robotic applications, including both commercial products and research, spanning wheeled and legged ground robots, aerial drones, and underwater vehicles\n[\n4\n,\n5\n]\n. Simulation plays a pivotal role in these fields, as it enables the evaluation and development of algorithms without the need for expensive hardware, thereby allowing a broader community to contribute to research\n[\n1\n]\n.\nAlthough\nROSÂ 2\nprovides mechanisms for simulated time, its asynchronous, multiprocess design means that callback execution order cannot be guaranteed\n[\n4\n]\n. Figure\n1\nillustrates that computation times, transmission delays, and scheduling overhead can significantly influence the execution order of callbacks in such a multiprocess system.\nHowever, both the execution order and the timing of these callbacks can have a substantial impact on the outcomes of complex multiprocess simulations\n[\n6\n,\n7\n]\n.\nAs a consequence, achieving exact reproducibility of simulation results remains challenging, despite an identical software setup. This issue is further exacerbated when testing on various hardware platforms, such as during continuous integration testing.\nAs a workaround, code is frequently benchmarked outside its\nROSÂ 2\n-based implementation\n[\n8\n]\n.\nHowever, as the integration into\nROSÂ 2\noften constitutes a significant portion of the codebase\n[\n9\n]\n, testing in isolation fails to validate the complete system and neglects potential side effects.\n(a)â€„\nAsynchronous multi-process execution\n(b)â€„\nDeterministic synchronous execution using our approach.\nFigure 1:\nIllustrative comparison of asynchronous and synchronous execution. The example consists of timerÂ (\nğ’¯\n1\n\\mathcal{T}_{1}\n,\nğ’¯\n2\n\\mathcal{T}_{2}\n) and subscriptionÂ (\nğ’®\n1\n\\mathcal{S}_{1}\n) callbacks.\nğ’®\n1\n\\mathcal{S}_{1}\nis triggered by a publisher at the end of\nğ’¯\n2\n\\mathcal{T}_{2}\n. In the asynchronous case, the callback runtimes influence the order in which the callbacks are processed. With our approach, they remain in a fixed order.\nt\nt\nindicates wall time progression, which is decoupled from the simulation time for the synchronous example.\nTo address the aforementioned limitations, we introduce a methodology for achieving deterministic execution order and timing of callbacks in a multi-node\nROSÂ 2\nsystem.\nBy decoupling simulation progress from computation time, our approach enables sped-up simulations or the evaluation of algorithms that are not yet real-time capable.\nThis acts as a robust baseline for scientific benchmarking and continuous integration testing.\nFor this, the main contributions of this paper are:\nâ€¢\nWe present a methodology for enforcing deterministic execution of\nROSÂ 2\ncallbacks, thereby enabling fully reproducible and hardware-agnostic simulation results.\nâ€¢\nWe validate the proposed approach across multiple CPU architectures using both a synthetic benchmark and a real-world robotic system.\nâ€¢\nWe implement and open-source the presented methodology in the ROS Simulation Library for C++ (\nrslcpp\n). This library enables the creation of deterministic simulations using existing\nROSÂ 2\nnodes without requiring any code changes.\nII\nRelated Work\nOnly a few approaches in the literature address the lack of predictability in\nROS\n-based systems.\nOtto\n[\n10\n]\nidentifies different sources of non-deterministic execution in\nROSÂ 2\nand proposes a method to ensure reproducible execution orders.\nThis work introduces an orchestrator that uses callback graphs and ordering constraints to schedule the execution of callbacks in a deterministic way.\nHowever, this orchestrator requires a specific callback structure, hence necessitating modifications to the code of many\nROSÂ 2\nnodes.\nOther works\n[\n11\n,\n12\n]\npropose\nROSÂ 2\nexecutors that aim to improve the predictability of callback execution.\nHowever, their focus lies on real-time capability rather than determinism.\nThese works assign priorities to each callback or chain of callbacks based on real-time requirements.\nTo ensure execution according to the assigned priorities, Randolph\n[\n12\n]\nutilizes a multi-threaded executor.\nIn contrast, Choi et al.\n[\n11\n]\nemploy multiple executors for different callback chains, assigning each executor to a single core.\nFurthermore, the\nGazebo\nsimulator\n[\n13\n]\noffers a lockstep mode.\nThis mode allows the executor to pause the simulation, enabling synchronization of all sensor outputs.\nHowever, the execution order of the remaining software interacting with the simulator remains uncontrolled and can still lead to non-deterministic behavior.\nAdditionally, deterministic executors for\nmicro-ROS\n, a\nROSÂ 2\nvariant for microcontrollers, have been proposed.\nStaschulat et al.\n[\n14\n]\npresent a deterministic\nrclc\nexecutor that can execute callbacks in a user-defined order and handle various trigger conditions for callback processing.\nIn a later work, this executor has been extended to a budget-based multi-threaded executor to improve predictability in real-time applications\n[\n15\n]\n.\nSimilarly, Wang et al.\n[\n16\n]\nextend the deterministic\nrclc\nexecutor to address the problem of priority inversion, where lower-priority tasks block high-priority tasks.\nThey propose an executor with a list of ready tasks sorted by priority to replace the set in the original executor, ensuring the earlier execution of high-priority tasks.\nIn summary, various approaches exist to improve callback scheduling and execution order. However, none provide a comprehensive solution for creating deterministic simulations that can be easily integrated without requiring heavy modification of the existing\nROSÂ 2\ncodebase.\nIII\nMethodology\nTo create a deterministic simulation using\nROSÂ 2\nnodes, we first discuss the foundations for achieving deterministic callback execution. Based on these concepts, we present our approach for efficiently specifying simulation routines.\nIII-A\nAchieving Deterministic Callback Execution\nTo achieve reproducible simulation results in a generic\nROSÂ 2\nsystem, all callbacks must be executed in a defined order with precise timing.\nSince this is challenging in an asynchronous multi-process system like\nROSÂ 2\n, our approach first aggregates all nodes into a single process by utilizing node composition.\nWe require all simulation components to reside within this single process, isolated from external communication.\nThis simplifies scheduling, as all callbacks run within a single thread.\nFurther, node composition enables using efficient zero-copy intra-process communication\n[\n17\n]\n.\nTo establish deterministic execution, we implement a custom event loop, as illustrated in Fig.\n2\n.\nWithin this event loop, we utilize the\nrclcpp\nevents executor first introduced in\nROSÂ 2\nJazzy. This executor processes callbacks in a defined first-in-first-out manner\n[\n18\n]\n.\nFigure 2:\nrslcpp\nevent loop. The actions depicted in blue are specific to the\nrslcpp\nevent loop, while white coloring indicates processes implemented within the\nrclcpp\nevents executor. The loop terminates before advancing time as soon as the job object indicates that the simulation is complete.\nTo become independent of computation times, we configure all nodes to run in simulation time.\nWe advance simulation time only after the executor has finished executing all ready entities. This includes both time-triggered callbacks (e.g., timers) and successive data-triggered callbacks (e.g., subscriptions, services, clients).\nHowever, this scheme requires that the system eventually becomes idle if time is not advanced.\nConsequently, loops of data-triggered callbacks would stop time from advancing, since they would continuously trigger each other without ever reaching an idle state.\nNonetheless, this limitation rarely affects real-world robotic systems, which commonly rely on periodic control and sensor loops.\nSince the entire simulation runs in a single thread, a blocking callback (e.g., waiting for a service response) will halt the entire simulation. While this requires careful implementation of callbacks, it significantly simplifies debugging, as a breakpoint in any callback effectively pauses the entire system state.\nTo achieve maximum efficiency, we advance simulation time adaptively to the next time-triggered callback, effectively creating a discrete-event simulation\n[\n19\n]\n.\nIII-B\nDelay Modeling\nSince the discrete-event approach executes callbacks without advancing simulation time, it neglects the impact of computation time on system latency. To address this, we introduce a mechanism to artificially delay message publication. Instead of publishing a message immediately upon generation, we schedule its publication to occur after a configurable duration.\nPublishing the delayed message is handled by the custom event loop itself (Fig.\n2\n).\nThis mechanism effectively decouples simulated latency from actual computation time, allowing for the analysis of system performance under varying latency conditions without requiring runtime optimization of the underlying algorithms.\nIII-C\nSimulation Specification and Integration\nTo specify generic simulation routines, we propose a job object that encapsulates all necessary information for executing a simulation.\nIt specifies the start timestamp and defines which nodes are part of the simulation. Since\nROSÂ 2\nallows setting parameters at launch, we utilize its dynamic parameter loading instead of specifying parameters within the job itself.\nTherefore, the same job object can conduct various simulations by loading different parameters.\nAdditionally, the job object terminates the event loop as soon as the simulation routine is completed. For this, the job object provides a boolean flag that indicates whether the simulation has finished. Further, the job object can provide an exit code for the simulation routine, indicating successful or failed execution.\nTo simplify the integration of existing\nROSÂ 2\nnodes into\nrslcpp\nsimulations, we provide a dynamic job executable. This enables loading nodes dynamically at launch by utilizing the\nrclcpp\ncomponent system\n[\n17\n]\n.\nConsequently, the full simulation routine can be configured exclusively at launch.\nAs a result, existing\nrclcpp\ncomponents can be used for deterministic simulations without any code changes.\nProvided they are discoverable within the active\nROSÂ 2\nsystem, they can be loaded into the simulation without the need for recompilation.\nHowever, recompiling against our minimally modified\nrclcpp\nversion is required to enable the delay modeling feature, or to support nodes that create timers based on wall time instead of simulation time.\nThe full\nrslcpp\nlibrary, along with its documentation, usage, and integration examples, is available open-source at\nhttps://github.com/TUMFTM/rslcpp\n.\nIV\nExperimental Setup\nTo validate our claims, we will conduct two different experiments. The first experiment will focus on a synthetic benchmark system designed to test the determinism of callback execution within the simulation. For the second experiment, we will use a LiDAR odometry benchmark to demonstrate the practical applicability of our approach in a real-world robotics scenario.\nIV-A\nSynthetic Benchmark System\nTo experimentally validate the determinism of our approach, a system that is highly sensitive to callback execution order and timing is required. To achieve this, we designed a synthetic benchmark system, which is depicted in Fig.\n3\n.\nIt consists of multiple nodes interconnected via publishers, subscribers, services, and clients.\nThe system is designed to ensure that multiple callbacks (subscriptions, timers)\nbecome ready simultaneously, both within a single node and across multiple nodes.\nThis increases the potential for execution order variance when the system is executed conventionally.\nFigure 3:\nSynthetic benchmark system for testing deterministic callback execution. Timer callbacks with their respective frequencies are shown in blue, while subscription callbacks are depicted in dark gray. Service callbacks are colored green while a clientâ€™s response callback is depicted in white. Individual nodes are represented as light gray boxes.\nTo make the system sensitive to execution order and timing, each node maintains an internal state represented by a hash value. Additionally, each callback has a unique, randomly generated ID.\nEach time a callback is executed, it modifies the internal state of the node using a pseudo-random number generator\n[\n20\n]\n.\nThis random number generator is fed with the callbackâ€™s ID, the execution timestamp, the nodeâ€™s current internal state, and, if available, the callbackâ€™s input data.\nAdditionally, the nodes are interconnected by publishing their constantly updating internal state to the topics shown in Fig.\n3\n.\nComparing the systemâ€™s final state after a fixed simulation period across runs allows us to detect any non-determinism in callback execution.\nTo demonstrate that our approach is also invariant to fluctuations in computation times, each callback randomly sleeps between\n0\nand\n20\nms\n20\\text{\\,}\\frac{\\mathrm{ms}}{}\nbefore executing its logic.\nIV-B\nCase Study: LiDAR Odometry\nTo demonstrate the applicability of our framework to real-world robotics, we benchmark the LiDAR odometry algorithm\nKISS-ICP\n[\n8\n]\nusing the\nKITTI Odometry\n[\n21\n]\nSequence 00.\nKISS-ICP\nwas selected for its algorithmic simplicity, which facilitates highly reproducible results when executed in a deterministic environment.\nThe simulation setup comprises three\nROSÂ 2\nnodes: a rosbag player, the\nKISS-ICP\nnode, and a data recorder.\nThe rosbag player publishes the\nKITTI\ndata, which was pre-converted to a rosbag using\nkitti2bag\n[\n22\n]\n.\nThe recorder logs all topics to a new rosbag, which is subsequently used to compute the root-mean-squared error (RMSE) of the average positional error (APE) via\nevo\n[\n23\n]\n.\nWe limit the number of parallel threads used by\nKISS-ICP\nto the minimum required for valid results on each tested CPU, simulating the constraints of a resource-limited robotic system.\nAdditionally, we set the subscriber queue history depth to 1 and the number of ICP iterations to 100, ensuring the low latency typically required in real-world applications.\nV\nResults\nV-A\nSynthetic Benchmark System\nWe ran the synthetic benchmark system on various hardware architectures to demonstrate the deterministic execution of our approach across different systems. Table\nI\nlists the CPU models used for the experiments.\nFor each system, we performed 100 independent runs and compared the final hash values produced by all nodes.\nAcross every simulation, the final hash values were identical, confirming that the simulation framework yields fully deterministic, bit-identical results under the conditions tested.\nTABLE I:\nCPU models used for validating deterministic execution with the synthetic benchmark system.\nArchitecture\nVendor\nModel\nCores/Threads\nx86_64\nIntel\ni7-11850H\n8/16\nx86_64\nAMD\nRyzen 7 Pro 6850U\n8/16\nx86_64\nAMD\nRyzen 7 PRO 7840U\n8/16\nx86_64\nIntel\nXeon D-2166NT\n12/12\nx86_64\nAMD\nEPYC 7313P\n16/32\nx86_64\nAMD\nRyzen 9 7950X\n16/32\naarch64\nARM\nCortex-A72\n4/4\nV-B\nCase Study: LiDAR Odometry\nFig.\n4\npresents the results from running the LiDAR odometry benchmark using both native\nROSÂ 2\nand our framework.\nExperiments conducted natively in\nROSÂ 2\nexhibit substantial variability across the various hardware architectures (Fig.\n4\n).\nWhile the AMD Ryzen 9 7950X exhibits fully reproducible behavior, experiments on the AMD EPYC 7313P and Intel Xeon D-2166NT show significant result jitter. Executing the system on the ARM Cortex-A72 does not yield valid results, as the algorithm diverges.\nIn contrast, Fig.\n4\nindicates that even the multi-threaded implementation of\nKISS-ICP\nexhibits fully deterministic behavior when executed in\nrslcpp\n.\nSimilar to the results obtained from the synthetic benchmark system, all runs across all hardware architectures yield identical results.\n(a)\nROSÂ 2\n(b)\nrslcpp\nFigure 4:\nRoot-mean-squared-error (RMSE) of the average positional error (APE) over 100 simulations of the\nKISS-ICP\n[\n8\n]\non SequenceÂ 00 of the\nKITTI Odometry\n[\n21\n]\ndataset within\nROSÂ 2\nand\nrslcpp\n. The number of parallel threads is reported in parentheses. CPU models are abbreviated and correspond to Table\nI\n.\nVI\nDiscussion and Conclusion\nIn this work, we introduced a methodology for creating deterministic simulations by aggregating\nROSÂ 2\nnodes into a single process controlled by a custom event loop.\nOur experiments demonstrated bit-exact reproducibility across various systems, eliminating the variance typical of asynchronous multi-process execution.\nIt is important to note, however, that the validation of determinism is empirical rather than mathematically proven, as the complexity of\nROSÂ 2\nand its client libraries complicates formal verification.\nBy building upon the existing component system and executor architecture, our framework is tightly integrated with\nROSÂ 2\n.\nThis simplifies adoption for existing\nROSÂ 2\nprojects, as no code changes are required.\nHowever, this tight coupling also introduces a dependency on the underlying executor logic of\nROSÂ 2\n, which may necessitate maintenance efforts to ensure compatibility with future\nROSÂ 2\nreleases.\nWhile single-threaded execution may increase runtime for complex simulations, having a deterministic framework enables the execution of multiple simulations in parallel without interference, thereby increasing overall throughput.\nIn conclusion,\nrslcpp\noffers a modular, open-source solution for reproducible, hardware-agnostic robotic simulation.\nIts application areas include scientific research, system-level debugging, and continuous integration testing.\nAcknowledgment\nAuthor contributions:\nS. Sagmeister, as the first author, designed the structure of the article and contributed\nessentially to the development and implementation of the presented framework.\nM. Weinmann and P. Pitschi contributed to the paper writing and the frameworkâ€™s design and implementation.\nM. Lienkamp made an essential contribution to the concept of the research project. He revised the paper critically for important intellectual content. M. Lienkamp gives final approval for the version to be published and agrees to all aspects of the work. As a guarantor, he accepts responsibility for the overall integrity of the paper.\nAI tools (GPT5.2, Gemini 3 Pro) were used exclusively for editorial, code, and documentation refinement of author-provided input.\nReferences\n[1]\nS.Â M. Kargar, B.Â Yordanov, C.Â Harvey, and A.Â Asadipour, â€œEmerging trends in\nrealistic robotic simulations: A comprehensive systematic literature\nreview,â€\nIEEE Access\n, vol.Â 12, pp. 191â€‰264â€“191â€‰287, 2024.\n[2]\nA.Â Haghighi\netÂ al.\n, â€œA comprehensive review and bibliometric analysis\non collaborative robotics for industry: Safety emerging as a core focus,â€\nFrontiers in Robotics and AI\n, vol.Â 12, p. 1605682, Sep. 2025.\n[3]\nM.Â Quigley\netÂ al.\n, â€œRos: an open-source robot operating system,â€ in\nICRA workshop on open source software\n, vol.Â 3, no. 3.2.â€ƒKobe, 2009, p.Â 5.\n[4]\nS.Â Macenski, T.Â Foote, B.Â Gerkey, C.Â Lalancette, and W.Â Woodall, â€œRobot\nOperating System 2: Design, architecture, and uses in the wild,â€\nScience Robotics\n, vol.Â 7, no.Â 66, p. eabm6074, May 2022.\n[5]\nS.Â Macenski, T.Â Moore, D.Â V. Lu, A.Â Merzlyakov, and M.Â Ferguson, â€œFrom the\ndesks of ROS maintainers: A survey of modern & capable mobile robotics\nalgorithms in the robot operating system 2,â€\nRobotics and Autonomous\nSystems\n, vol. 168, p. 104493, 2023. [Online]. Available:\nhttps://www.sciencedirect.com/science/article/pii/S092188902300132X\n[6]\nT.Â Betz, P.Â Karle, F.Â Werner, and J.Â Betz, â€œAn Analysis of Software\nLatency for a High-Speed Autonomous Race Carâ€”A Case Study in the\nIndy Autonomous Challenge,â€\nSAE International Journal of Connected\nand Automated Vehicles\n, vol.Â 6, no.Â 3, pp. 12â€“06â€“03â€“0018, Feb. 2023.\n[7]\nD.Â Casini, T.Â BlaÃŸ, I.Â LÃ¼tkebohle, and B.Â B. Brandenburg,\nâ€œResponse-Time Analysis of ROS 2 Processing Chains Under\nReservation-Based Scheduling,â€\nLIPIcs, Volume 133, ECRTS 2019\n, vol.\n133, pp. 6:1â€“6:23, 2019.\n[8]\nI.Â Vizzo\netÂ al.\n, â€œKISS-ICP: In Defense of Point-to-Point\nICP â€“ Simple, Accurate, and Robust Registration If Done the\nRight Way,â€\nIEEE Robotics and Automation Letters\n, vol.Â 8, no.Â 2,\npp. 1029â€“1036, Feb. 2023.\n[9]\nS.Â Sagmeister\netÂ al.\n, â€œApproaching Current Challenges in\nDeveloping a Software Stack for Fully Autonomous Driving,â€ in\n2025 IEEE Intelligent Vehicles Symposium (IV)\n.â€ƒCluj-Napoca, Romania: IEEE, Jun. 2025, pp.\n1577â€“1584.\n[10]\nJ.Â Otto, â€œEnabling Reproducibility in ROS 2 by Ensuring Sequence\nDeterministic Callback Execution,â€ Masterâ€™s thesis, Ulm University, 2023.\n[Online]. Available:\nhttps://jonasotto.com/MT_Otto_unsigned.pdf\n[11]\nH.Â Choi, Y.Â Xiang, and H.Â Kim, â€œPicas: New design of priority-driven\nchain-aware scheduling for ros2,â€ in\n2021 IEEE 27th Real-Time and\nEmbedded Technology and Applications Symposium (RTAS)\n, 2021, pp. 251â€“263.\n[12]\nC.Â Randolph, â€œImproving the predictability of event chains in ros 2,â€\nPhD diss., Delft University of Technology\n, 2021.\n[13]\nN.Â Koenig and A.Â Howard, â€œDesign and use paradigms for gazebo, an open-source\nmulti-robot simulator,â€ in\nIEEE/RSJ International Conference on\nIntelligent Robots and Systems\n, Sendai, Japan, Sep 2004, pp. 2149â€“2154.\n[14]\nJ.Â Staschulat, I.Â Lutkebohle, and R.Â Lange, â€œThe rclc Executor:\nDomain-specific deterministic scheduling mechanisms for ROS\napplications on microcontrollers: Work-in-progress,â€ in\n2020\nInternational Conference on Embedded Software (EMSOFT)\n.â€ƒShanghai, China: IEEE, Sep. 2020, pp.\n18â€“19.\n[15]\nJ.Â Staschulat, R.Â Lange, and D.Â NarahariÂ Dasari, â€œBudget-based real-time\nexecutor for micro-ros,â€\narXiv e-prints\n, pp. arXivâ€“2105, 2021.\n[16]\nZ.Â Wang, S.Â Liu, X.Â Jiang, D.Â Ji, and Y.Â Wang, â€œTide: a timing-deterministic\nand efficient executor for micro-ros,â€ in\n2023 IEEE International\nConferences on Internet of Things (iThings) and IEEE Green Computing &\nCommunications (GreenCom) and IEEE Cyber, Physical & Social Computing\n(CPSCom) and IEEE Smart Data (SmartData) and IEEE Congress on Cybermatics\n(Cybermatics)\n.â€ƒIEEE, 2023, pp.\n487â€“494.\n[17]\nS.Â Macenski, A.Â Soragna, M.Â Carroll, and Z.Â Ge, â€œImpact of ROS 2 Node\nComposition in Robotic Systems,â€ May 2023.\n[18]\nH.Â Teper, O.Â Bell, M.Â GÃ¼nzel, C.Â Gill, and J.-J. Chen, â€œBridging the\nGap between ROS~2 and Classical Real-Time\nScheduling for Periodic Tasks,â€ 2024.\n[19]\nS.Â Robinson,\nSimulation: The Practice of Model Development and\nUse\n.â€ƒChichester: Wiley, 2004.\n[20]\nG.Â L. Steele, D.Â Lea, and C.Â H. Flood, â€œFast splittable pseudorandom number\ngenerators,â€\nACM SIGPLAN Notices\n, vol.Â 49, no.Â 10, pp. 453â€“472, Dec.\n2014.\n[21]\nA.Â Geiger, P.Â Lenz, and R.Â Urtasun, â€œAre we ready for autonomous driving? the\nkitti vision benchmark suite,â€ in\n2012 IEEE Conference on Computer\nVision and Pattern Recognition\n, 2012, pp. 3354â€“3361.\n[22]\nT.Â Krejci, â€œKitti2bag,â€ Nov. 2019. [Online]. Available:\nhttps://github.com/tomas789/kitti2bag\n[23]\nM.Â Grupp, â€œevo: Python package for the evaluation of odometry and slam.â€\nhttps://github.com/MichaelGrupp/evo\n, 2017.",
    "preview_text": "Simulation is crucial in real-world robotics, offering safe, scalable, and efficient environments for developing applications, ranging from humanoid robots to autonomous vehicles and drones. While the Robot Operating System (ROS) has been widely adopted as the backbone of these robotic applications in both academia and industry, its asynchronous, multiprocess design complicates reproducibility, especially across varying hardware platforms. Deterministic callback execution cannot be guaranteed when computation times and communication delays vary. This lack of reproducibility complicates scientific benchmarking and continuous integration, where consistent results are essential. To address this, we present a methodology to create deterministic simulations using ROS 2 nodes. Our ROS Simulation Library for C++ (RSLCPP) implements this approach, enabling existing nodes to be combined into a simulation routine that yields reproducible results without requiring any code changes. We demonstrate that our approach yields identical results across various CPUs and architectures when testing both a synthetic benchmark and a real-world robotics system. RSLCPP is open-sourced at https://github.com/TUMFTM/rslcpp.\n\nRSLCPP - Deterministic Simulations Using\nROSÂ 2\nSimon Sagmeister\n1\n, Marcel Weinmann\n1\n, Phillip Pitschi\n2\n, and Markus Lienkamp\n1\n*This work was funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) â€“ 469341384\n1\nTechnical University of Munich, Germany; School of Engineering & Design, Department of Mobility Systems Engineering, Institute of Automotive Technology\n2\nTechnical University of Munich, Germany; School of Engineering & Design, Department of Engineering Physics and Computation, Institute of Automatic Control\nCorresponding author:\nsimon.sagmeister@tum.de\nAbstract\nSimulation is crucial in real-world robotics, offering safe, scalable, and efficient environments for developing applications, ranging from humanoid robots to autonomous vehicles a",
    "is_relevant": false,
    "relevance_score": 1.0,
    "extracted_keywords": [
        "simulation",
        "ROS 2",
        "deterministic",
        "robotics",
        "reproducibility"
    ],
    "one_line_summary": "è¿™ç¯‡è®ºæ–‡ä»‹ç»äº†ä¸€ç§ä½¿ç”¨ROS 2å®ç°ç¡®å®šæ€§ä»¿çœŸçš„æ–¹æ³•ï¼Œæ—¨åœ¨æé«˜æœºå™¨äººä»¿çœŸä¸­çš„å¯é‡å¤æ€§ï¼Œä½†ä¸å¼ºåŒ–å­¦ä¹ ã€VLAã€æ‰©æ•£æ¨¡å‹ã€Flow Matchingã€è¿åŠ¨æ§åˆ¶ã€VLMå’Œå…¨èº«æ§åˆ¶ç­‰å…³é”®è¯æ— å…³ã€‚",
    "detailed_summary": "",
    "qa_pairs": [],
    "is_hidden": false,
    "is_starred": false,
    "flag": true,
    "published_date": "2026-01-11T20:10:54Z",
    "created_at": "2026-01-21T12:09:06.769254",
    "updated_at": "2026-01-21T12:09:06.769261",
    "recommend": 0
}