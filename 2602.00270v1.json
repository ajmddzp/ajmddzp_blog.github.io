{
    "id": "2602.00270v1",
    "title": "RVDebloater: Mode-based Adaptive Firmware Debloating for Robotic Vehicles",
    "authors": [
        "Mohsen Salehi",
        "Karthik Pattabiraman"
    ],
    "abstract": "随着嵌入式设备数量的增长及其功能需求的增加，嵌入式固件规模日益庞大，攻击面也随之扩大。尽管固件体积不断增大，但许多嵌入式设备（如机器人车辆）在不同模式下运行时仅需调用固件代码的极小部分。我们将此类设备称为基于模式的嵌入式设备。代码精简技术通过移除或限制非必要代码来缩减攻击面，但现有方法存在显著局限性，例如粒度粗放、代码删除不可逆等问题，限制了其实际应用。\n\n为突破这些限制，我们提出RVDebloater——一种面向模式化嵌入式设备的自适应代码精简技术。该技术通过静态或动态分析自动识别各模式下的非必要固件代码，并在运行时以函数粒度动态执行固件精简。RVDebloater创新性地采用基于软件的强制执行机制，可适配多种基于模式的嵌入式设备。我们基于LLVM编译器实现了该方案，并在六款不同机器人车辆（含仿真与实体设备）上通过多组实际任务评估了其效率与有效性。\n\n研究发现：设备在各模式下的需求会随生命周期动态变化，大量关键固件函数在其他模式下可被安全限制，平均85%的函数属于非必要代码。实验结果表明，经RVDebloater精简后所有任务均正常运行，未出现误删或漏删现象。此外，该技术使不同固件的调用图规模平均缩减45%。在实际机器人车辆测试中，RVDebloater仅产生平均3.9%的性能开销与4%的内存开销（约0.25MB）。",
    "url": "https://arxiv.org/abs/2602.00270v1",
    "html_url": "https://arxiv.org/html/2602.00270v1",
    "html_content": "RVDebloater: Mode-based Adaptive Firmware Debloating for Robotic Vehicles\nMohsen Salehi\nKarthik Pattabiraman\nAbstract\nAs the number of embedded devices grows and their functional requirements increase,\nembedded firmware is becoming increasingly larger, thereby expanding its attack surface.\nDespite the increase in firmware size, many embedded devices, such as robotic vehicles (RVs),\noperate in distinct modes,\neach requiring only a small subset of the firmware code at runtime.\nWe refer to such devices as\nmode-based embedded devices\n.\nDebloating is an approach to reduce attack surfaces by removing or restricting unneeded code,\nbut existing techniques suffer from significant limitations, such as coarse granularity and irreversible code removal,\nlimiting their applicability.\nTo address these limitations, we propose\nRVDebloater\n, a novel adaptive debloating technique for\nmode-based embedded devices\nthat automatically identifies unneeded firmware code for each mode\nusing either static or dynamic analysis,\nand dynamically debloats\nthe firmware for each mode at the function level at runtime.\nRVDebloater\nintroduces a new software-based enforcement approach that supports diverse\nmode-based embedded devices\n. We implemented\nRVDebloater\nusing the LLVM compiler and evaluated its efficiency and effectiveness\non six different RVs, including both simulated and real ones, with different real-world missions.\nWe find that device requirements change throughout its lifetime for each mode,\nand that many critical firmware functions can be restricted in other modes,\nwith an average of 85% of functions not being required.\nThe results showed that none of the missions failed after debloating with\nRVDebloater\n, indicating that it neither incurred false positives nor false negatives.\nFurther,\nRVDebloater\nprunes the firmware call graph by an average of 45% across different firmware.\nFinally,\nRVDebloater\nincurred an average performance overhead of 3.9% and memory overhead of 4% (approximately 0.25 MB) on real RVs.\n1\nIntroduction\nRobotic vehicles (RVs) such as unmanned aerial vehicles (UAVs),\nunmanned ground vehicles (UGVs), and remotely operated underwater vehicles (ROVs), are a prominent class of embedded devices.\nA wide range of features (e.g., system calls and device drivers\n[\n31\n]\n)\nand hardware functionalities is being incorporated into these devices\nto support the requirements of different users,\neven though each user may only require a fraction of these features.\nThis expansion enhances potentially buggy code,\neven in unused features, thereby increasing the devices’ attack surface\n[\n28\n,\n26\n,\n45\n]\n.\nFor instance,\nUAVs are vulnerable to various security vulnerabilities,\nsuch as buffer overflows\n[\n33\n,\n28\n]\n, which can allow attackers to hijack the control flow\nand manipulate critical programs like the flight control program, causing crashes.\nOne approach to reduce attack surfaces is minimizing\nor restricting unwanted features (e.g., security-critical system calls) through a technique known as\ndebloating\n[\n14\n,\n44\n,\n33\n,\n30\n,\n29\n,\n24\n,\n25\n,\n2\n]\n.\nDebloating\nkeeps\na\nsmall subset\nof firmware code necessary for specific workloads\nwhile\nrestricting\nthe execution of the remaining code\n[\n22\n,\n2\n,\n47\n,\n33\n]\n,\nor\nremoves\nunwanted features such as peripherals (e.g., USB and UART\n[\n29\n,\n30\n]\n).\nAlthough these techniques have gained popularity in different contexts,\nsuch as desktop\n[\n2\n,\n24\n]\nand\nserver applications\n[\n47\n,\n32\n,\n14\n]\n,\nembedded systems have not received sufficient attention\n[\n33\n]\n.\nDebloating techniques can be categorized into two main classes:\nfixed\nand\nadaptive\ntechniques.\nFixed debloating techniques\nsuch as SHARD\n[\n2\n]\n, Minion\n[\n33\n]\n, and FACE-CHANGE\n[\n24\n]\nanalyze applications throughout the entire lifetime, without considering how applications’ requirements change during different execution phases.\nFor instance, critical firmware code or system calls like\nexecve\nor\nfork\nare usually executed\nonly during the initial moments of an application’s lifetime.\nHowever,\nfixed debloating techniques\noften fail to disable such system calls or code,\nleaving these available to be used in exploits\n[\n22\n]\n.\nIn contrast to\nfixed debloating techniques\n, which restrict specialization granularity to the entire application’s execution lifetime,\nadaptive debloating techniques\n[\n22\n,\n47\n]\nconsider the changing requirements of an application through different execution phases.\nFor example, Ghavamnia et al.\n[\n22\n]\nand Rajagopalan et al.\n[\n47\n]\nproposed temporal system call specialization techniques for server applications,\nwhich restrict available system calls based on the application’s execution phase.\nThey use static analysis techniques to identify the required system calls for two distinct\nphases—\ninitialization\nand\nserving\n—and block unneeded system calls, such as\nfork\nand\nexecve\n,\nafter transitioning to the\nserving\nphase,\nusing a Linux-based mechanism called the Seccomp-BPF filter\n[\n49\n]\n.\nUnfortunately, adaptive debloating techniques\n[\n22\n,\n47\n]\nhave two limitations.\nFirst, similar to fixed debloating techniques, they focus on disabling security-critical system calls such as\nexecve\n.\nHowever, embedded devices’ firmware, particularly those used in RVs (e.g., ArduPilot\n[\n12\n]\n, PX4\n[\n41\n]\n), contains critical functions, such as\ndisarm_motors\n,\nwhich should only be executed in specific modes\n1\n1\n1\nWe use\nmodes\n(e.g.,\nRTL\n,\nAUTO\n) to refer to the\nphases\nof the RV.\n, e.g.,\nTurtle\nmode (i.e., flipping the copter). If not, they can lead to serious safety violations.\nSecond, these techniques use Seccomp-BPF to restrict the set of available system calls for each phase.\nHowever, the Seccomp-BPF mechanism for filtering system calls is irreversible,\nmeaning that once a system call is filtered out, it cannot be reallowed later.\nIn contrast to server applications, which typically have a simple control flow\nand do not revert to the previous phase,\nembedded devices often experience frequent mode changes, including transitions back to earlier modes (e.g.,\nAUTO <-> LOITER\n).\nTherefore, debloating techniques that cannot\ndynamically\nadjust access restrictions on firmware functions at runtime,\nsuch as those relying on Seccomp-BPF, are unsuitable for embedded devices.\nTo address the above limitations, we propose\nRVDebloater\n, an adaptive debloating approach that automatically identifies\nthe set of functionalities required by each mode (e.g.,\nTAKEOFF\n) at the function-level and then monitors the device at runtime\nto ensure that only those firmware functions are allowed to execute when the device operates in the corresponding mode.\nOur key insight is that many embedded devices-such as RVs—operate in distinct modes\n(e.g.,\nLAND\nor\nTAKEOFF\n) at runtime,\nwith each mode requiring a specific set of functionalities, implemented as functions in their firmware. We call these devices\nmode-based\nembedded devices.\nFor instance, when RVs are in\nAUTO\nmode, travelling from point A to B,\nthey do not require the motor disarming function designed for\nLAND\nmode; misuse of this function can result in crashes.\nThus, we can restrict these functionalities (firmware functions) to their respective modes at runtime.\nRVDebloater\nhas two main goals: 1) Specializing firmware code by\ndynamically\nadapting it to changes in the device’s requirements\nat the mode level throughout its execution lifetime,\nand 2) Enforcing restrictions on firmware code at\nfunction-level granularity\n,\nproviding finer specialization than system call-level\n[\n22\n,\n2\n,\n47\n]\nor hardware-level (e.g., disabling unused peripherals)\n[\n29\n,\n30\n]\ntechniques.\nRVDebloater\naddresses the above goals through two innovations. First, it uses either\nstatic\nor\ndynamic analysis\nto identify per-mode firmware code coverage,\nwhile considering changes in the device’s requirements throughout its execution\n(i.e., the set of firmware functions required for each mode).\nFor static analysis,\nRVDebloater\nuses points-to analysis\n[\n51\n,\n4\n]\nwith two pruning heuristics\nto construct a pruned call graph of the entire firmware (e.g., ArduPilot and PX4) and reduce spurious targets for indirect call sites;\nit then determines the\nreachable (required)\nfunctions for each mode based on the call graph. For dynamic analysis,\nRVDebloater\nemploys a dynamic profiling technique by executing the device with different workloads (e.g., missions for RVs) to identify the functions\nrequired\nfor each mode at runtime.\nRVDebloater\nperforms dynamic profiling by instrumenting firmware functions,\nas well as the mode-switching function responsible for changing device modes and tracking mode transitions and function executions.\nSecond,\nRVDebloater\nuses a software-based enforcement technique that statically instruments indirect\ncontrol flow transfer instructions\n(e.g., indirect call sites and function return instruction) and the mode-switching function\nto redirect control flow, monitor function execution and mode transitions,\nand restrict access to functions belonging to other modes. Upon a mode switch,\nRVDebloater\nloads the required firmware functions for the new mode\nby applying per-mode configurations (goal 1), including\nrequired\nfunctions (goal 2) identified by either\nstatic\n(\nRVDebloater-static\n) or\ndynamic analysis\n(\nRVDebloater-dynamic\n).\nWe evaluated\nRVDebloater\nusing both techniques,\nand the results (§\n6.2\n) show that\nRVDebloater-dynamic\ncan debloat more functions, without introducing either\nfalse negatives\nor\nfalse positives\n(i.e., all allowed functions are used during the missions, and\nno mission fails due to a missing function).\nThis is because embedded devices typically require a fixed set of functions (functionalities) for each mode,\nwhich can be identified with just a few missions.\nIn contrast,\nRVDebloater-static\neliminates fewer unneeded firmware functions for each mode, while\nemploying a more careful and conservative debloating approach.\nThus, the choice between these two approaches involves a trade-off:\nstatic analysis\nprovides more cautious restrictions with lower protection,\nwhereas\ndynamic analysis\noffers higher protection but comes with a risk of potential false positives\n2\n2\n2\nHenceforth,\nRVDebloater\nrefers to both variants, unless the variant is explicitly mentioned.\n.\nTo the best of our knowledge, RVDebloater is the first fine-grained,\nadaptive debloating framework for mode-based embedded devices\nthat automatically identifies and specializes the firmware code\nat the function-level for each mode.\nOur main contributions are summarized as follows:\n•\nPropose two automated analysis techniques (static and dynamic) to identify the required firmware code\nat the function-level, considering the different operational requirements of RVs\nacross different execution modes.\n•\nPropose a runtime adaptive debloating\ntechnique that tracks mode switches and\na novel software-only enforcement technique to dynamically specialize the firmware code for each mode at runtime.\n•\nDesign\nRVDebloater\n, a fine-grained debloating framework to integrate the above techniques\nfor mode-based embedded devices such as RVs.\nRVDebloater\nis implemented using the LLVM compiler\n[\n54\n]\n,\nmaking it portable across different devices.\n•\nEvaluate\nRVDebloater\non four simulated and two real RVs, all running one of two widely used open-source autopilot\nsystems, ArduPilot or PX4, across a diverse range of scenarios and missions. We also evaluated it against three realistic code-reuse attacks on the RVs.\nThe results demonstrate that (1)\nRVDebloater-static\nreduces the attack surface by an average of 41% of the\nfirmware functions.\n(2)\nRVDebloater-dynamic\nidentifies all\nrequired\nfunctions for each mode\nby running RVs with only up to 10 missions, and achieves an average attack surface reduction of 85%.\n(3) The average performance overhead and power consumption overhead of\nRVDebloater\non real RVs are 3.9% and 0.47%, respectively.\nFurther, the overall mission time was not increased due to\nRVDebloater\n.\n(4) The firmware instrumented by\nRVDebloater\nincurred an average memory overhead of about 4%, which is about 0.25 MB, and\n(5)\nRVDebloater\nsuccessfully prevented all three attacks.\n2\nBackground\n2.1\nMemory Corruptions\nThe majority of embedded devices’ software, including firmware, is developed in low-level programming languages\n(i.e., C or C++) due to their efficiency and ability to provide full control over the underlying hardware.\nHowever, these languages are type-unsafe, requiring developers\nto carefully manage memory accesses and ensure their validity to prevent issues like dereferencing invalid pointers.\nThe lack of memory safety in these languages, combined with developers’ failure to meet these responsibilities,\nleads to memory corruption vulnerabilities (e.g., buffer overflow) that attackers can exploit\nto manipulate device behavior maliciously or even gain full control over\nthe system’s execution flow\n[\n53\n]\n(e.g., control flow hijacking attacks).\nControl flow hijacking attacks occur when a code pointer,\nsuch as a return address (backward edge) or a function pointer (forward edge),\non the backward edge (e.g., return addresses) or forward edge (e.g., function pointers)\nbecomes corrupted.\nBy hijacking the control flow, attackers can either execute malicious payloads injected\ninto the application stack (\ncode injection attacks\n) or reuse existing code sequences (gadgets)\nfrom the victim application (\ncode reuse attacks\n).\nSecurity mechanisms like Data Execution Prevention (DEP),\nwhich mark memory regions as either writable or executable (i.e.,\nW\n⊕\nX\nW\\oplus X\n), mitigate code injection attacks.\nHowever, code reuse attacks bypass these defenses by injecting addresses of existing instructions\ninto corrupted code pointers, altering the original control flow in an arbitrarily expressive way.\n2.2\nMode-based Embedded Devices\nEmbedded devices are widely used in mission-critical applications such as smart homes, industrial control systems, and autonomous vehicles.\nOne class of embedded devices are mode-based devices, which operate in different modes during their tasks (missions).\nFor instance, robotic vehicles (RVs) switch between different modes such as\nSTABILIZE\n,\nAUTO\n, and\nRTL\nwhile performing missions like delivering a package from point A to B.\nExamples of simple missions for the ArduPilot firmware are shown in Figure\n1(a)\nand Figure\n1(b)\nfor ArduPlane and ArduCopter, respectively.\nThese modes are predefined in RVs’ autopilot software such as ArduPilot\n[\n12\n]\nand PX4\n[\n41\n]\n.\nFurther, to manage their tasks, mode-based embedded devices often rely on real-time operating systems (RTOS) such as NuttX\n[\n5\n]\n.\nAll these software components—the autopilot software, RTOS, and other essential modules like device drivers—are integrated into the device’s firmware.\nAs an example, Figure\n2(a)\nand Figure\n2(b)\npresent mode switching\nin\nArduPlane\n[\n13\n]\nand\nArduCopter\n[\n6\n]\n, sub-platforms of the ArduPilot software.\nThe list of ArduPilot and PX4 modes is presented in Table\nVII\nin the Appendix.\n(a)\nArduPlane\n(b)\nArduCopter\nFigure 1\n:\nTwo mission examples for ArduPilot firmware.\n(a)\nMode switching process in ArduPlane.\n(b)\nMode switching process in ArduCopter.\nFigure 2\n:\nMode switching for ArduPlane and ArduCopter.\nMany embedded devices, including mode-based ones, often lack hardware security features, such as Memory Management Unit (MMU),\nwhich results in all applications being mapped into a single memory space\n[\n33\n]\n.\nTherefore, these applications have unrestricted access to the entire shared memory in the privileged mode,\nenabling attackers to exploit a single memory corruption vulnerability\nto manipulate the control flow of applications and take over the entire system.\nFurthermore, these devices may not support Memory Protection Units (MPUs)\n[\n48\n]\n.\nEven when an MPU is available, configuring and controlling memory access presents challenges\ndue to its limitations. Unlike the MMU,\nwhich enforces access restrictions through page tables and virtual memory,\nan MPU operates with a limited number of hardware registers,\ntypically supporting only 8 to 16 memory regions (e.g., 8 regions in ARMv7-M\n[\n18\n]\n).\nEach region is protected using read, write, and execute permissions,\nconfigurable for both privileged and unprivileged modes.\nAlso, MPU regions must be a power of two in size, with a minimum size of 32 bytes,\nand their starting addresses must be a multiple of their size. This severely restricts MPUs’ use.\n3\nMotivation\n3.1\nDebloating Techniques’ Limitations\nL1: Treating Applications as Monolithic Entities with Fixed Requirements.\nFixed techniques\nin attack surface reduction\n[\n43\n,\n25\n,\n2\n,\n33\n]\nspecialize or remove functionality based on the entire application’s lifetime requirements.\nHowever,\nadaptive debloating techniques\n[\n22\n,\n47\n]\nhave shown that considering the changing requirements during the application’s execution phases is more effective.\nIn particular, many devices and programs, such as mode-based embedded devices and server applications,\noperate in distinct modes, with their requirements changing based on the execution phase.\nL2: Removing Functionalities.\nFixed debloating techniques\n[\n29\n,\n30\n]\noften remove functionalities, such as hardware features or kernel source code,\nthat are not required at any point during the applications’ lifetime.\nOn the other hand, these techniques retain critical functionalities used for legitimate purposes during the application’s operation,\nwhile some of these functionalities are only executed for a short period of time.\nTherefore, to prevent over-debloating and potential system crashes, these techniques often overestimate the functionalities required.\nRetaining such functionalities would inflate the attack surface.\nL3: Using MPU.\nSome\nFixed debloating techniques\n[\n33\n,\n18\n]\nuse MPUs to control memory access.\nHowever, this hardware may not be available on all devices,\nparticularly embedded systems\n[\n48\n]\n. Moreover, due to MPU limitations (§\n2.2\n),\nthese methods must rely on clustering techniques to group code for multiple processes.\nThus, processes may gain access to unrequired code, thus leading to security risks.\nL4: Considering System Calls.\nExisting debloating techniques, both\nfixed\nand\nadaptive\n, only focus on system calls to reduce attack surfaces.\nHowever, other functionalities implemented as firmware functions, such as those in RV autopilot software,\nmay also pose security risks if accessible throughout the device’s execution lifetime.\nFor instance, Listing\n1\nand Listing\n2\nshow two security-critical functions\nin ArduPilot for the\nLand\nand\nTurtle\nmodes, respectively.\nThe purpose of the function shown in Listing\n1\nis to land the RV when it is in\nspecific states, such as upon reaching its destination.\nAlso, the function in Listing\n2\nis executed to disarm the motors if\nthe RV lands upside down, and enters the\nTurtle\nmode to flip the drone upright.\nHowever, executing\ndisarm_motors\nduring flight immediately kills the motors, causing a crash.\nThus, these functions should not be accessible in other modes,\nsuch as\nAUTO\nor\nGUIDED\n, as attackers could exploit vulnerabilities to execute these functions\nand manipulate the device’s behavior.\nL5: Irreversible Mechanism.\nAlthough\nadaptive debloating techniques\nlike SysPart\n[\n47\n]\nand TSCP\n[\n22\n]\nare more effective at reducing attack surfaces compared to\nfixed techniques\n,\nthey employ an irreversible mechanism to disable system calls after transitioning to the\nserving\nphase.\nSpecifically, these techniques leverage a Linux kernel feature called Seccomp-BPF, which is a one-way process,\nmeaning the filtered system calls cannot be re-enabled.\nAs a result, they are suitable for applications with simple control flow, such as\nserver programs\n,\nbut not for devices like\nmode-based embedded devices\nthat frequently switch between modes, and transition back to earlier modes (Figure\n2\n).\n⬇\n1\nvoid\nModeLand\n::\nrun\n()\n{\n2\nif\n(\ncontrol_position\n){\n3\ngps_run\n();\n4\n}\nelse\n{\n5\nnogps_run\n();\n6\n}\n7\n}\nListing 1:\nLanding function for ArduCopter’s Land mode.\n⬇\n1\nvoid\nModeTurtle\n::\ndisarm_motors\n(){\n2\n/\n/...\nomit\n3\nmotors\n->\narmed\n(\nfalse\n);\n/\n/\ndisarm\n4\n/\n/...\nomit\n5\nhal\n.\nutil\n->\nset_soft_armed\n(\nfalse\n);\n6\n}\nListing 2:\nArduCopter’s function executed in Turtle mode to disarm the vehicle motors if it lands upside down.\n3.2\nOur Approach: RVDebloater\nRVDebloater\nproposes two solutions (i.e., S1 and S2)\nto address the limitations of existing debloating techniques.\nS1: Addressing L1 and L4.\nWe propose an adaptive debloating technique that specializes firmware code\nbased on the device’s requirements during its mode of execution (L1).\nThis technique, detailed in §\n4.2\n,\nemploys either a static or dynamic analysis\nto identify the required firmware code for each mode at the function-level (L4).\nS2: Addressing L2, L3, and L5.\nWe use a software-based technique that does not rely on hardware features\nto enforce firmware debloating\nbased on the device’s current execution mode throughout its execution lifetime (L5).\nSpecifically,\nRVDebloater\nmonitors mode switches and controls memory access by instrumenting the firmware’s mode-switching functions\nand indirect control flow transfer instructions to restrict access to required firmware functions based on the device’s current mode (L2 and L3).\n3.3\nAssumptions and Threat Model\nAssumptions.\nWe make the following two assumptions.\nFirst, the list of autopilot software modes (e.g.,\nTAKEOFF\nand\nAUTO\n) and mode-switching functions responsible for changing modes at runtime are known to\nRVDebloater\nand provided as inputs to it.\nThis information can be found in the firmware’s source code or autopilot software’s documentation (e.g., ArduPilot documentation\n[\n13\n,\n6\n]\n).\nAlthough determining mode-switching function could be automated through dynamic analysis,\nwe did not invest the effort to develop this capability,\nas it only needs to be performed once per firmware model (e.g., ArduPlane).\nIn our experiments, it took us only a few minutes to identify this function in six different firmware models (e.g., ArduPlane and PXCopter).\nSecond, similar to prior debloating techniques\n[\n2\n,\n22\n,\n33\n]\n, we assume that\nRVDebloater\nhas access to the firmware’s source code.\nWith that said, since\nRVDebloater\noperates on the LLVM IR\n[\n54\n]\n, it can also work if the firmware is available in the LLVM Intermediate Representation (IR) format instead of source code.\nThreat Model.\nWe consider an adversary who is capable of performing remote attacks on the system without having root or physical access to it.\nFurthermore, we assume that the core system software is benign and developed by honest developers; however it may contain\nmemory corruption vulnerabilities (e.g., buffer overflows).\nAn adversary can exploit such memory corruption vulnerabilities,\nto hijack the firmware’s control flow and call unneeded critical firmware functions via code-reuse attacks.\nOur threat model is consistent with those of prior debloating techniques\n[\n2\n,\n33\n]\n.\n4\nDesign:\nRVDebloater\nThis section presents the system design of\nRVDebloater\n, the first adaptive debloating technique for\nmode-based embedded devices\n.\nWe start with an overview of\nRVDebloater\nand its key innovations (§\n4.1\n), before\ndescribing the different phases of the system in detail (§\n4.2\n, §\n4.3\nand §\n4.4\n).\n4.1\nOverview of RVDebloater\nFigure 3\n:\nOverview of\nRVDebloater\n’s operation, including both the offline phase (top) and runtime phase (bottom).\nFigure\n3\nshows\nRVDebloater\n’s workflow, which includes three main phases:\n(1) the analysis phase, (2) the guard insertion phase, and (3) the monitoring phase.\nOur approach aims to identify and dynamically specialize firmware code\n3\n3\n3\nMode-based embedded device firmware consists of code from various software modules, such as libraries and applications, compiled into a single executable file.\nrunning on mode-based embedded devices\nat the function-level granularity (i.e., firmware functions),\ndepending on the device’s execution mode.\nTo accomplish this goal, we propose two key innovations.\nThe first innovation is using either a static analysis\nor dynamic analysis\nto identify the firmware functions used in a specific mode (see S1 in §\n3.2\n).\nWe leverage this method in the\nanalysis\nphase.\nThe second main innovation of our technique is that,\nunlike previous debloating methods that rely on hardware components (MPU)\n[\n33\n]\n,\nvirtualization mechanisms (VMX)\n[\n2\n]\n, or irreversible mechanisms (Seccomp-BPF)\n[\n22\n,\n47\n]\n,\nour approach uses a completely\nsoftware-based enforcement technique\n(see S2 in §\n3.2\n).\nIn particular, our\nsoftware-based enforcement technique\nuses\nstatic analysis\nto instrument indirect control flow transfer instructions (e.g., indirect function\ncall or function return instruction) and redirect the control flow to the\nRVDebloater\nmonitor,\nwhich specializes firmware code for each mode using a mode-specific configuration file\nthat includes the required functions and their addresses generated in the previous phase (i.e.,\nanalysis\nphase).\nThis is achieved in two phases:\n(1) the\nguard insertion\nphase, which modifies the firmware code,\nand (2) the\nmonitoring\nphase, which tracks the device’s execution to check indirect control flow transfer instructions and specialize the firmware for each mode.\nAs shown in Figure\n3\n, the\nanalysis\nand\nguard insertion\nphase are both performed offline,\nwhile the\nmonitoring\nphase is performed online.\nAfter generating the mode-based configuration file (\nanalysis\nphase) and executing the instrumented firmware (\nguard insertion\nphase) on the device, the\nRVDebloater\nmonitor is triggered when an indirect control flow transfer instruction is executed (\nmonitoring\nphase).\nThe monitor checks whether the jump and execution of the target address are allowed based on the configuration file.\nIf the target is not present in the static output (\nRVDebloater-static\n) or\nin the dynamic output (\nRVDebloater-dynamic\n) (depending on which is used), the monitor can either\nactivate safety mechanisms such as\nFail-Safe\nmode\nor take other actions\nbased on the device maintainer’s preferences (e.g., mechanisms they have developed).\nFail-Safe\nmechanisms are commonly employed in various detection\nand recovery techniques\n[\n34\n,\n16\n,\n33\n,\n46\n]\nto safely control the vehicle by returning it to the launch point or\nperforming an emergency landing\nwhen an attack is detected or control is lost.\nArduPilot provides 11 well-defined fail-safe mechanisms\n[\n9\n]\n, and PX4 also includes a\nfail-safe landing\n[\n40\n]\n. Thus, we used fail-safe mechanisms in our evaluation.\nWe provide a detailed discussion of the process in the following sections (§\n4.2\n, §\n4.3\nand §\n4.4\n).\nNote that, for simplicity, the examples are presented in the C language,\neven though\nRVDebloater\noperates on LLVM IR.\nAn example of LLVM IR is provided in §\nB\n.\nFurther, to describe the examples,\nwe treat each line of C code (i.e., program statement) as a single instruction, even though,\nin practice, each of these would correspond to multiple LLVM instructions.\n4.2\nAnalysis Phase\nThe first phase of the\nRVDebloater\nprocess is the offline analysis phase,\nwhich automatically identifies the\nrequired functions\nfor each mode using either\nstatic\nor\ndynamic\nanalysis.\nSince static analysis tends to overestimate the required functions for each mode,\nwhile dynamic analysis tends to underestimate them,\nRVDebloater\nleverages\nboth techniques\n,\ngiving device maintainers the flexibility to choose the most appropriate option based on their level of risk-tolerance.\nSpecifically, the offline analysis phase consists of either: (1) executing the device with different missions to dynamically identify the functions\nused in each mode at runtime (\nRVDebloater-dynamic\n§\n4.2.1\n),\nOR (2) generating a pruned call graph of the firmware to statically identify an overestimated\nset of required functions for each mode (\nRVDebloater-static\n§\n4.2.2\n). Subsequently,\nRVDebloater-dynamic\nuses the dynamic output\nto enforce firmware specialization based on the device’s current mode,\nwhile\nRVDebloater-static\nuses the identified function lists for each mode from the static output.\nIn the following sections, we explain each step in the offline analysis phase.\n4.2.1\nRVDebloater-dynamic\n: Dynamic Analysis\nTo enforce debloating,\nRVDebloater\nleverages dynamic analysis to identify the required firmware functions\nfor each mode (\nRVDebloater-dynamic\n). To do so,\nRVDebloater\nemploys static instrumentation to generate a modified firmware version\nthat records (1) mode switches, and (2) the firmware functions executed in each mode at runtime.\nAfterwards,\nRVDebloater\nruns the instrumented firmware on the device with various missions\nto determine the executed (\nrequired\n) firmware functions for each mode. The following outlines each step of the dynamic analysis in detail.\n(1) Instrumentation.\nThis step inserts trampolines\n4\n4\n4\nA single instruction, like a jump or branch instruction, inserted into the program to redirect its original control flow.\ninto the mode-switching function(s)\n5\n5\n5\nAlthough\nRVDebloater\nsupports multiple mode-switching functions, in the tested firmware (e.g., ArduCopter, PXCopter), instrumenting a single mode-switching function was sufficient to monitor all mode changes.\nand firmware functions.\nRVDebloater\nprovides an instrumentation component that automates this process.\nThis component takes the firmware and mode-switching function(s) (§\n3.3\n) as input and\noutputs the instrumented firmware.\nSpecifically, the instrumentation component statically analyzes the firmware to locate the given mode-switching function(s)\nand other firmware functions,\nthen inserts the trampolines.\nTo ensure that the mode has changed successfully, the component inserts a trampoline at the end of mode-switching function(s).\nIf a mode switch fails, the firmware handles the error independently of\nRVDebloater\n.\n⬇\n1\nbool\nPlane\n::\nset_mode_by_number\n(\nconst\nMode\n::\nNumber\nnew_mode_number\n,\nconst\nModeReason\nreason\n){\n2\nMode\n*\nnew_mode\n=\nplane\n.\nmode_from_mode_num\n(\nnew_mode_number\n);\n3\nif\n(\nnew_mode\n==\nnullptr\n)\n{\n4\nnotify_no_such_mode\n(\nnew_mode_number\n);\n5\nreturn\nfalse\n;\n6\n}\n7\nTrampoline\n8\nreturn\nset_mode\n(*\nnew_mode\n,\nreason\n);\n}\nListing 3:\nOutput of the instrumentation step for the mode-switching function in ArduPlane (ArduPilot).\nListing\n3\nshows an example of the mode-switching function in ArduPlane.\nThis function first (line 2 in Listing\n3\n) retrieves the name of the new mode (e.g.,\nCIRCLE\nor\nRTL\n)\nby passing the input number (\nnew_mode_number\n).\nThen, it checks the returned mode name to validate whether the new mode exists (lines 3 to 6).\nFinally, it calls a function to switch the current mode to the new mode (line 8).\nAs seen in Listing\n3\n, the component has inserted a trampoline at the end of the function (line 7)\nafter the mode change has been successfully validated (lines 3 to 6).\nWhen the inserted trampoline is triggered at runtime, it passes the current and new mode to\nRVDebloater\n’s profiler,\nrecords the executed functions in the current mode, and changes the profiler’s mode to the new mode.\nFurther, the component inserts trampolines at the beginning of all firmware functions (except the mode-switching function) to ensure that every function executed in the current mode triggers\nRVDebloater\n’s profiler. Algorithm\n1\ndemonstrates the workflow of the instrumentation step.\nFor the mode-switching function, the component inserts a trampoline at the end (lines 2 to 6). For all other functions, it adds trampolines to the beginning (lines 7 to 11).\nAlgorithm 1\nInstrumentation Component for Profiling\ninputs:\nFirmware functions, mode-switching function set\nm\n​\no\n​\nd\n​\ne\n​\nF\n​\nu\n​\nn\n​\nc\n​\ns\nmodeFuncs\noutput:\nInstrumented firmware\n1\nfunction\nInstrumentationComponent\n(\nF\n​\nu\n​\nn\n​\nc\n​\nt\n​\ni\n​\no\n​\nn\n​\ns\nFunctions\n)\n2\nif\nF\n​\nu\n​\nn\n​\nc\n​\nt\n​\ni\n​\no\n​\nn\n∈\nm\n​\no\n​\nd\n​\ne\n​\nF\n​\nu\n​\nn\n​\nc\n​\ns\nFunction\\in modeFuncs\nthen\n3\nif\nE\n​\nn\n​\nd\nEnd\no\n​\nf\nof\nF\n​\nu\n​\nn\n​\nc\n​\nt\n​\ni\n​\no\n​\nn\nFunction\nthen\n4\nl\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\n←\nf\n​\ni\n​\nn\n​\nd\n​\nL\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\n​\n(\n)\nlocation\\leftarrow findLocation()\n5\ninsertTrampoline(\nl\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\nlocation\n)\n6\nend\nif\n7\nelse\n⊳\n\\triangleright\nOther firmware functions\n8\nif\nF\n​\nu\n​\nn\n​\nc\n​\nt\n​\ni\n​\no\n​\nn\nFunction\nE\n​\nn\n​\nt\n​\nr\n​\na\n​\nn\n​\nc\n​\ne\nEntrance\nthen\n9\nl\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\n←\nf\n​\ni\n​\nn\n​\nd\n​\nL\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\n​\n(\n)\nlocation\\leftarrow findLocation()\n10\ninsertTrampoline(\nl\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\nlocation\n)\n11\nend\nif\n12\nend\nif\n13\nreturn\ni\n​\nn\n​\ns\n​\nt\n​\nr\n​\nu\n​\nm\n​\ne\n​\nn\n​\nt\n​\ne\n​\nd\n​\nF\n​\ni\n​\nr\n​\nm\n​\nw\n​\na\n​\nr\n​\ne\ninstrumentedFirmware\n14\nend\nfunction\n(2) Dynamic Profiling.\nIn the next step,\nRVDebloater\nruns the device with the instrumented firmware (e.g., ArduPlane or ArduCopter) across different missions\nand scenarios (e.g., with and without obstacles) to identify the firmware functions for each mode at runtime\nby capturing functions with\nRVDebloater\n’s profiler.\nThe instrumented firmware ensures that each function for the current mode is logged at most once when the device switches to a new mode.\nWe assume that\nRVDebloater\nruns this step (dynamic profiling) in a benign environment, free from any security attacks.\n4.2.2\nRVDebloater-static\n: Static Analysis\nRVDebloater\nalso statically analyzes the firmware to construct its call graph.\nSince the firmware is written in C/C++, it often relies on indirect function calls via function pointers.\nStatically resolving the targets of these calls is both challenging and critical\nfor accurately identifying the functions required by each mode.\nTo address this,\nRVDebloater\nemploys Andersen’s points-to analysis\n[\n4\n]\n,\na static technique for resolving pointer targets in C/C++ programs.\nThis analysis can have different sensitivities depending on how objects in memory are modeled:\nfield sensitivity, path sensitivity, and context sensitivity.\nHigher levels of sensitivity yield more accurate results but also increase the analysis time\nand the implementation complexity.\nFor instance, field sensitivity distinguishes and models each field of a structured variable (e.g., a\nstruct\n) separately,\nwhile context sensitivity distinguishes between different call sites of a function,\nmeaning that when the same function is called from different places, each call gets\nits own context and is analyzed independently of the others.\nWhile a detailed discussion of these topics is beyond the scope of this paper,\nmore details about these sensitivities can be found in previous work\n[\n22\n,\n27\n]\n.\nSpecifically,\nRVDebloater\nleverages SVF\n[\n51\n]\n, which implements Andersen’s analysis with field sensitivity but without path or context sensitivity.\nAs a result, SVF tends to over-approximate the call graph,\nas it associates indirect function calls with a large number of potential targets—only a small subset of\nwhich is actually executed, while the rest are spurious.\nAlthough this over-approximation increases the number of functions identified per mode,\nintroducing unneeded functions that increase the attack surface and could be exploited by attackers to subvert the system,\nthe approach is sound in determining which functions are not required (unreachable) for each mode.\nHowever, to improve precision,\nRVDebloater\napplies two pruning heuristics,\ninspired by the TSCP technique\n[\n22\n]\n,\nto remove spurious targets caused by the lack of path and context sensitivity\nand generate a more accurate call graph.\nWe modified these heuristics to support embedded firmware and refine call graphs further.\nThe call graph is generated once per firmware model (e.g., ArduCopter),\nindependent of the number of modes.\nThe two heuristics are as follows.\n(1) Signature-based Pruning Heuristic.\nSVF resolves indirect call sites using a basic pruning heuristic that considers only the number of arguments.\nHowever, this approach does not effectively prune spurious targets,\nas it considers functions with the correct number of arguments but incorrect argument types\nas valid targets.\nTo improve precision, we additionally use two filtering methods.\nFirst,\nRVDebloater\nconsiders the\nargument types when resolving indirect call targets,\ndiscarding those that do not match.\nIn particular,\nRVDebloater\nanalyzes all indirect call sites and prunes call edges to functions whose argument types do not match the expected types at the call site.\nSecond,\nRVDebloater\nenhances call graph accuracy by also considering return types. Specifically, functions with a\nvoid\nreturn type are identified as spurious targets\nfor indirect call sites that expect a return value.\nIt effectively prunes spurious targets and reduces the number of call edges in the generated call graph.\n(2) Address-based Pruning Heuristic.\nTo further prune spurious targets,\nRVDebloater\napplies an additional heuristic (address-based pruning heuristic) based on “taken” addresses in the reachable path to the entry point.\nAndersen’s algorithm assumes that\nall functions in the program\nare reachable from the entry point.\nHowever, a function may not have its address stored in a variable or may be unreachable through the entry point,\nmaking it an invalid target for an indirect call site.\nThus,\nRVDebloater\nidentifies all functions whose addresses appear in paths reachable from the entry point.\nThen, it examines all indirect call sites and removes edges that point to functions that are not in this list—i.e.,\nfunctions whose addresses are not in any reachable path from the entry point.\nAfter refining the call graph,\nRVDebloater\nidentifies the entry functions of each mode to\ndetermine their reachable (required) functions.\nTo do so, it employs an instrumentation component similar to the one used in dynamic analysis (§\n4.2.1\n),\nwhich instruments both the firmware functions and the mode-switching function(s).\nRVDebloater\nthen executes the device through a mission that includes all modes intended for monitoring and control at runtime by\nRVDebloater-static\n.\nDuring execution, when the device switches modes,\nRVDebloater\ntracks the function(s) invoked by the mode-switching function to initialize the parameters\nrequired for the new mode and marks them as the entry function(s) of that mode.\nRVDebloater\nalso performs mode-name pattern matching to confirm the validity of the identified entry function(s). In particular, we observed that these firmware models (e.g., ArduCopter or ArduPlane) have entry function(s)\nresponsible for managing mode-specific parameters, and their names typically include the mode name itself.\nTherefore,\nRVDebloater\nuses the list of mode names provided as input (§\n3.3\n)\nto verify and confirm the correctness of these functions.\nWe found that all identified entry functions were correct.\nNote that this pattern can be adapted by developers to support other firmware.\nHowever, we used the same pattern in all the firmware models evaluated in this paper, as it was sufficient.\nFinally,\nRVDebloater\nuses the generated call graph to\nidentify the reachable and unreachable functions for each mode, starting from its entry function(s).\nBoth\ndynamic\nand\nstatic\nanalyses only need to be performed\nonce\nfor each firmware model\n(e.g., ArduPlane or ArduCopter) to identify and store the functions required for each mode at runtime.\nThese identified functions are then used during the runtime (device execution) monitoring phase to enforce debloating\nby checking whether they are permitted in the current mode of the device.\n4.3\nGuard Insertion Phase\nThe next phase of the\nRVDebloater\nprocess is the\nguard insertion\nphase, which is performed offline and only once per firmware.\nThe\nRVDebloater\nmonitoring\nphase is designed to: (1) track mode switches,\n(2) load the appropriate list of identified functions for the new mode when a mode switch occurs,\nand (3) monitor indirect control flow transfer instructions and ensure they are allowed; otherwise,\nRVDebloater\nlogs the violation and switches to\nFail-Safe\nmode.\nTo achieve these goals, the\nRVDebloater\nprocess has two main phases:\nguard insertion\nand\nmonitoring\n(§\n4.4\n).\nSimilar to the previous instrumentation step for offline analysis phase,\nRVDebloater\nprovides a component that automatically identifies mode-switching function(s) and inserts a trampoline at the end of each.\nHowever, in this instrumentation step,\nRVDebloater\nreplaces\nall\nindirect control flow transfer instructions in the firmware code\nwith calls to the\nRVDebloater\nmonitor. This allows\nRVDebloater\nto observe all function calls and returns, and verify them against the list of allowed functions identified in the previous phase.\nAlgorithm 2\nInstrumentation Component for Monitoring\ninputs:\nFirmware functions (\nI\n​\nn\n​\ns\n​\nt\n​\ns\n=\n(\ni\n​\nn\n​\ns\n​\nt\n1\n,\n…\n,\ni\n​\nn\n​\ns\n​\nt\nn\n)\nInsts=(inst_{1},\\dots,inst_{n})\n) and mode-switching function set (\nm\n​\no\n​\nd\n​\ne\n​\nF\n​\nu\n​\nn\n​\nc\n​\ns\nmodeFuncs\n)\noutput:\nInstrumented firmware\n1\nfunction\nInstrumentationComponent\n(\nF\n​\nu\n​\nn\n​\nc\n​\nt\n​\ni\n​\no\n​\nn\n​\ns\nFunctions\n)\n2\nif\nF\n​\nu\n​\nn\n​\nc\n​\nt\n​\ni\n​\no\n​\nn\n∈\nm\n​\no\n​\nd\n​\ne\n​\nF\n​\nu\n​\nn\n​\nc\n​\ns\nFunction\\in modeFuncs\nthen\n3\nif\nE\n​\nn\n​\nd\nEnd\no\n​\nf\nof\nF\n​\nu\n​\nn\n​\nc\n​\nt\n​\ni\n​\no\n​\nn\nFunction\nthen\n4\nl\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\n←\nf\n​\ni\n​\nn\n​\nd\n​\nL\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\n​\n(\n)\nlocation\\leftarrow findLocation()\n5\ninsertTrampoline(\nl\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\nlocation\n)\n6\nend\nif\n7\nelse\n8\nfor all\ni\n​\nn\n​\ns\n​\nt\n​\nr\n​\nu\n​\nc\n​\nt\n​\ni\n​\no\n​\nn\ninstruction\ni\n​\nn\n​\ns\n​\nt\ni\n∈\nI\n​\nn\n​\ns\n​\nt\n​\ns\ninst_{i}\\in Insts\ndo\n9\nif\ni\n​\nn\n​\ns\n​\nt\ni\n.\ntype\ninst_{i}.\\text{type}\nis indirect_control_flow_instruction\nthen\n10\nl\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\n←\nf\n​\ni\n​\nn\n​\nd\n​\nL\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\n​\n(\n)\nlocation\\leftarrow findLocation()\n11\nreplaceInst(\nl\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\nlocation\n)\n12\nelse\nif\ni\n​\nn\n​\ns\n​\nt\ni\n.\ntype\ninst_{i}.\\text{type}\nis return_instruction\nthen\n13\nl\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\n←\nf\n​\ni\n​\nn\n​\nd\n​\nL\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\n​\n(\n)\nlocation\\leftarrow findLocation()\n14\nreplaceInst(\nl\n​\no\n​\nc\n​\na\n​\nt\n​\ni\n​\no\n​\nn\nlocation\n)\n15\nelse\n16\ncontinue\n17\nend\nif\n18\nend\nfor\n19\nend\nif\n20\nreturn\ni\n​\nn\n​\ns\n​\nt\n​\nr\n​\nu\n​\nm\n​\ne\n​\nn\n​\nt\n​\ne\n​\nd\n​\nF\n​\ni\n​\nr\n​\nm\n​\nw\n​\na\n​\nr\n​\ne\ninstrumentedFirmware\n21\nend\nfunction\nThis component takes a list of mode-switching function(s) and the firmware code as input (§\n3.3\n), and outputs an instrumented firmware where trampolines are statically added to the mode-switching functions, and indirect control flow transfer instructions are replaced accordingly.\nAs noted in the offline analysis phase (§\n4.2.1\n), RVDebloater can instrument multiple mode-switching functions.\nHowever, in the tested firmware in this paper (i.e., ArduPilot, PX4), a single mode-switching function\nhandled all the mode changes.\nAlgorithm\n2\ndescribes the workflow of this instrumentation component for monitoring.\nSimilar to the prior instrumentation component (Algorithm\n1\n),\nthis component inserts trampolines at the end of mode-switching functions (lines 2 to 6).\nFor other firmware functions, it iterates over their instructions, and replaces each\nindirect control flow transfer instruction (e.g., indirect call site or return instruction)\nwith an instruction (i.e.,\ncall \"monitor_fn\"\n) that redirects the control to\nRVDebloater\n’s monitor (lines 7 to 18).\nRVDebloater\n’s monitor checks the call target\nbefore calling the intended target address directly.\nSection\n4.4\nprovides details.\n4.4\nMonitoring Phase\nThe final phase of the\nRVDebloater\nprocess is the\nmonitoring phase\n,\nwhich operates after the\nanalysis\nand\nguard insertion\nphases\nhave determined the required functions for each mode (either static or dynamic output)\nand instrumented the firmware.\nThe purpose of the monitoring phase is to\nmonitor\nthe device and\ndynamically debloat\n(specialize) the firmware functions for each mode\nbased on the identified lists at runtime, such as during RV missions.\nTo do so,\nRVDebloater\nuses the instrumented firmware from the previous phase (§\n4.3\n) and\nthe list of functions identified for each mode, which is generated during the analysis phase (§\n4.2.2\nor §\n4.2.1\n).\nThe procedure of monitoring call sites and returns is illustrated in Figure\n4\n.\nThe figure consists of five steps (labelled (1) to (5)) and four phases:\nthe process of switching modes in the RV, an access control table for each mode,\nan example of Mode A at runtime, and the\nRVDebloater\nmonitor component.\nOnce a mode switch occurs, the mode-switching function jumps to\nRVDebloater\n’s monitor (step (1)) to update the access control tables for the new mode (step (2)).\nFor example, as shown in Figure\n4\n(steps (1) and (2)), when the device mode changes from\nMode B\nto\nMode A\n, the access control table containing the required functions for\nMode A\nis loaded from the generated configuration file.\nFigure 4\n:\nRVDebloater\nRuntime System. Steps (1), (2) occur during a mode change to load the access control table, including functions required for the new mode.\nSteps (3)-(5) monitor and control indirect control flow transfer instructions based on the current mode’s access control table.\nAs mentioned,\nRVDebloater\nrewrites call instructions to redirect them to its monitor\n(step (3) in Figure\n4\n). When Function X calls Function Z, control is transferred to the\nRVDebloater\nmonitor,\nwhich checks whether the call is permitted using the loaded access control table\nfor the current mode (based on either the static or dynamic output).\nIf calling Function Z is permitted, the monitor saves the return address (e.g., the ”return point” in Function X, as shown in Figure\n4\n) and then invokes the function. Otherwise, if the function call is not authorized based on the static output for\nRVDebloater-static\nor the dynamic output for\nRVDebloater-dynamic\n,\nRVDebloater\ntriggers an alert and switches the device to\nFail-Safe\nmode, as the call is unauthorized according to the respective analysis.\nAfter finishing the execution of Function Z, the return instruction jumps back to the monitor (step (4) in Figure\n4\n),\nwhich verifies the stored return address.\nIf the address matches the expected return address, control flow returns to Function X (step (5) in Figure\n4\n).\nOtherwise, the monitor performs the same approach as for an unauthorized function call (i.e., switching to\nFail-Safe\nmode).\n5\nImplementation\nWe implemented\nRVDebloater\n’s analysis phase using two LLVM module passes,\nwhich can be executed on firmware containing different functions\n[\n56\n]\n.\nFurthermore, we developed two functions\nthat are linked to the firmware to support the instrumentation component and\nRVDebloater\n’s profiler.\nAs mentioned in §\n4.2\n, this phase takes the mode-switching function(s)\nand firmware code as input and generates an instrumented firmware\nalong with a list of required functions for each mode (configuration file).\nWe also utilized SVF\n[\n52\n]\nto generate the firmware’s call graph.\nHowever, we modified and added two LLVM passes to refine the generated call graph\n(i.e., signature-based and address-based pruning heuristics).\nFurther, the guard insertion phase is implemented as two LLVM module passes, and is executed on the firmware.\nThis generates an instrumented firmware that tracks mode changes\nand controls function execution based on the identified required functions.\nFinally, the runtime monitoring phase\nmonitors mode switching and indirect control flow transfer instructions to\ndynamically\nspecialize the firmware code for each mode according to the configuration file.\nThe implementation details are discussed in §\nA\nin the Appendix.\n6\nEvaluation\nThis section describes the evaluation of different aspects of\nRVDebloater\nincluding the effectiveness and efficiency\nof the system. Effectiveness is the ability of\nRVDebloater\nto specialize the firmware code for each mode at runtime and reduce the attack surface,\nwhile the efficiency is the runtime and memory overheads of\nRVDebloater\n.\n6.1\nExperimental Setup\nWe evaluated\nRVDebloater\non four simulated RV systems using either ArduPilot\n[\n12\n]\nor PX4\n[\n41\n]\n—two popular\nopen-source autopilot platforms—to test whether\nRVDebloater\ncan work across different platforms without modification:\n(1) ArduPilot’s quadcopter\n[\n7\n]\n(ArduCopter), (2) ArduPilot’s quadplane\n[\n10\n]\n(ArduPlane),\n(3) ArduPilot’s ground rover\n[\n11\n]\n(ArduRover), and (4) PX4’s quadcopter\n[\n38\n]\n(PXCopter).\nWe used Gazebo\n[\n21\n]\n, QGroundControl\n[\n42\n]\n,\nand APM SITL (Software-In-The-Loop)\n[\n12\n]\nplatforms for simulations.\nWe also used two real RVs, shown to the right:\n(Left)\nAion R1 ground rover (Aion rover)\n[\n3\n]\nand\n(Right)\nPixhawk based DIY drone (Pixhawk drone)\n[\n35\n]\n.\nBoth are commodity RV systems based on the Pixhawk\n[\n37\n]\n. Pixhawk is a platform built on an ARM Cortex architecture that integrates ArduPilot or PX4 firmware, a flight management unit (FMU),\nmemory, sensors, and I/O interfaces.\nTo generate the firmware call graph using the\nRVDebloater\n’s modified SVF,\nstatically extract the required (reachable) firmware functions for each mode (\nanalysis\nphase),\nand perform instrumentation during both the\nanalysis\nand\nguard insertion\nphases,\nwe used a desktop machine equipped with an Intel Xeon E-224 CPU (4 cores, 3.4 GHz)\nrunning Ubuntu 22.04 (64-bit). After identifying the required functions for each mode and generating the instrumented firmware,\nwe tested\nRVDebloater\nusing simulations\nand real devices.\nNote that the Aion rover and the Pixhawk drone use the same platforms as ArduRover in ArduPilot\nand PXCopter in PX4, respectively; therefore, the evaluation results for ArduRover\nand the Aion rover, and for PXCopter and the Pixhawk drone, are similar.\nThus, we do not report them separately, except when evaluating the efficiency in §\n6.3\n.\nRV Missions:\nTo evaluate the effectiveness of\nRVDebloater\n, we execute a diverse set of 40 missions (for each RV)\nwith varying durations and distances, randomly selected to cover a range of scenarios.\nEach mission consists of a navigation path that begins at a starting location, passes through several intermediate waypoints, and ends at a specific destination.\nThese missions emulate a range of real-world RV missions, including\nstraight-line paths for last-mile delivery drones\n[\n55\n]\n,\npolygonal paths for rovers in warehouse management\n[\n15\n]\n, and\nboth polygonal and circular paths for agriculture and surveillance\n[\n20\n]\n.\nThe types of missions used for each RV are summarized in Table\nI\n.\nDuring each mission, the RV switches between different modes,\nsuch as\nCIRCLE\nand\nLOITER\nfor ArduCopter and ArduRover, or\nQHOVER\nand\nQLOITER\nfor ArduPlane.\nThe main RVs’ modes are outlined in Table\nVII\nin the Appendix.\nAlthough our mission set includes other modes, this section presents the results for the main RV modes\nthat we observed are used in real-world missions (Tables\nIII\nand\nIV\n).\nTABLE I\n:\nMission sets for each RV firmware type used to evaluate\nRVDebloater\n. In the ”Missions” column,\nwe use SL: straight line, MW: multiple waypoints, HFE: hover at fixed elevation, CP: circular paths, PP: polygonal path.\nRV (Firmware) Type\nMissions\nTotal\nSL\nMW\nHFE\nPP\nCP\nArduCopter\n40\n10\n12\n5\n5\n8\nArduRover\n40\n12\n13\n-\n7\n8\nArduPlane\n40\n11\n13\n3\n3\n10\nPXCopter\n40\n10\n12\n5\n5\n8\nMetrics:\nWe used four metrics to evaluate\nRVDebloater\n, namely\n(1)\nprecision\nof the call graph, which refers to the reduction in the number of spurious call graph edges achieved\nby applying various pruning heuristics. This metric is\nsimilar to what prior work used\n[\n47\n,\n22\n]\n,\n(2)\nmissed functions\nare those that\nRVDebloater\n’s dynamic profiler fails to identify\nduring profiling missions using dynamic analysis.\n(3)\nfalse positive rate (FPR)\nis the percentage of mission failures\ncaused by the absence of required functions in the configuration file\n(either static or dynamic results) for the current mode,\ndespite the RV needing them.\n(4)\nfalse negative rate (FNR)\nis the percentage of functions that\nRVDebloater\nallows during missions, even though these functions are not required by the RV’s current mode.\n6.2\nEffectiveness\n6.2.1\nAnalysis Phase\nAs discussed in §\n4.2.2\nand §\nA.1\n,\nRVDebloater\nuses a modified version of SVF along with two pruning heuristics—signature-based and address-based—to generate\nand refine the firmware call graph, identifying the\nreachable\n(\nrequired\n) functions for each mode (\nRVDebloater-static\n).\nTo assess the effectiveness of these heuristics in reducing spurious edges in the call graph,\nwe evaluated them on ArduCopter, ArduPlane, ArduRover, and PXCopter.\nAs shown in Table\nII\n, the number of edges in the original call graph generated by SVF ranges from 104K\nto 193K. By applying our pruning heuristics,\nwe reduced the number of spurious edges in the call graph, achieving a precision of\napproximately 36% (66.8K),\n45% (67.1K), 48% (60.1K), and 49% (98.5K) for ArduCopter, ArduPlane, ArduRover and PXCopter, respectively.\nThus, our enhancement enables\nRVDebloater-static\nto more effectively restrict the functions accessible in each mode,\nensuring that it only identifies the functions actually required by each mode.\nTABLE II\n:\nPrecision after applying different heuristics. The third column shows the number of edges after applying the signature-based heuristic, and the fourth column shows the number after both heuristics.\nRV (Firmware) Type\nSVF\n+ Signature-based\n+ Addressed-based\nPrecision\nArduCopter\n104K\n87.4K\n66.8K\n36%\nArduRover\n115.3K\n80.3K\n60.1K\n48%\nArduPlane\n122K\n86.8K\n67.1K\n45%\nPXCopter\n193K\n130.2K\n98.5K\n49%\nThe complexity of the input (i.e., firmware) affects the duration of the above process. On our platform, generating the call graph for each RV type (firmware) took approximately 3 to 4 hours on average, based on 10 executions of the SVF.\nHowever, as mentioned earlier, this step is performed offline, and is done only once per firmware.\n6.2.2\nMonitoring Phase\nRVDebloater\nreduces the attack surface by restricting each mode’s access to only the\nrequired\nfirmware functions at runtime.\nIn the following, we evaluate the effectiveness of\nRVDebloater\n’s profiler in identifying the required firmware functions for each mode,\nand subsequently measure the resulting attack surface reduction achieved by\nRVDebloater\n.\nRVDebloater-dynamic\nProfiler.\nTo evaluate the\nRVDebloater\ndynamic analysis output,\nwe measured the number of missed functions across varying numbers of profiling and testing missions\non different RV types, and determined how many profiling missions are needed to identify\nall the\nrequired\nfunctions for each mode without missing any.\nTo do so, we used the RV missions discussed in §\n6.1\nto dynamically determine the\nrequired\nfirmware functions for each mode and RV.\nSpecifically, we first randomly chose two out of the 20 test missions as profiling missions for\ndynamic analysis\nfor each RV. We then used the remaining 18 missions to test the identified\nrequired\nfunctions for each mode at runtime.\nWe further evaluated the dynamic analysis output by gradually increasing the number of profiling missions, adding 2 missions each time to the profiling set from the testing set (e.g., 4 profiling and 16 testing missions), all the way to 20 missions.\nThe results are shown in Figure\n5\n.\nAs can be seen, all RVs converged to\nzero missed functions\nafter profiling within only 10 missions (i.e., 10 profiling and 10 testing missions).\nAlthough the\nRVDebloater\nprofiler identified all the required functions for each mode using 10\nprofiling missions, we continued the dynamic analysis evaluation by incrementally adding two new missions\nat a time to the profiling mission set\nand testing on the remaining missions (e.g., 12 profiling and 8 testing missions)\nto ensure that no missed functions appeared after convergence.\nThe results confirmed that the number of missed functions for each RV remained at zero.\nFigure 5\n:\nNumber of missed functions across different missions for various platforms (i.e., ArduPlane, ArduCopter, ArduRover, and PXCopter) during dynamic analysis with\nRVDebloater\n. All platforms converge to 0 missed functions after 10 missions.\nTo further confirm this result, we evaluated the\nRVDebloater\nprofiler on a totally different\nset of 20 different missions. The results, shown in Figure\n5\n(20 missions),\ndemonstrate that\nRVDebloater\n’s dynamic profiler\ndid not miss any required functions. Therefore, all\nrequired\nfunctions\nfor each mode can be identified within 10 missions.\nAlthough the number of profiling missions used to identify all required functions for each mode at runtime is small,\nthe\nRVDebloater\nprofiler may still miss some functions and produce false positives.\nTo address this,\nRVDebloater-static\ncan be used,\nwhich also includes the missing functions.\nHowever, the device maintainer may choose to rely on the dynamic analysis results (\nRVDebloater-dynamic\n)\nto achieve greater specialization compared to\nRVDebloater-static\n, which uses static analysis technique (§\n4.2\nand §\n4.4\n).\nDetailed results are provided below.\nAttack Surface Reduction.\nTo evaluate the attack surface reduction, we used\nRVDebloater\n’s dynamic and static analysis\nto identify the required firmware functions for each mode.\nAs we observed, after profiling 10 missions, the dynamic analysis converged to zero missing functions,\nand the number of functions remained unchanged with additional profiling.\nHence, Tables\nIII\nand\nIV\n(\nDynamic Analysis\nrow) shows the number of firmware functions required at runtime for each mode,\nas identified by\nRVDebloater\n’s profiler with 10 missions.\nFurthermore, the\nStatic Analysis\nrow in Tables\nIII\nand\nIV\npresents the number\nof\nreachable\nfunctions for each mode, as determined by static analysis on the generated call graph.\nAs discussed earlier (§\n4.2\nand §\n4.4\n),\nRVDebloater-static\nand\nRVDebloater-dynamic\nuse the outputs of static and dynamic analysis, respectively, to specialize the firmware code.\nTABLE III\n:\nSummary of firmware functions reduction (i.e., attack surface reduction through debloating) across different modes in ArduCopter, ArduPlane, and ArduRover (sub-platforms of ArduPilot). Reduction represents the percentage decrease in the number of firmware functions accessible to each mode when using\nRVDebloater\nwith dynamic (\nRVDebloater-dynamic\n) or static analysis (\nRVDebloater-static\n), compared to the baseline firmware where all functions remain accessible.\nTechnique\nRV Type (modes)\nArduCopter\nArduPlane\nArduRover\nAUTO\nCIRCLE\nSTABILIZE\nGUIDED\nRTL\nLOITER\nMANUAL\nAUTO\nCIRCLE\nGUIDED\nQLOITER\nRTL\nQHOVER\nAUTO\nCIRCLE\nMANUAL\nRTL\nGUIDED\nLOITER\nDynamic Analysis\n2869\n3106\n7054\n3271\n3153\n2757\n6891\n2823\n2756\n2692\n3120\n2692\n2700\n2513\n2435\n6246\n2433\n2647\n2255\nStatic Analysis\n13520\n13450\n13447\n13469\n13470\n13452\n13235\n13253\n13232\n13238\n13252\n13239\n13238\n12637\n12558\n12549\n12566\n12583\n12550\nw/o\nRVDebloater\n22653\n22653\n22653\n22653\n22653\n22653\n22514\n22514\n22514\n22514\n22514\n22514\n22514\n20990\n20990\n20990\n20990\n20990\n20990\nReduction:\nRVDebloater-dynamic\nRVDebloater-static\n87.33%\n40.31%\n86.28%\n40.62%\n68.86%\n40.64%\n85.56%\n40.54%\n86.08%\n40.53%\n87.83%\n40.61%\n69.39%\n41.21%\n87.46%\n41.13%\n88.75%\n41.22%\n88.04%\n41.20%\n86.14%\n41.14%\n88.04%\n41.19%\n88%\n41.20%\n88.02%\n39.80%\n88.40%\n40.17%\n70.24%\n40.21%\n88.40%\n40.13%\n87.39%\n40.05%\n89.26%\n40.20%\nTABLE IV\n:\nSummary of firmware functions reduction in PXCopter across different modes (continuation of Table\nIII\n).\nTechnique\nTAKEOFF\nMISSION\nLOITER\nRTL\nDynamic Analysis\n4320\n2765\n2660\n2853\nStatic Analysis\n12244\n12238\n12208\n12227\nw/o\nRVDebloater\n20805\n20805\n20805\n20805\nReduction:\nRVDebloater-dynamic\nRVDebloater-static\n79.23%\n41.15%\n86.71%\n41.18%\n87.21%\n41.32%\n86.29%\n41.23%\nThe results reveal that, on average, 85% and 41% of firmware functions are not required according to dynamic and static analysis, respectively.\nIn particular, when\nRVDebloater\nuses static analysis outputs,\nit reduces the firmware functions by an average of 41% (Reduction\nRVDebloater-static\nin Tables\nIII\nand\nIV\n),\nwhile achieving a 0%\nFPR\nand an average\nFNR\nof 44%, as this technique tends to overestimate the functions required for each mode (§\n4.2\n).\nAttempts to access debloated functions\nlead to activating\nFail-Safe\nmode, and raise an alarm\nto the device maintainer\n(§\n4.4\n).\nOn the other hand, when the device maintainer uses\nRVDebloater-dynamic\n,\nwhich uses dynamic analysis—generated by profiling\n10 missions—no missions fail, resulting in a 0%\nFPR\nand an 85% reduction\nin the attack surface (Reduction\nRVDebloater-dynamic\nin Tables\nIII\nand\nIV\n).\nConsequently, any attempt to access the debloated functions triggers a switch of the RV\nto\nFail-Safe\nmode, thereby restricting the attacker’s access to only 15% of the firmware’s functions with\nRVDebloater-dynamic\n. Furthermore, all functions allowed by\nRVDebloater-dynamic\nare actually required during execution\n(identified by profiling different missions), resulting in a 0%\nFNR\n.\nFrom the results (Table\nIII\nand\nIV\n), we can infer two main trends.\nFirst, each mode requires only a subset of the firmware functions rather than the entire firmware.\nFor instance, when the RV is in\nAUTO\nmode, it requires approximately 2800\nfirmware functions, whereas in\nRTL\nmode,\nit requires a different set of around 3000 firmware functions (addressing L1, L2, and L4 in §\n3.1\n).\nSecond, because RVs switch between different modes, including returning to earlier modes,\nthey need an adaptive debloating technique that is reversible, in contrast to previous\ndebloating techniques\n[\n22\n,\n47\n]\nthat use irreversible mechanisms to disable unwanted features (addressing L5 in §\n3.1\n).\nAttack Evaluation.\nAccording to the list of most dangerous software weaknesses from CWE\n[\n1\n]\n, out-of-bounds write is one\nof the most prevalent vulnerabilities.\nThus, to evaluate\nRVDebloater\n’s effectiveness (\nRVDebloater-dynamic\n,\nRVDebloater-static\n) in restricting firmware access,\nwe injected a buffer-overflow vulnerability—inspired by real-world vulnerabilities\n[\n50\n,\n19\n]\n—into\na function that processes user input, following prior work\n[\n34\n,\n33\n]\n.\nAn attacker who exploits this vulnerability can\nhijack control flow and perform a code-reuse attack.\nIn our evaluation, we exploited this vulnerability to hijack the control flow and then\nexecuted three sensitive firmware functionalities, such as\ndisarm_motors\n(§\n3.1\n), while the device was not in the\ncorrect mode. We discuss the three attacks in detail.\n(A1) Disarming RVs.\nArduCopter provides\na safety-critical function,\ndisarm_motors\n(Listing\n2\n), which disarms the\nmotors during benign tasks such as flipping the device upright in\nTurtle\nmode (§\n3.1\n).\nHowever, after hijacking the control flow,\nour attack reused the\ndisarm_motors\nfunction during a mission\n(e.g., while the device is in\nGUIDED\nmode), causing the device to crash.\nThe attack succeeded because the firmware allowed unrestricted access to any function,\nincluding\ndisarm_motors\n, regardless of the current mode.\nIn contrast,\nRVDebloater\ndetected the attack and switched the device mode to\nFail-Safe\n,\nallowing the device to land safely or return to the launch point (§\n4.1\n),\nbecause\ndisarm_motors\nis restricted and not\naccessible from other modes, such as\nGUIDED\n.\nThe\ndisarming\nfunctionality also exists in other platforms, such as ArduPlane and ArduRover,\nand is used during specific events like parachute release or crash detection.\nAn attacker can perform the same attack to disarm the motors and cause physical damage.\nAgain,\nRVDebloater\ndetected such attacks because disarming should not be allowed in modes such as\nQHOVER\n.\n(A2) Stopping Motors.\nArduCopter and ArduPlane provide a function called\noutput_min\n,\nwhich stops all motors and cuts engine power when specific events occur, such as when the device has landed.\nSimilar to the previous attack, our stopping motors attack hijacks the control flow of the victim device (firmware)\nand calls\noutput_min\nto stop the motors at an incorrect time (e.g., during mission while the device is in\nGUIDED\n),\ncausing the device to crash. In our experiments, we confirmed that an attacker can easily disrupt a mission\nand damage the device by invoking this function. This attack was also detected and prevented by\nRVDebloater\n,\nsince\noutput_min\nis not reachable from modes such as\nGUIDED\nor\nQHOVER\n.\n(A3) Disarming Aion Rover.\nThis attack case demonstrates the effectiveness of\nRVDebloater\non a real-world device, the Aion Rover, discussed in §\n6.1\n.\nSimilar to the previous attack cases, a buffer overflow vulnerability is intentionally inserted into the\nfunction that processes user input, inspired by previous work\n[\n34\n]\n. During the mission, this vulnerability is triggered,\nallowing the attacker to hijack the control flow and invoke a safety-critical function,\ndisarm\n,\nfrom an incorrect mode (i.e.,\nMANUAL\n).\nAs a result, the motors are disarmed, and the rover stops abruptly, which may cause collisions with other nearby rovers.\nHowever,\nRVDebloater\nsuccessfully detected this attack because the\ndisarm\nfunction is not included in the list of required functions for modes such as\nMANUAL\n.\nFigure\n6\nshows the setup for this attack on the Aion Rover in our lab.\n(a)\nBoot Firmware\n(b)\nRuntime\nFigure 6\n:\nReal-world attack (A3) on Aion Rover.\n6.3\nEfficiency\n6.3.1\nPerformance and Power Overhead\nAs discussed in §\n4.1\n, the only component of\nRVDebloater\nthat incurs overhead on the RV is the monitoring component,\nwhich monitors mode-switching function and checks indirect control flow transfer instructions to specialize the firmware code for each mode.\nTherefore, since both\nRVDebloater-static\nand\nRVDebloater-dynamic\nuse this component, their results are similar.\nTo evaluate the performance overhead, we used the real RVs mentioned in §\n5\n,\ni.e., the Aion rover and Pixhawk drone, as performance overheads in simulated RVs are dependent on the computing platform used for simulation. We used the scheduler in the RV autopilot platforms (ArduPilot and PX4)\nto track total CPU time and measured\nRVDebloater\n’s overhead by analyzing the additional CPU time\nincurred when\nRVDebloater\nwas deployed on the RV.\nWe found that\nRVDebloater\nincurs modest performance overheads of 3.5% on the Aion rover\nand 4.3% on the Pixhawk drone, with an average of 3.9%.\nWe also found that there was\nno increase\nin the overall mission time of the RVs with\nRVDebloater\nfor the missions discussed in §\n6.1\n.\nFurthermore, we estimated the power consumption of\nRVDebloater\nrunning on those RVs,\nwhich are powered by a 5000 mAH battery.\nSince the processor typically accounts for 12% of the total power consumption\n[\n36\n]\nand\nRVDebloater\nadds an average overhead of 3.9%, we estimate that the RV’s total power and energy consumption increases by approximately 0.47%, which is negligible.\n6.3.2\nMemory Overhead\nTo measure\nRVDebloater\n’s memory overhead, only the configuration files generated during the\nanalysis\nphase\nand the instrumented firmware produced during the\nguard insertion\nphase are stored on the device.\nThus, we focus on the overhead introduced by\nthese two phases, as they are the only ones that incur overhead to memory usage on the device.\nAs discussed in §\nA.2\nand §\nA.3\n,\nRVDebloater\nbuilds the firmware using the LLVM compiler toolchain (i.e., gclang, gclang++, and clang).\nThis process involves extracting the bitcode from the original executable firmware file\nand then generating a new executable file from the instrumented bitcode for deployment on the device.\nTABLE V\n:\nFirmware size with and without using\nRVDebloater\nguard insertion phase.\nTechnique\nRV Type\nArduCopter\nArduPlane\nArduRover\nPXCopter\nw/o\nRVDebloater\n6.2 MB\n6.1 MB\n5.7 MB\n6.2 MB\nRVDebloater\n6.5 MB\n6.4 MB\n5.9 MB\n6.4 MB\nOverhead\n0.3 MB (4.8%)\n0.3 MB (4.9%)\n0.2 MB (3.5%)\n0.2 MB (3.2%)\nWe find that the instrumented firmware introduces an average memory overhead of 0.25 MB\nacross different platform types,\ncorresponding to approximately a 4% increase over the original firmware.\nA summary of firmware sizes is presented in Table\nV\n.\nFurther, the mode-based configuration files generated by\nRVDebloater-static\nand\nRVDebloater-dynamic\n(§\n4.2\n) incur\nan average memory overhead of 0.65 MB and 0.17 MB, respectively.\nThese files are not included in the firmware and thus do not contribute to the 4% size increase.\nOverall, the total memory overhead (i.e., instrumented firmware+configuration files) is negligible (\n<\n<\n4%), as the memory available on the real RVs is over 20 MB.\nNote that, like other debloating (specialization) techniques\n[\n2\n,\n22\n,\n33\n]\nthat retain the firmware code while restricting access,\nRVDebloater\nalso does not reduce the memory usage.\nAs discussed earlier, mode-based embedded devices require the entire firmware,\nbut only the functions relevant to the current mode should be accessible in it.\n7\nRelated Work\nFixed debloating techniques\nfall into two types based on whether they\nretain\nor\nremove\nunneeded features, such as security-critical system calls or hardware features.\n1. Retaining Features.\nAbubakar et al.\n[\n2\n]\nproposed SHARD, which leverages context-aware hardening to specialize\nthe Linux kernel at the application and system call levels.\nSHARD uses both static and dynamic analysis to identify the required kernel code\nfor executing the system call invoked by an application.\nAfterwards, at runtime, SHARD ensures that only the identified kernel code is allowed to execute\nwhen the application calls the same system call.\nHowever, SHARD switches all kernel code pages for each system call invocation,\nmaking it unsuitable for resource-constrained embedded devices like RVs.\nMinion\n[\n33\n]\nproposed a thread-level memory isolation technique for real-time microcontroller systems (MCS)\nthat isolates the memory space for each process through offline static analysis of firmware\nand runtime memory access control using the Memory Protection Unit (MPU).\nHowever, Minion remains vulnerable to control flow hijacking attacks,\nas attackers can exploit memory corruption vulnerabilities in the shared memory between processes\nto hijack control flow and construct ROP or JOP chains.\nFurther, since Minion uses the MPU to enforce memory isolation,\nit applies clustering techniques to group functions.\nHowever, this may allow processes to access functions that they do not require (§\n3.1\n).\nGu et al. proposed FACE-CHANGE\n[\n24\n]\n, a kernel debloating technique that employs dynamic analysis\nto generate kernel profiles for each application, identifying the required kernel code at the application level.\nHowever, FACE-CHANGE’s reliance on runtime profiling leads to incomplete identification of required kernel code\n(i.e., customized kernel view), limiting its analysis to the subset of the program executed during profiling.\nFurthermore, FACE-CHANGE suffers from coarse specialization granularity (i.e., single kernel view for the entire application),\nand hence attackers can still hijack the control flow of the sensitive programs (e.g., flight control program in RVs)\nand manipulate the devices’ behavior.\n2. Removing Features.\nHu et al. proposed IRQDebloat\n[\n29\n]\n, a debloating technique that leverages dynamic analysis to identify interrupt handlers\nand disable undesired hardware functionalities by rewriting their handlers with a no-op function in the target firmware.\nHu et al. proposed Hacksaw\n[\n30\n]\n, a kernel specialization technique\nthat uses a list of hardware components attached to the target machine, called the device inventory,\nto remove kernel device drivers related to unnecessary hardware components.\nWu et al. proposed LightBlue\n[\n57\n]\n, a profile-aware debloating technique that uses static analysis\nto identify the Bluetooth profiles (e.g., Advanced Audio Distribution Profile (A2DP))\nutilized by an application (e.g., an Android app). Then, it removes unused code from the Bluetooth stack,\nincluding Bluetooth host code and firmware, thereby reducing the attack surface.\nHowever, LightBlue is limited to debloating of Bluetooth stacks and does not consider other critical features,\nsuch as firmware functionalities (e.g.,\ndisarm_motors\nin RV autopilot software).\nJahanshahi et al. proposed Minimalist\n[\n32\n]\n, a semi-automated debloating technique\nfor PHP web applications (e.g., WordPress and PhpMyAdmin) that uses static analysis\nto generate a call graph for these applications.\nMinimalist then removes unreachable and unused code\nbased on the generated call graph and recorded access-log files,\nwhich include users’ interactions with the web applications.\nHowever, Minimalist has two limitations as follows.\nFirst, users need to interact with the web server for each application to generate the access-log files,\nwhich is both time-consuming and potentially incomplete.\nSecond, since Minimalist relies on user requests, it may remove essential parts of the code\nthat are not captured in the log files, potentially causing system crashes.\nAll of these debloating techniques, which\nremove unwanted features\nsuch as hardware functionalities\nor kernel code, are irreversible, meaning that once unneeded features are removed,\nthey cannot be restored.\nHowever, embedded devices may require different functionalities during various phases of execution.\nTherefore, these techniques are only suitable\nwhen certain features are guaranteed to remain unused during runtime; hence, our work is orthogonal\nto this line of work, complementing these techniques.\nAdaptive Debloating Techniques\nAs mentioned in §\n1\n,\nfixed debloating techniques\ndo not consider changes in application requirements\nat runtime, and as a result, they cannot disable critical features, such as the\nfork\nand\nexecve\nsystem calls,\nwhich are necessary during the initial stages of an application.\nTo address this issue, Ghavamnia et al.\n[\n22\n]\nand Rajagopalan et al.\n[\n47\n]\nproposed adaptive system call specialization techniques for server applications,\nwhich are discussed in detail,in Sections §\n1\nand §\n3.1\n.\nUnlike existing adaptive debloating techniques that rely on irreversible mechanisms\nto disable system calls,\nRVDebloater\ndynamically specializes firmware code\nat runtime for each mode. This is particularly important for mode-based embedded devices,\nsuch as RVs, where firmware functions may need to be re-enabled depending\non the active mode (§\n6.2.2\n). Further, while prior techniques focus solely on system\ncall disabling,\nRVDebloater\nprovides function-level specialization of firmware.\n8\nConclusion and Future Work\nWe propose\nRVDebloater\n,the first adaptive debloating framework for\nmode-based\nembedded devices.\nRVDebloater\naddresses limitations of existing debloating techniques by using static or dynamic analysis\nto\nautomatically\nidentify the\nrequired\nfirmware functions for each mode and\nreduce the attack surface by restricting access to unneeded functions at runtime.\nFurthermore,\nRVDebloater\nuses a software-only technique to track mode-switches and specialize the firmware code at runtime.\nRVDebloater\nis implemented using the LLVM compiler, making it portable across platforms.\nWe evaluated\nRVDebloater\nusing real missions with various scenarios on six different RVs running\neither ArduPilot or PX4,\ntwo of the most widely used RV firmware.\nThe results reveal that\nRVDebloater\ncan reduce the RVs’ attack surface by an average of 41% with static analysis and 85% with dynamic analysis.\nFurthermore,\nRVDebloater\nincurred a performance overhead of 3.9%, and negligible power and memory overheads on those RVs (\n<\n<\n4%).\nFinally,\nRVDebloater\nsuccessfully mitigated three attacks on the RVs.\nWe outline one possible direction to be explored in future studies.\nAlthough we evaluated\nRVDebloater\nusing either static or dynamic analysis,\nthese techniques can be combined as a hybrid approach.\nRVDebloater-hybrid\ncan first check using the dynamic output; if the target is not found,\nit then checks the static output. Since static analysis tends to overestimate,\ncontrol flow integrity (CFI) techniques can then be applied using the generated call graph\nto ensure that all control flow transfers adhere to the CFG.\nReferences\n[1]\n(Last Accessed, Oct 2025)\n2024 cwe top 25 most dangerous software weaknesses\n.\nNote:\nhttps://cwe.mitre.org/top25/archive/2024/2024_cwe_top25.html\nCited by:\n§6.2.2\n.\n[2]\nM. Abubakar, A. Ahmad, P. Fonseca, and D. Xu\n(2021)\n{\n\\{\nshard\n}\n\\}\n:\n{\n\\{\nfine-Grained\n}\n\\}\nkernel specialization with\n{\n\\{\ncontext-aware\n}\n\\}\nhardening\n.\nIn\n30th USENIX Security Symposium (USENIX Security 21)\n,\npp. 2435–2452\n.\nCited by:\n§1\n,\n§1\n,\n§1\n,\n§3.1\n,\n§3.3\n,\n§3.3\n,\n§4.1\n,\n§6.3.2\n,\n§7\n.\n[3]\n(Last Accessed, Aug 2025)\nAion robotics\n.\nNote:\nhttps://www.aionrobotics.com/\nCited by:\n§6.1\n.\n[4]\nL. O. Andersen\n(1994)\nProgram analysis and specialization for the c programming language\n.\nCited by:\n§1\n,\n§4.2.2\n.\n[5]\n(Last Accessed, Aug 2025)\nApache nuttx\n.\nNote:\nhttps://nuttx.apache.org/\nCited by:\n§2.2\n.\n[6]\n(Last Accessed, Aug 2025)\nArduCopter flight modes\n.\nNote:\nhttps://ardupilot.org/copter/docs/flight-modes.html\nCited by:\n§2.2\n,\n§3.3\n.\n[7]\n(Last Accessed, Aug 2025)\nArdupilot copter\n.\nNote:\nhttps://ardupilot.org/copter/index.html\nCited by:\n§6.1\n.\n[8]\n(Last Accessed, Aug 2025)\nArduPilot documentation\n.\nNote:\nhttps://ardupilot.org/ardupilot/index.html\nCited by:\nTABLE VII\n,\nTABLE VII\n,\nAppendix C\n.\n[9]\n(Last Accessed, Oct 2025)\nArduPilot fail-safe\n.\nNote:\nhttps://ardupilot.org/copter/docs/failsafe-landing-page.html\nCited by:\n§4.1\n.\n[10]\n(Last Accessed, Aug 2025)\nArdupilot plane\n.\nNote:\nhttps://ardupilot.org/plane/index.html\nCited by:\n§6.1\n.\n[11]\n(Last Accessed, Aug 2025)\nArdupilot rover\n.\nNote:\nhttps://ardupilot.org/rover/index.html\nCited by:\n§6.1\n.\n[12]\n(Last Accessed, Aug 2025)\nArdupilot software in the loop\n.\nNote:\nhttps://ardupilot.org/dev/docs/sitl-simulator-software-in-the-loop.html\nCited by:\n§1\n,\n§2.2\n,\n§6.1\n.\n[13]\n(Last Accessed, Aug 2025)\nArduPlane flight modes\n.\nNote:\nhttps://ardupilot.org/plane/docs/flight-modes.html\nCited by:\n§2.2\n,\n§3.3\n.\n[14]\nB. A. Azad, P. Laperdrix, and N. Nikiforakis\n(2019)\nLess is more: quantifying the security benefits of debloating web applications\n.\nIn\n28th USENIX Security Symposium (USENIX Security 19)\n,\npp. 1697–1714\n.\nCited by:\n§1\n.\n[15]\n(Last Accessed, Aug 2025)\nBot-in-time delivery\n.\nNote:\nhttps://www.forbes.com/forbes/2009/0316/040_bot_time_saves_nine.html\nCited by:\n§6.1\n.\n[16]\nH. Choi, W. Lee, Y. Aafer, F. Fei, Z. Tu, X. Zhang, D. Xu, and X. Deng\n(2018)\nDetecting attacks against robotic vehicles: a control invariant approach\n.\nIn\nProceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security\n,\npp. 801–816\n.\nCited by:\n§4.1\n.\n[17]\n(Last Accessed, Aug 2025)\nClang: a c language family frontend for llvm\n.\nNote:\nhttps://clang.llvm.org/index.html\nCited by:\n§A.3\n.\n[18]\nA. A. Clements, N. S. Almakhdhub, S. Bagchi, and M. Payer\n(2018)\n{\n\\{\naces\n}\n\\}\n: Automatic compartments for embedded systems\n.\nIn\n27th USENIX Security Symposium (USENIX Security 18)\n,\npp. 65–82\n.\nCited by:\n§2.2\n,\n§3.1\n.\n[19]\n(Last Accessed, Oct 2025)\nCVE-2022-28711\n.\nNote:\nhttps://nvd.nist.gov/vuln/detail/CVE-2022-28711\nCited by:\n§6.2.2\n.\n[20]\n(Last Accessed, Aug 2025)\nDJI agras t50\n.\nNote:\nhttps://ag.dji.com\nCited by:\n§6.1\n.\n[21]\n(Last Accessed, Aug 2025)\nGazebo robot simulation\n.\nNote:\nhttps://gazebosim.org/home\nCited by:\n§6.1\n.\n[22]\nS. Ghavamnia, T. Palit, S. Mishra, and M. Polychronakis\n(2020)\nTemporal system call specialization for attack surface reduction\n.\nIn\n29th USENIX Security Symposium (USENIX Security 20)\n,\npp. 1749–1766\n.\nCited by:\n§A.1\n,\n§1\n,\n§1\n,\n§1\n,\n§1\n,\n§1\n,\n§3.1\n,\n§3.1\n,\n§3.3\n,\n§4.1\n,\n§4.2.2\n,\n§4.2.2\n,\n§6.1\n,\n§6.2.2\n,\n§6.3.2\n,\n§7\n.\n[23]\n(Last Accessed, Aug 2025)\nGLLVM\n.\nNote:\nhttps://github.com/SRI-CSL/gllvm\nCited by:\n§A.1\n.\n[24]\nZ. Gu, B. Saltaformaggio, X. Zhang, and D. Xu\n(2014)\nFace-change: application-driven dynamic kernel view switching in a virtual machine\n.\nIn\n2014 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks\n,\npp. 491–502\n.\nCited by:\n§1\n,\n§1\n,\n§7\n.\n[25]\nK. Heo, W. Lee, P. Pashakhanloo, and M. Naik\n(2018)\nEffective program debloating via reinforcement learning\n.\nIn\nProceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security\n,\npp. 380–394\n.\nCited by:\n§1\n,\n§3.1\n.\n[26]\n(Last Accessed, Aug 2025)\nHijacking drones with a mavlink exploit\n.\nNote:\nhttps://diydrones.com/profiles/blogs/hijacking-quadcopters-with-a-mavlink-exploit\nCited by:\n§1\n.\n[27]\nM. Hind\n(2001)\nPointer analysis: haven’t we solved this problem yet?\n.\nIn\nProceedings of the 2001 ACM SIGPLAN-SIGSOFT workshop on Program analysis for software tools and engineering\n,\npp. 54–61\n.\nCited by:\n§4.2.2\n.\n[28]\nM. Hooper, Y. Tian, R. Zhou, B. Cao, A. P. Lauf, L. Watkins, W. H. Robinson, and W. Alexis\n(2016)\nSecuring commercial wifi-based uavs from common security attacks\n.\nIn\nMILCOM 2016-2016 IEEE Military Communications Conference\n,\npp. 1213–1218\n.\nCited by:\n§1\n.\n[29]\nZ. Hu and B. Dolan-Gavitt\n(2022)\nIrqdebloat: reducing driver attack surface in embedded devices\n.\nIn\n2022 IEEE Symposium on Security and Privacy (SP)\n,\npp. 1608–1622\n.\nCited by:\n§1\n,\n§1\n,\n§3.1\n,\n§7\n.\n[30]\nZ. Hu, S. Lee, and M. Peinado\n(2023)\nHacksaw: hardware-centric kernel debloating via device inventory and dependency analysis\n.\nIn\nProceedings of the 2023 ACM SIGSAC Conference on Computer and Communications Security\n,\npp. 1994–2008\n.\nCited by:\n§1\n,\n§1\n,\n§3.1\n,\n§7\n.\n[31]\nY. Huang, V. Narayanan, D. Detweiler, K. Huang, G. Tan, T. Jaeger, and A. Burtsev\n(2022)\n{\n\\{\nksplit\n}\n\\}\n: Automating device driver isolation\n.\nIn\n16th USENIX Symposium on Operating Systems Design and Implementation (OSDI 22)\n,\npp. 613–631\n.\nCited by:\n§1\n.\n[32]\nR. Jahanshahi, B. A. Azad, N. Nikiforakis, and M. Egele\n(2023)\nMinimalist: semi-automated debloating of\n{\n\\{\nphp\n}\n\\}\nweb applications through static analysis\n.\nIn\n32nd USENIX Security Symposium (USENIX Security 23)\n,\npp. 5557–5573\n.\nCited by:\n§1\n,\n§7\n.\n[33]\nC. H. Kim, T. Kim, H. Choi, Z. Gu, B. Lee, X. Zhang, and D. Xu\n(2018)\nSecuring real-time microcontroller systems through customized memory view switching.\n.\nIn\nNDSS\n,\nCited by:\n§1\n,\n§1\n,\n§1\n,\n§2.2\n,\n§3.1\n,\n§3.1\n,\n§3.3\n,\n§3.3\n,\n§4.1\n,\n§4.1\n,\n§6.2.2\n,\n§6.3.2\n,\n§7\n.\n[34]\nA. Li, J. Wang, and N. Zhang\n(2025)\nSoftware availability protection in cyber-physical systems\n.\nIn\n34nd USENIX Security Symposium (USENIX Security 25)\n,\nCited by:\n§4.1\n,\n§6.2.2\n,\n§6.2.2\n.\n[35]\nL. Meier, P. Tanskanen, F. Fraundorfer, and M. Pollefeys\n(2011)\nPixhawk: a system for autonomous flight using onboard computer vision\n.\nIn\n2011 ieee international conference on robotics and automation\n,\npp. 2992–2997\n.\nCited by:\n§6.1\n.\n[36]\n(Last Accessed, Aug 2025)\nPixhawk power consumption\n.\nNote:\nhttps://diydrones.com/profiles/blogs/pixhawk-and-apm-power-consumption\nCited by:\n§6.3.1\n.\n[37]\n(Last Accessed, Aug 2025)\nPixhawk\n.\nNote:\nhttps://ardupilot.org/copter/docs/common-pixhawk-overview.html\nCited by:\n§6.1\n.\n[38]\n(Last Accessed, Aug 2025)\nPX4 airframes\n.\nNote:\nhttps://docs.px4.io/v1.12/en/airframes/airframe_reference.html\nCited by:\n§6.1\n.\n[39]\n(Last Accessed, Aug 2025)\nPX4 documentation\n.\nNote:\nhttps://docs.px4.io/main/en/flight_modes/\nCited by:\nTABLE VII\n,\nTABLE VII\n,\nAppendix C\n.\n[40]\n(Last Accessed, Oct 2025)\nPX4 fail-safe configuration\n.\nNote:\nhttps://docs.px4.io/main/en/config/safety.html\nCited by:\n§4.1\n.\n[41]\n(Last Accessed, Aug 2025)\nPX4 open source autopilot\n.\nNote:\nhttps://docs.px4.io/main/en/\nCited by:\n§1\n,\n§2.2\n,\n§6.1\n.\n[42]\n(Last Accessed, Aug 2025)\nQGroundControl\n.\nNote:\nhttps://qgroundcontrol.com/\nCited by:\n§6.1\n.\n[43]\nC. Qian, H. Hu, M. Alharthi, P. H. Chung, T. Kim, and W. Lee\n(2019)\n{\n\\{\nrazor\n}\n\\}\n: A framework for post-deployment software debloating\n.\nIn\n28th USENIX security symposium (USENIX Security 19)\n,\npp. 1733–1750\n.\nCited by:\n§3.1\n.\n[44]\nA. Quach, A. Prakash, and L. Yan\n(2018)\nDebloating software through\n{\n\\{\npiece-wise\n}\n\\}\ncompilation and loading\n.\nIn\n27th USENIX security symposium (USENIX Security 18)\n,\npp. 869–886\n.\nCited by:\n§1\n.\n[45]\nD. Quarta, M. Pogliani, M. Polino, F. Maggi, A. M. Zanchettin, and S. Zanero\n(2017)\nAn experimental security analysis of an industrial robot controller\n.\nIn\n2017 IEEE Symposium on Security and Privacy (SP)\n,\npp. 268–286\n.\nCited by:\n§1\n.\n[46]\nR. Quinonez, J. Giraldo, L. Salazar, E. Bauman, A. Cardenas, and Z. Lin\n(2020)\n{\n\\{\nsavior\n}\n\\}\n: Securing autonomous vehicles with robust physical invariants\n.\nIn\n29th USENIX security symposium (USENIX Security 20)\n,\npp. 895–912\n.\nCited by:\n§4.1\n.\n[47]\nV. L. Rajagopalan, K. Kleftogiorgos, E. Göktas, J. Xu, and G. Portokalidis\n(2023)\nSyspart: automated temporal system call filtering for binaries\n.\nIn\nProceedings of the 2023 ACM SIGSAC Conference on Computer and Communications Security\n,\npp. 1979–1993\n.\nCited by:\n§1\n,\n§1\n,\n§1\n,\n§1\n,\n§3.1\n,\n§3.1\n,\n§4.1\n,\n§6.1\n,\n§6.2.2\n,\n§7\n.\n[48]\nM. Salehi, D. Hughes, and B. Crispo\n(2020)\n{\n\\{\nμ\n\\mu\nsbs\n}\n\\}\n: Static binary sanitization of bare-metal embedded devices for fault observability\n.\nIn\n23rd International Symposium on Research in Attacks, Intrusions and Defenses (RAID 2020)\n,\npp. 381–395\n.\nCited by:\n§2.2\n,\n§3.1\n.\n[49]\n(Last Accessed, Aug 2025)\nSeccomp bpf (secure computing with filters)\n.\nNote:\nhttps://www.kernel.org/doc/html/v4.16/userspace-api/seccomp_filter.html\nCited by:\n§1\n.\n[50]\n(Last Accessed, Oct 2025)\nStack buffer overflow\n.\nNote:\nhttps://github.com/PX4/PX4-Autopilot/issues/5643\nCited by:\n§6.2.2\n.\n[51]\nY. Sui and J. Xue\n(2016)\nSVF: interprocedural static value-flow analysis in llvm\n.\nIn\nProceedings of the 25th international conference on compiler construction\n,\npp. 265–266\n.\nCited by:\n§1\n,\n§4.2.2\n.\n[52]\n(Last Accessed, Aug 2025)\nSVF\n.\nNote:\nhttps://github.com/SVF-tools/SVF\nCited by:\n§5\n.\n[53]\nL. Szekeres, M. Payer, T. Wei, and D. Song\n(2013)\nSok: eternal war in memory\n.\nIn\n2013 IEEE Symposium on Security and Privacy\n,\npp. 48–62\n.\nCited by:\n§2.1\n.\n[54]\n(Last Accessed, Aug 2025)\nThe llvm compiler\n.\nNote:\nhttps://llvm.org/\nCited by:\n3rd item\n,\n§3.3\n.\n[55]\n(Last Accessed, Aug 2025)\nUPS will use drones to deliver medical supplies in north carolina\n.\nNote:\nhttps://www.theverge.com/2019/3/26/18282291/ups-drone-delivery-hospital-nc-matternet\nCited by:\n§6.1\n.\n[56]\n(Last Accessed, Aug 2025)\nWriting an llvm pass\n.\nNote:\nhttps://llvm.org/docs/WritingAnLLVMPass.html\nCited by:\n§5\n.\n[57]\nJ. Wu, R. Wu, D. Antonioli, M. Payer, N. O. Tippenhauer, D. Xu, D. J. Tian, and A. Bianchi\n(2021)\n{\n\\{\nlightblue\n}\n\\}\n: Automatic\n{\n\\{\nprofile-aware\n}\n\\}\ndebloating of bluetooth stacks\n.\nIn\n30th USENIX Security Symposium (USENIX Security 21)\n,\npp. 339–356\n.\nCited by:\n§7\n.\nAppendix A\nImplementation Details\nA summary of the\nRVDebloater\nimplementation across its five main components,\ncorresponding to the different phases (§\n5\n, §\nA.1\n,\n§\nA.2\n, and §\nA.3\n)\nis presented in Table\nVI\n.\nTABLE VI\n:\nLines of code in\nRVDebloater\ncomponents.\nComponent\nLines of Code\nPruning Heuristics\n220 C++\nInstrumentation\n1000 C++ (two LLVM passes)\nRVDebloater\nProfiler\n500 C\nGuard Insertion\n1100 C++ (two LLVM passes)\nRVDebloater\nMonitor\n400 C\nTotal\n3220\nA.1\nAnalysis Phase\nAs mentioned earlier, the instrumentation component of the analysis phase takes the firmware source code as input.\nIn the first step, the firmware is compiled to LLVM bitcode (\nbc\nfile) using the\ngclang\nand\ngclang++\ncompilers\n[\n23\n]\n.\nThen, if\nRVDebloater-static\nis selected, it uses the modified version of SVF with two pruning heuristics—signature-based and address-based—to generate a pruned call graph.\nWe modified the TSCP implementation\n[\n22\n]\nby adding new heuristics to refine the call graph.\nA Python script then analyzes this call graph to generate lists of reachable functions for each mode through static analysis.\nIf\nRVDebloater-dynamic\nis selected, the instrumentation component links the firmware bitcode with\nRVDebloater\n’s profiler functions (i.e.,\nmode_entry\nand\nlog_fn\n).\nThis component then takes the mode-switching function as input and iterates through the firmware’s instructions.\nSpecifically, it inserts\nmode_entry\nat locations within the mode-switching function where the return value is\ntrue\n, indicating a successful mode change.\nAlso, it inserts\nlog_fn\nat the entry points of other firmware functions.\n⬇\ndefine\ndso_local\nzeroext\ni1\n@AP_Arming_Plane\n(%\nclass\n.\nAP_Arming_Plane\n*,\ni32\n,\ni1\nzeroext\n)\n#0\nalign\n2\n!\ndbg\n!97833\n{\n/\n/\nAllocation\nVariables\ncall\nvoid\n@log_fn\n(\narguments\n)\n/\n/\n...\nomit\n}\nListing 4:\nInserting\nlog_fn\nat the entry of functions.\nIn the example shown in Listing\n4\n, the instrumentation component inserts\nlog_fn\nat the beginning of the function, after the allocation instructions.\nFinally,\nRVDebloater\nautomatically executes the instrumented firmware with different missions\nin a benign environment and tracks its execution using profiler functions to identify the required functions\nfor each mode at runtime.\nA.2\nGuard Insertion Phase\nIn the next phase, a different instrumentation component takes the firmware and mode-switching function(s) as input.\nOnce the firmware is compiled to LLVM bitcode using\ngclang\nand\ngclang++\ncompilers and linked with\nRVDebloater\n’s monitor functions\n(i.e.,\nmode_entry_runtime\nand\nmonitor_fn\n),\nRVDebloater\nfirst identifies\nthe mode-switching function(s). It then inserts\nmode_entry_runtime\n, which monitors mode changes and loads\nthe required functions for the new mode from the configuration file (either static or dynamic output) at\nlocations where the mode successfully changes. Part of the\nmode_entry_runtime\nfunction in the LLVM IR format is shown in Listing\n6\n. Next, the component iterates over the firmware functions and replaces indirect control flow transfer instructions (e.g., indirect call sites represented by\nCallInst\nin LLVM IR) and\nreturn instructions (\nReturnInst\nin LLVM IR) with\nmonitor_fn\n, which controls target execution,\nraises an alarm, and switches to\nFail-Safe\nmode if needed.\n⬇\n1\ndefine\ndso_local\nzeroext\ni1\n@Plane18set_mode_by_number\n(%\nclass\n.\nPlane\n*,\ni8\nzeroext\n,\ni8\nzeroext\n)\n#0\nalign\n2\n!\ndbg\n!566193\n{\n/\n/\n...\nomit\n2\ncall\nvoid\n@mode_entry_runtime\n(\narguments\n)\n3\nret\ni1\n%22,\n!\ndbg\n!566216\n4\n}\nListing 5:\nInserting\nmode_entry_runtime\nbefore return instruction (Listing\n3\n).\nFor instance, this component inserts\nmode_entry_runtime\nbefore the return instruction\nwhen its value is true, as shown in Listing\n5\n.\nFinally, it stores the instrumented file.\nA.3\nMonitoring Phase\nIn the final phase,\nRVDebloater\nbuilds the instrumented firmware executable using the\nClang\ncompiler\n[\n17\n]\n.\nAt runtime (during an RV mission), the\nRVDebloater\nmonitor is triggered when a mode change occurs.\nThe monitor component then loads the corresponding configuration file, which includes the required functions for the new mode identified by either static or dynamic analysis.\nFurthermore, the\nRVDebloater\nmonitor is triggered whenever an indirect control flow transfer or a return instruction is executed.\nIn such cases, the component checks permissions based on the loaded configuration for the current mode and logs the event,\nraising an alarm or switching to\nFail-Safe\nmode if an unauthorized execution is detected.\nAppendix B\nLLVM IR Example\n⬇\n1\ndefine\ndso_local\nvoid\n@mode_entry_runtime\n(\ni8\nzeroext\n)\n#0\n{\n2\n%2\n=\nalloca\ni8\n,\nalign\n1\n3\n%3\n=\nalloca\n%\nstruct\n.\nFuncEntry\n*,\nalign\n8\n4\n%4\n=\nalloca\n%\nstruct\n.\nFuncEntry\n*,\nalign\n8\n5\n%5\n=\nalloca\n%\nstruct\n.\nUT_hash_handle\n*,\nalign\n8\n6\n/\n/\nother\nalloca\ninstructions\n(omit)\n7\nstore\ni8\n%0,\ni8\n*\n%2,\nalign\n1\n8\n%44\n=\nload\ni32\n,\ni32\n*\n@curr_mode_id\n,\nalign\n4\n9\n%45\n=\nload\ni8\n,\ni8\n*\n%2,\nalign\n1\n10\n%46\n=\nzext\ni8\n%45\nto\ni32\n11\n%47\n=\nicmp\neq\ni32\n%44,\n%46\n12\nbr\ni1\n%47,\nlabel\n%48,\nlabel\n%49\n13\n;\n<\nlabel\n>:48:\n;\npreds\n=\n%1\n14\nbr\nlabel\n%2248\n15\n;\n<\nlabel\n>:49:\n;\npreds\n=\n%1\n16\nstore\nvolatile\ni32\n1,\ni32\n*\n@mode_switching\n,\nalign\n4\n17\n%50\n=\nload\n%\nstruct\n.\nFuncEntry\n*,\n%\nstruct\n.\nFuncEntry\n**\n@allowed_functions\n,\nalign\n8\n18\n%51\n=\nicmp\nne\n%\nstruct\n.\nFuncEntry\n*\n%50,\nnull\n19\nbr\ni1\n%51,\nlabel\n%52,\nlabel\n%437\n20\n;\n<\nlabel\n>:52:\n;\npreds\n=\n%49\n21\n%53\n=\nload\n%\nstruct\n.\nFuncEntry\n*,\n%\nstruct\n.\nFuncEntry\n**\n@allowed_functions\n,\nalign\n8\n22\nstore\n%\nstruct\n.\nFuncEntry\n*\n%53,\n%\nstruct\n.\nFuncEntry\n**\n%3,\nalign\n8\n23\n%54\n=\nload\n%\nstruct\n.\nFuncEntry\n*,\n%\nstruct\n.\nFuncEntry\n**\n@allowed_functions\n,\nalign\n8\n24\n%55\n=\nicmp\nne\n%\nstruct\n.\nFuncEntry\n*\n%54,\nnull\n25\nbr\ni1\n%55,\nlabel\n%56,\nlabel\n%61\n26\n/\n/\nother\ninstructions\n(omit)\n27\n;\n<\nlabel\n>:2248:\n;\npreds\n=\n%2245,\n%495,\n%453,\n%48\n28\nret\nvoid\n29\n}\nListing 6:\nA part of the LLVM IR for the\nmode_entry_runtime\nfunction in\nRVDebloater\n’s mode-switching monitor (line 2 of Listing\n5\n).\nListing\n6\nshows a part of the\nmode_entry_runtime\nfunction in LLVM IR format,\nwhich is used by\nRVDebloater\nto instrument mode-switching function(s) in\nguard insertion\nphase.\nFor the sake of simplicity, we only present a partial snippet of this function.\nAs previously discussed in §\n4.3\nand §\nA.2\n,\nbefore executing the device and monitoring it for specialization,\nRVDebloater\ninstruments the mode-switching function(s) during the\nguard insertion\nphase.\nRVDebloater\niterates over these functions to identify locations where\na mode switch is successful (e.g., returning true or a new mode), and then\ninserts a call to\nmode_entry_runtime\nat those points.\nThe purpose of\nmode_entry_runtime\nfunction\nis to monitor mode changes at runtime and load the configuration file corresponding to the new mode, allowing\nthe\nRVDebloater\nmonitor to specialize and restrict access to other firmware function via another function called\nmonitor_fn\n, which controls indirect control flow transfer instructions.\nAs can be seen in the Listing\n6\n, after initializing the variables (lines 2 to 7),\nthe function compares the\ncurrent mode with the new mode passed as an argument (e.g.,\nset_mode_by_number\nfunction in Listing\n5\n)\nin lines between 7 to 12, to ensure they are not the same.\nThen, in lines 16 to 25, it loads the new list of functions and their corresponding addresses into a structure (e.g.,\nallowed_functions\n).\nOnce this process is complete, control returns to the mode-switching function (line 28).\nAppendix C\nArduPilot & PX4 Modes\nThe explanation of the main modes of ArduPilot and PX4 across different RV types (firmware), including ArduCopter, ArduPlane, ArduRover, and PXCopter,\nis summarized in Table\nVII\n. For a more detailed explanation and information on other modes,\nplease refer to the ArduPilot and PX4 documentations\n[\n8\n,\n39\n]\n.\nTABLE VII\n:\nArduPilot and PX4 Mode Details. For details about each mode, see the ArduPilot and PX4 documentations\n[\n8\n,\n39\n]\n.\nRV Type\nMode\nMode Description\nArduCopter\nAUTO\nAutomatically flying to a pre-defined mission\nCIRCLE\nAutomatically circling a point in front of the RV\nSTABILIZE\nSelf levels in the roll and pitch axis\nGUIDED\nFlying to points commanded by GCS\nRTL\nReturning to home (launch) location, can also include landing\nLOITER\nHolding altitude and position, uses GPS for movements\nTURTLE\nFlipping an inverted vehicle upright\nArduPlane\nMANUAL\nRegular RC control, no stabilization\nAUTO\nFlying to a preloaded mission (set of GPS coordinates)\nCIRCLE\nGently turning the RV around the point\nGUIDED\nFlying and circling the RV to points commanded by GCS\nQLOITER\nAutomatically attempting to maintain the current location, heading and altitude\nRTL\nReturning to home (launch) location\nQHOVER\nMaintaining a consistent altitude while allowing roll, pitch, and yaw to be controlled normally\nArduRover\nAUTO\nFollowing a preloaded mission (set of GPS coordinates)\nCIRCLE\nAutomatically orbits a point, sent from the GCS, located in front of the RV\nMANUAL\nManually control the vehicle’s throttle and steering\nRTL\nReturning to home (launch) location\nGUIDED\nControlling and moving the RV to points commanded by GCS\nLOITER\nMaintaining the current location and heading\nPXCopter\nTAKEOFF\nTaking off vertically and then switches to Hold mode\nMISSION\nFollowing a preloaded mission (set of GPS coordinates)\nLOITER\nHolding altitude and position, uses GPS for movements\nRTL\nReturning to home (launch) location and landing",
    "preview_text": "As the number of embedded devices grows and their functional requirements increase, embedded firmware is becoming increasingly larger, thereby expanding its attack surface. Despite the increase in firmware size, many embedded devices, such as robotic vehicles (RVs), operate in distinct modes, each requiring only a small subset of the firmware code at runtime. We refer to such devices as mode-based embedded devices. Debloating is an approach to reduce attack surfaces by removing or restricting unneeded code, but existing techniques suffer from significant limitations, such as coarse granularity and irreversible code removal, limiting their applicability.\n  To address these limitations, we propose RVDebloater, a novel adaptive debloating technique for mode-based embedded devices that automatically identifies unneeded firmware code for each mode using either static or dynamic analysis, and dynamically debloats the firmware for each mode at the function level at runtime. RVDebloater introduces a new software-based enforcement approach that supports diverse mode-based embedded devices. We implemented RVDebloater using the LLVM compiler and evaluated its efficiency and effectiveness on six different RVs, including both simulated and real ones, with different real-world missions. We find that device requirements change throughout its lifetime for each mode, and that many critical firmware functions can be restricted in other modes, with an average of 85% of functions not being required. The results showed that none of the missions failed after debloating with RVDebloater, indicating that it neither incurred false positives nor false negatives. Further, RVDebloater prunes the firmware call graph by an average of 45% across different firmware. Finally, RVDebloater incurred an average performance overhead of 3.9% and memory overhead of 4% (approximately 0.25 MB) on real RVs.\n\nRVDebloater: Mode-based Adaptive Firmware Debloating for Robotic Vehicles\nMohsen Salehi\nKarthik Patta",
    "is_relevant": false,
    "relevance_score": 1.0,
    "extracted_keywords": [
        "robotic vehicles",
        "firmware debloating",
        "embedded devices",
        "mode-based",
        "attack surface reduction",
        "static analysis",
        "dynamic analysis",
        "runtime adaptation",
        "LLVM compiler",
        "performance overhead"
    ],
    "one_line_summary": "这篇论文提出了一种针对机器人车辆的自适应固件去膨胀技术，通过运行时动态移除未使用的代码来减少攻击面，与强化学习、视觉语言动作模型等关键词无关。",
    "detailed_summary": "",
    "qa_pairs": [],
    "is_hidden": false,
    "is_starred": false,
    "flag": true,
    "published_date": "2026-01-30T19:46:08Z",
    "created_at": "2026-02-03T15:53:18.838663",
    "updated_at": "2026-02-03T15:53:18.838672"
}