{
    "id": "2601.07172v1",
    "title": "TranSC: Hardware-Aware Design of Transcendental Functions Using Stochastic Logic",
    "authors": [
        "Mehran Moghadam",
        "Sercan Aygun",
        "M. Hassan Najafi"
    ],
    "abstract": "Ë∂ÖË∂äÂáΩÊï∞Âú®Á°¨‰ª∂‰∏äÁöÑÂèãÂ•ΩÂÆûÁé∞‰∏ÄÁõ¥ÊòØËÆæËÆ°Ëá™Âä®ÂåñÈ¢ÜÂüüÈïøÊúüÈù¢‰∏¥ÁöÑÊåëÊàò„ÄÇËøôÁ±ªÊó†Ê≥ïÁî®ÊúâÈôê‰ª£Êï∞ËøêÁÆóÁªÑÂêàË°®Á§∫ÁöÑÂáΩÊï∞ÔºåÁªôÊï∞Â≠óÁîµË∑ØËÆæËÆ°Â∏¶Êù•‰∫ÜÊûÅÂ§ßÁöÑÂ§çÊùÇÊÄß„ÄÇÊú¨Á†îÁ©∂ÊèêÂá∫‰∫Ü‰∏ÄÁßçÂàõÊñ∞ÊñπÊ≥ïTranSCÔºåÂà©Áî®ÈöèÊú∫ËÆ°ÁÆóÊäÄÊúØÂÆûÁé∞Ë∂ÖË∂äÂáΩÊï∞ÁöÑËΩªÈáèÁ∫ßÈ´òÁ≤æÂ∫¶ÂÆûÁé∞„ÄÇÂú®Áé∞ÊúâÈöèÊú∫ËÆ°ÁÆóÊäÄÊúØÂü∫Á°Ä‰∏äÔºåÊàë‰ª¨ÁöÑÊñπÊ≥ïÊé¢Á¥¢‰∫ÜÊõø‰ª£ÈöèÊú∫Ê∫ê‚Äî‚ÄîÁâπÂà´ÊòØÂáÜÈöèÊú∫ËåÉÂæ∑ÁßëÊôÆÁâπ‰ΩéÂ∑ÆÂºÇÂ∫èÂàó‚Äî‚Äî‰ª•Âèñ‰ª£‰º†ÁªüÁöÑ‰º™ÈöèÊú∫ÊÄß„ÄÇËøô‰∏ÄËΩ¨ÂèòÊòæËëóÊèêÂçá‰∫ÜÂü∫‰∫éÈöèÊú∫ËÆ°ÁÆóÁöÑÁ≤æÂ∫¶‰∏éÊïàÁéá„ÄÇÊàë‰ª¨ÈÄöËøáÂØπ‰∏âËßíÂáΩÊï∞„ÄÅÂèåÊõ≤ÂáΩÊï∞ÂíåÊøÄÊ¥ªÂáΩÊï∞Á≠âÂ§öÁßçÂáΩÊï∞Á±ªÂûãËøõË°åÂπøÊ≥õÂÆûÈ™åÈ™åËØÅ‰∫ÜËØ•ÊñπÊ≥ï„ÄÇ‰∏éÁé∞ÊúâÊúÄ‰ºòÊñπÊ°àÁõ∏ÊØîÔºåÊâÄÊèêÂá∫ÁöÑËÆæËÆ°ÊñπÊ°àÂú®Â∞ÜÂùáÊñπËØØÂ∑ÆÈôç‰ΩéÈ´òËææ98%ÁöÑÂêåÊó∂ÔºåÁ°¨‰ª∂Èù¢ÁßØ„ÄÅÂäüËÄóÂíåËÉΩËÄóÂàÜÂà´ÂáèÂ∞ë‰∫Ü33%„ÄÅ72%Âíå64%„ÄÇ",
    "url": "https://arxiv.org/abs/2601.07172v1",
    "html_url": "https://arxiv.org/html/2601.07172v1",
    "html_content": "TranSC: Hardware-Aware Design of Transcendental Functions Using Stochastic Logic\nIEEE Publication Technology\nThis paper was produced by the IEEE Publication Technology Group. They are in Piscataway, NJ.Manuscript received April 19, 2021; revised August 16, 2021.\nMehran¬†Moghadam\nID\n,¬†, Sercan¬†Aygun\nID\n,¬†, and\nM.¬†Hassan¬†Najafi\nID\n,\nThis work is supported in part by National Science Foundation (NSF) under grants #2019511, #2339701, NASA grant 80NSSC25C0335, and generous gifts from NVIDIA.\nMehran Moghadam and M. Hassan Najafi are with the Electrical, Computer, and Systems Engineering Department, Case Western Reserve University, Cleveland, OH, USA.\nE-mail:{moghadam, najafi}@case.edu. Sercan Aygun is with the School of Computing and Informatics, University of Louisiana at Lafayette, Lafayette, LA, USA. E-mail: sercan.aygun@louisiana.edu. A preliminary version of this paper appeared as\n[\n7\n]\n.\nAbstract\nThe hardware-friendly implementation of transcendental functions remains a longstanding challenge in design automation.\nThese functions, which cannot be expressed as finite combinations of algebraic operations, pose significant complexity in digital circuit design.\nThis study introduces a novel approach,\nTranSC\n, that utilizes stochastic computing (SC) for lightweight yet accurate implementation of transcendental functions. Building on established SC techniques,\nour method explores alternative random sources‚Äîspecifically, quasi-random Van der Corput low-discrepancy (LD) sequences‚Äîinstead of conventional pseudo-randomness. This shift enhances both the accuracy and efficiency of SC-based computations.\nWe validate our approach through extensive experiments on various function types, including trigonometric, hyperbolic, and activation functions.\nThe proposed design approach significantly reduces MSE by up to 98% compared to the state-of-the-art solutions while reducing hardware area, power consumption, and energy usage by 33%, 72%, and 64%, respectively.\nI\nIntroduction\nThe rapid growth of deep neural networks has placed unprecedented demands on computing hardware, particularly for activation functions that introduce non-linearity. Functions such as sigmoid, hyperbolic tangent, and their underlying exponential and logarithmic forms are especially costly when implemented using conventional binary computing. Likewise, trigonometric functions such as sine and cosine are indispensable for analyzing periodic behavior in digital signal processing (DSP),\nwith widespread applications in motor control, communications, and noise filtering. These domains often operate under strict real-time and low-power constraints. Implementing transcendental functions in software on general-purpose processors causes significant computational delays, ultimately limiting throughput and responsiveness. To overcome this bottleneck, the design of low-latency, cost-efficient hardware accelerators has become a critical objective for embedded DSP systems\n[\n14\n]\n.\nTranscendental functions are equally vital in computer graphics and robotics, where they play a central role in coordinate transformations, lighting calculations, and robotic kinematics. These operations frequently depend on sine and cosine computations, and their accuracy directly impacts the final output, whether in the visual quality of a rendered image or the positioning precision of a robotic manipulator.\nThe importance of these functions is underscored by the inclusion of dedicated Special Function Units (SFUs) in modern GPUs to accelerate their evaluation\n[\n21\n]\n. However, in resource-constrained platforms such as mobile robots, autonomous drones, or AR/VR headsets, the power and area requirements of SFUs can be prohibitive. This limitation has created a strong demand for alternative hardware solutions that are both ultra-lightweight and energy-efficient, while still providing sufficient accuracy for performance-critical applications.\nStochastic computing (SC) is a re-emerging computing paradigm that enables ultra-low-cost implementations for complex arithmetic operations\n[\n2\n,\n23\n]\n. SC offers robust data processing with significantly reduced hardware cost and power consumption, making it attractive for resource-constrained systems. An SC system typically comprises three core modules: a\nbit-stream generator (BSG)\n, a\ncomputation logic block (CLB)\n, and an\noutput decoder\n[\n24\n]\n. In SC systems, scalar values are converted into random binary sequences, known as bit-streams, where all bits have equal weight. The quality of randomness in these bit-streams (governed by the BSG, often implemented with pseudo-random number generators (RNGs)) plays a critical role in determining system accuracy.\nFig.\n1\nillustrates a general SC system consisting of the BSG, CLB, and output decoder. The CLB unit processes the bit-streams using simple logic gates (e.g.,\nAND\n,\nOR\n,\nXOR\n) or lightweight sequential circuits such as\nflip-flops (\nFF\ns). The decoder converts the output bit-stream back to standard binary radix format, typically by counting the number of ones in the bit-stream\n[\n6\n]\n. This architecture allows SC to replace costly arithmetic circuits with basic logic components, offering a highly efficient alternative for implementing complex mathematical functions.\nFigure 1:\nA general SC system architecture with BSG, CLB, and output decoder that converts the output bit-stream to standard radix representation.\nNumerous arithmetic blocks have been developed within SC frameworks\n[\n17\n,\n38\n,\n47\n]\n. In particular, considerable research has focused on extending SC to transcendental and algebraic functions\n[\n22\n,\n33\n,\n12\n,\n18\n,\n43\n]\n, often by employing intermediary mathematical tools, such as Bernstein polynomials and Taylor or Maclaurin series expansions.\nWhile prior efforts have primarily concentrated on designing low-cost CLB units\n[\n27\n]\n, this work shifts attention to the BSG as a key lever for improving accuracy and reducing hardware overhead and processing latency.\nSpecifically, we exploit lightweight low-discrepancy (LD) sequence generators for the BSG unit to realize highly efficient SC designs.\nLD sequences are quasi-random number generators that distribute values more uniformly than pseudo-random sources, enabling faster convergence and reduced error in SC-based designs\n[\n25\n]\n. The key contributions of this study are as follows:\n‚ù∂ Design exploration of SC-based transcendental functions using lightweight\nQuasi-Random\nBSG units.\n‚ù∑ Reducing delay and improving hardware efficiency of transcendental function designs by leveraging LD bit-streams.\n‚ù∏ Mitigation of computational error and hardware cost in SC-based designs of transcendental\nfunctions.\n‚ùπ Demonstration of two novel applications in SC:\nimage geometric transformation\nand\nrobotic manipulator positioning\n.\nFigure 2:\nBit-stream generation using RNG and comparator (a) Shared RNG for correlated bit-streams. (b) Independent RNGs for uncorrelated bit-streams.\nThe remainder of this manuscript is organized as follows. Section\nII\nreviews the fundamentals of SC. Section\nIII\ndiscusses core concepts for implementing transcendental functions, transitioning from traditional SC approaches. Section\nIV\nintroduces the proposed framework, featuring a novel random number generation technique and improvements over state-of-the-art (SOTA) designs.\nSection\nV\npresents detailed\nexperimental results, including accuracy and hardware cost comparisons. Section\nVI\nprovides validation and justification of the proposed approach relative to SOTA methods.\nSection\nVII\ndemonstrates the application of SC through two representative use cases.\nSection\nVIII\nprovides a detailed discussion and comparison with SOTA design implementations.\nFinally, Section\nIX\nconcludes the paper by summarizing the key contributions.\nII\nFundamentals of SC\nSC offers an unconventional approach to computation by departing from the traditional binary radix system that encodes information positionally\n[\n2\n]\n. Rather than relying on fixed-point or floating-point representations, which demand complex arithmetic circuits, SC realizes arithmetic with simple bitwise logic over probabilistic bit-streams.\nFor example, bit-wise\nAND\nimplements the multiplication operation when applied to independent bit-streams.\nOther fundamental SC arithmetic circuits include a\nMUX\nfor scaled addition (\na\n‚Äã\nd\n‚Äã\nd\nadd\n)\n[\n8\n]\n, an inverted-input\nMUX\nfor scaled subtraction (\ns\n‚Äã\nu\n‚Äã\nb\nsub\n), and a\nJK-FF\n-based design for approximate division (\nd\n‚Äã\ni\n‚Äã\nv\ndiv\n)\n[\n13\n]\n.\nAny scalar value within the range\n0\n‚â§\nX\n‚â§\nN\n0\\leq X\\leq N\n(or equivalently\n0\n‚â§\nX\nN\n‚â§\n1\n0\\leq\\frac{X}{N}\\leq 1\nwhen normalized to the unit interval) can be encoded into an\nN\nN\n-bit stochastic bit-stream using a hardware configuration composed of an RNG and a comparator. For each bit position, the RNG generates a random value (\nR\nR\n), and the comparator evaluates the condition\nX\n>\nR\ni\nX>R_{i}\n. If true, the corresponding bit position is set to logic-\n1\n1\n; otherwise, it is set to logic-\n0\n. This bit-stream generation process is a fundamental step in SC systems.\nThe performance of SC operations directly depends on the BSG unit. The quality of randomness and the degree of correlation between bit-streams play a pivotal role in the performance and accuracy of computations. Let\nX\n‚Äã\n1\nX1\nand\nX\n‚Äã\n2\nX2\ndenote scalar values encoded into stochastic bit-streams. Existing approaches to bit-stream generation predominantly adopt one of two methodologies:\nI)\nshared RNG method\n: a single random source is shared with two comparators to produce two\ncorrelated\nbit-streams (Fig.\n2\n(a)), II)\nindependent RNG method\n: two separate random sources are utilized to generate two\nuncorrelated\nbit-streams (Fig.\n2\n(b)).\nTwo primary BSG setups stand out in the state-of-the-art SC designs: i) a linear-feedback shift register (LFSR) combined with a comparator\n[\n3\n]\nand ii) a Sobol sequence generator combined with a comparator\n[\n31\n]\n. The former produces pseudo-random sequences, while the latter generates quasi-random sequences. Pseudo-random sources use deterministic mathematical algorithms to produce sequences that repeat when initialized with the same seed.\nQuasi-randomness introduces\nstructured variability, generating sequences that mimic randomness while maintaining a more uniform distribution.\nThese sequences are characterized by their evenly dispersed points in space, leading to better uniformity.\nWe later discuss that, for this work, we leverage quasi-random sequences by adopting cost-effective\nVan der Corput\n(VDC) sequence generators. These provide a uniform distribution with favorable hardware properties.\nThe CLB unit processes the generated stochastic bit-streams. Any arithmetic function\nf\nf\ncan be formulated in terms of\nprobabilities\nassociated with the input bit-streams. For a bit-stream of length\nN\nN\n, the probability of observing logic-\n1\n1\nis given by\nP\n=\n‚àë\nl\n‚Äã\no\n‚Äã\ng\n‚Äã\ni\n‚Äã\nc\n‚àí\n1\nN\nP=\\frac{\\sum{logic-1}}{N}\n. For two input operands\nX\n‚Äã\n1\nX1\nand\nX\n‚Äã\n2\nX2\n, the corresponding probabilities are denoted by\nP\nX\n‚Äã\n1\nP_{X1}\nand\nP\nX\n‚Äã\n2\nP_{X2}\n. The output of a stochastic function\nf\nf\nis then expressed as\nf\nm\n‚Äã\nu\n‚Äã\nl\n=\nP\nX\n‚Äã\n1\n√ó\nP\nX\n‚Äã\n2\nf_{mul}=P_{X1}\\times P_{X2}\n,\nf\na\n‚Äã\nd\n‚Äã\nd\n=\nP\nX\n‚Äã\n1\n+\nP\nX\n‚Äã\n2\nf_{add}=P_{X1}+P_{X2}\n,\nf\ns\n‚Äã\nu\n‚Äã\nb\n=\nP\nX\n‚Äã\n1\n‚àí\nP\nX\n‚Äã\n2\nf_{sub}=P_{X1}-P_{X2}\n, and\nf\nd\n‚Äã\ni\n‚Äã\nv\n=\nP\nX\n‚Äã\n1\nP\nX\n‚Äã\n2\nf_{div}=\\frac{P_{X1}}{P_{X2}}\n. In practice, discrepancies may arise between the\nexpected\nand the\nproduced\noutputs of SC systems due to three primary factors:\n‚ûÄ improper cross-correlation between input bit-streams, ‚ûÅ random fluctuations in bit-streams stemming typically from the pseudo-random sources,\nand ‚ûÇ functional approximations introduced by CLB.\nCorrelation\nis defined by the alignment of ‚Äò1‚Äôs between two bit-streams. Ensuring proper cross-correlation between input operands is essential to achieving the desired stochastic function.\nA widely used metric for quantifying the correlation between two bit-streams is the\nStochastic Cross Correlation\n(\nS\n‚Äã\nC\n‚Äã\nC\nSCC\n)\n[\n1\n]\n:\nS\n‚Äã\nC\n‚Äã\nC\n=\n{\na\n‚Äã\nd\n‚àí\nb\n‚Äã\nc\nN\n√ó\nm\n‚Äã\ni\n‚Äã\nn\n‚Äã\n(\na\n+\nb\n,\na\n+\nc\n)\n‚àí\n(\na\n+\nb\n)\n√ó\n(\na\n+\nc\n)\n,\ni\nf\na\nd\n>\nb\nc\na\n‚Äã\nd\n‚àí\nb\n‚Äã\nc\n(\na\n+\nb\n)\n√ó\n(\na\n+\nc\n)\n‚àí\nN\n√ó\nm\n‚Äã\na\n‚Äã\nx\n‚Äã\n(\na\n‚àí\nd\n,\n0\n)\n,\ne\nl\ns\ne\nSCC=\\begin{cases}\\frac{ad-bc}{N\\times min(a+b,a+c)-(a+b)\\times(a+c)}&,\\ if\\ ad>bc\\\\\n\\frac{ad-bc}{(a+b)\\times(a+c)-N\\times max(a-d,0)}&,\\ else\\end{cases}\n(1)\nwhere,\na\na\n,\nb\nb\n,\nc\nc\n, and\nd\nd\nrepresent the logic pairs\n11\n11\n,\n10\n10\n,\n01\n01\n, and\n00\n00\n, respectively, taken from the corresponding bit positions of the two bit-streams.\nThe level of correlation is determined by the number of overlapping logic-1s across all bit positions.\nWhen this overlap is maximized, the bit-streams exhibit\nmaximum correlation\n(\nS\n‚Äã\nC\n‚Äã\nC\n=\n+\n1\nSCC\\!\\!=\\!\\!+1\n); when the overlap is minimized, they are in\nminimum correlation\n(\nS\n‚Äã\nC\n‚Äã\nC\n=\n‚àí\n1\nSCC\\!\\!=\\!\\!-1\n).\nA special case occurs when the bit-streams have\nzero correlation\n(\nS\n‚Äã\nC\n‚Äã\nC\n=\n0\nSCC\\!\\!=\\!0\n), which is desirable in certain SC operations such as multiplication using bit-wise\nAND\noperation.\nLet\nX\n‚Äã\n1\n=\n4\nX1=4\n,\nX\n‚Äã\n2\n=\n6\nX2=6\n, and\nN\n=\n8\nN=8\n. The input probability values are\nP\nX\n‚Äã\n1\n=\n4\n8\nP_{X1}=\\frac{4}{8}\nand\nP\nX\n‚Äã\n2\n=\n6\n8\nP_{X2}=\\frac{6}{8}\n. The three correlation measures for bit-streams are exemplified as follows:\n‚ë†\nX\n‚Äã\n1\n‚Üí\n0\n0\n0\n0\n1\n1\n1\n1\nX\n‚Äã\n2\n‚Üí\n0\n0\n1\n1\n1\n1\n1\n1\n\\begin{smallmatrix}X1&\\rightarrow&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}\\\\\nX2&\\rightarrow&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}\\end{smallmatrix}\n‚ûô\nMaximum Correlation\n‚ë°\nX\n‚Äã\n1\n‚Üí\n1\n1\n1\n1\n0\n0\n0\n0\nX\n‚Äã\n2\n‚Üí\n0\n0\n1\n1\n1\n1\n1\n1\n\\begin{smallmatrix}X1&\\rightarrow&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}\\\\\nX2&\\rightarrow&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}1}\\end{smallmatrix}\n‚ûô\nMinimum Correlation\n‚ë¢\nX\n‚Äã\n1\n‚Üí\n0\n1\n0\n1\n0\n1\n0\n1\nX\n‚Äã\n2\n‚Üí\n0\n0\n1\n1\n1\n1\n1\n1\n\\begin{smallmatrix}X1&\\rightarrow&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}\\\\\nX2&\\rightarrow&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}1}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}\\end{smallmatrix}\n‚ûô\nZero Correlation\nThe parts highlighted in red depict the overlapping 1 bits. For\nMaximum Correlation\n‚ë†, the positions of overlapping ‚Äò1‚Äôs are aligned to the right for clarity, although they may occur randomly. For\nMinimum Correlation\n‚ë°, the overlapping ‚Äò1‚Äôs are minimum, causing 1s in the first and the second operand to be apart. Cross-correlation impacts the behavior of the CLB unit, enabling different functional outcomes\n[\n45\n,\n46\n]\n. For example, with\nZero Correlation\n‚ë¢, bit-wise\nAND\noperation between\nX\n‚Äã\n1\nX1\nand\nX\n‚Äã\n2\nX2\nyields the output\nY\n‚Üí\n0\n0\n0\n1\n0\n1\n0\n1\n\\begin{smallmatrix}Y&\\rightarrow&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}&{\\color[rgb]{0,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@color@gray@fill{0}0}&{\\color[rgb]{1,0,0}\\definecolor[named]{pgfstrokecolor}{rgb}{1,0,0}1}\\end{smallmatrix}\n. The expected\nf\nf\nfor zero-correlated input bit-streams supplied to the\nAND\ngate is\nf\nm\n‚Äã\nu\n‚Äã\nl\n=\nP\nX\n‚Äã\n1\n√ó\nP\nX\n‚Äã\n2\nf_{mul}=P_{X1}\\times P_{X2}\n. The probability of output\nY\nY\nis\n3\n8\n\\frac{3}{8}\n, validating the expected operation (i.e., multiplication):\nf\nm\n‚Äã\nu\n‚Äã\nl\n=\nP\nX\n‚Äã\n1\n√ó\nP\nX\n‚Äã\n2\n=\n4\n8\n√ó\n6\n8\n=\n3\n8\nf_{mul}=P_{X1}\\times P_{X2}=\\frac{4}{8}\\times\\frac{6}{8}=\\frac{3}{8}\n.\nHowever, the cases of\nMaximum\nand\nMinimum Correlation\nin ‚ë† and ‚ë° yield different output probability values after bit-wise\nAND\n:\nY\n‚Äã\n‚ë†\n=\n4\n8\nY\\textsubscript{\\char 172}=\\frac{4}{8}\nand\nY\n‚Äã\n‚ë°\n=\n2\n8\nY\\textsubscript{\\char 173}=\\frac{2}{8}\n. These varying correlations for bitwise\nAND\nelucidate different functions, such as\nf\n‚Äã\n‚ë†\n=\nmin\n‚Å°\n(\nP\nX\n‚Äã\n1\n,\nP\nX\n‚Äã\n2\n)\nf\\textsubscript{\\char 172}=\\min(P_{X1},P_{X2})\nand\nf\n‚Äã\n‚ë°\n=\nmax\n‚Å°\n(\n0\n,\nP\nX\n‚Äã\n1\n+\nP\nX\n‚Äã\n2\n‚àí\n1\n)\nf\\textsubscript{\\char 173}=\\max(0,P_{X1}+P_{X2}-1)\n. As demonstrated, correlation plays a crucial role in defining CLB behavior, underscoring the importance of the BSG unit. In this work, we significantly enhance the performance and hardware efficiency of SC-based transcendental function designs by revisiting the RNGs used in the BSG units.\nIII\nFrom Conventional to SC-based Transcendental Functions\nA key advantage of SC is its ability to perform complex arithmetic functions with simple and low-cost designs. This study proposes an efficient approach for implementing transcendental functions, with a focus on improving accuracy while reducing hardware cost compared to SOTA SC designs. Previous research has explored various methods for SC-based arithmetic, including piecewise-linear approximation\n[\n28\n]\n, FSM-based designs\n[\n16\n]\n, and polynomial factorization techniques\n[\n26\n]\n. More recent studies have\nemphasized the implementation of polynomial functions within CLB units, which are particularly advantageous for machine learning applications\n[\n43\n,\n12\n]\n. This work highlights the critical role of lightweight, high-quality BSG units, which indirectly affect the performance of CLBs.\nTranscendental functions play a critical role in diverse applications ranging from communication systems to computer vision\n[\n10\n,\n44\n,\n4\n]\n. SC becomes particularly important when robustness and hardware efficiency are the primary design objectives in implementing these functions. Among SOTA work, Parhi and Liu\n[\n33\n]\nexplored SC-based implementations of complex non-linear functions, including trigonometric, exponential, logarithm, hyperbolic tangent, and sigmoid, by leveraging the truncated Maclaurin series expansions. Alternative SC implementations of these functions have also been proposed using Chebyshev polynomials\n[\n19\n]\n, FSM\n[\n29\n]\n, and Bernstein Polynomials\n[\n36\n,\n32\n]\n.\nOther SOTA research has extended this domain to device-level designs beyond CMOS technology. For example, Chen et al.\n[\n9\n]\nemployed adiabatic quantum-flux parametron (AQFP) superconducting technology in conjunction with Bernstein Polynomial structures to realize transcendental functions.\nTo the best of our knowledge, our work is the first to incorporate quasi-randomness in the BSG units of SC designs, enabling more efficient SC-based implementations of transcendental functions.\nTABLE I:\nTruncated Maclaurin Series Expansions of Transcendental Functions Explored in This Study\nFunction\nPolynomial Equivalent\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\nx\n‚àí\nx\n3\n3\n!\n+\nx\n5\n5\n!\n‚àí\nx\n7\n7\n!\nx-\\frac{x^{3}}{3!}+\\frac{x^{5}}{5!}-\\frac{x^{7}}{7!}\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\n1\n‚àí\nx\n2\n2\n!\n+\nx\n4\n4\n!\n‚àí\nx\n6\n6\n!\n+\nx\n8\n8\n!\n1-\\frac{x^{2}}{2!}+\\frac{x^{4}}{4!}-\\frac{x^{6}}{6!}+\\frac{x^{8}}{8!}\ntan\n‚Å°\n(\nx\n)\n=\nsin\n‚Å°\n(\nx\n)\ncos\n‚Å°\n(\nx\n)\n\\tan(x)=\\frac{\\sin(x)}{\\cos(x)}\nx\n+\nx\n3\n3\n+\n2\n‚Äã\nx\n5\n15\n+\n17\n‚Äã\nx\n7\n315\nx+\\frac{x^{3}}{3}+\\frac{2x^{5}}{15}+\\frac{17x^{7}}{315}\ntanh\n‚Å°\n(\nx\n)\n\\tanh(x)\nx\n‚àí\nx\n3\n3\n+\n2\n‚Äã\nx\n5\n15\n‚àí\n17\n‚Äã\nx\n7\n315\nx-\\frac{x^{3}}{3}+\\frac{2x^{5}}{15}-\\frac{17x^{7}}{315}\narctan\n‚Å°\n(\nx\n)\n\\arctan(x)\nx\n‚àí\nx\n3\n3\n+\nx\n5\n5\n‚àí\nx\n7\n7\nx-\\frac{x^{3}}{3}+\\frac{x^{5}}{5}-\\frac{x^{7}}{7}\ns\n‚Äã\ni\n‚Äã\ng\n‚Äã\nm\n‚Äã\no\n‚Äã\ni\n‚Äã\nd\n‚Äã\n(\nx\n)\nsigmoid(x)\n1\n2\n+\nx\n4\n‚àí\nx\n3\n48\n+\nx\n5\n480\n\\frac{1}{2}+\\frac{x}{4}-\\frac{x^{3}}{48}+\\frac{x^{5}}{480}\nS\n‚Äã\ni\n‚Äã\nn\n‚Äã\nc\n‚Äã\n(\nx\n)\n=\nsin\n‚Å°\n(\nx\n)\nx\nSinc(x)=\\frac{\\sin(x)}{x}\n1\n‚àí\nx\n2\n3\n!\n+\nx\n4\n5\n!\n‚àí\nx\n6\n7\n!\n1-\\frac{x^{2}}{3!}+\\frac{x^{4}}{5!}-\\frac{x^{6}}{7!}\ne\n‚àí\nx\ne^{-x}\n1\n‚àí\nx\n+\nx\n2\n2\n!\n‚àí\nx\n3\n3\n!\n+\nx\n4\n4\n!\n‚àí\nx\n5\n5\n!\n1-x+\\frac{x^{2}}{2!}-\\frac{x^{3}}{3!}+\\frac{x^{4}}{4!}-\\frac{x^{5}}{5!}\nln\n‚Å°\n(\n1\n+\nx\n)\n\\ln(1+x)\nx\n‚àí\nx\n2\n2\n+\nx\n3\n3\n‚àí\nx\n4\n4\n+\nx\n5\n5\nx-\\frac{x^{2}}{2}+\\frac{x^{3}}{3}-\\frac{x^{4}}{4}+\\frac{x^{5}}{5}\nIn mathematics, transcendental functions‚Äìunlike algebraic functions‚Äìform a distinct class that cannot be expressed as a finite combination of algebraic operations such as addition, subtraction, multiplication, division, exponentiation, or root extraction. Common examples include\ntrigonometric\n(e.g.,\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\n),\nexponential\n(e.g.,\na\nx\na^{x}\n),\nlogarithmic\n(e.g.,\nlog\na\n‚Å°\nx\n\\log_{a}{x}\n), and\nhyperbolic\n(e.g.,\ntanh\n‚Å°\n(\nx\n)\n\\tanh(x)\n) functions. By contrast, expressions such as\nx\n3\n+\n1\nx^{3}+1\n,\n2\n‚Äã\nx\n‚àí\n3\nx\n+\n1\n\\frac{2x-3}{x+1}\n, and\nx\n5\n\\sqrt[5]{x}\nare classified as algebraic functions.\nOur approach significantly enhances the SC design of transcendental arithmetic functions, distinguishing it from existing SOTA solutions. We focus on hardware-efficient CMOS-based implementations for key functions such as\nùê¨ùê¢ùêß\n‚Äã\n(\nùê±\n)\n\\mathbf{sin(x)}\n,\nùêúùê®ùê¨\n‚Äã\n(\nùê±\n)\n\\mathbf{cos(x)}\n,\nùê≠ùêöùêß\n‚Äã\n(\nùê±\n)\n\\mathbf{tan(x)}\n,\nùêû\n‚Äã\n-\nx\n\\mathbf{e\\textsuperscript{{$-x$}}}\n,\nùê≠ùêöùêßùê°\n‚Äã\n(\nùê±\n)\n\\mathbf{tanh(x)}\n,\nùêöùê´ùêúùê≠ùêöùêß\n‚Äã\n(\nùê±\n)\n\\mathbf{arctan(x)}\n,\nùê¨ùê¢ùê†ùê¶ùê®ùê¢ùêù\n‚Äã\n(\nùê±\n)\n\\mathbf{sigmoid(x)}\n,\nùêíùê¢ùêßùêú\n‚Äã\n(\nùê±\n)\n\\mathbf{Sinc(x)}\n, and\nùê•ùêß\n‚Äã\n(\nùüè\n+\nùê±\n)\n\\mathbf{ln(1+x)}\n, leveraging the truncated Maclaurin series expansions and Horner‚Äôs rule\n[\n33\n,\n12\n]\n.\nThe Maclaurin series of a function\nf\n‚Äã\n(\nx\n)\nf(x)\nis a special case of the Taylor series centered at zero, expressed as\n‚àë\nn\n=\n0\n‚àû\nf\n(\nn\n)\nn\n!\n‚Äã\nx\nn\n\\sum_{n=0}^{\\infty}\\frac{f^{(n)}}{n!}x^{n}\n, where\nf\n(\nn\n)\nf^{(n)}\ndenotes the\nn\nn\n-th derivative of\nf\n‚Äã\n(\nx\n)\nf(x)\n. In what follows, we present approximate SC designs for the functions above using Horner‚Äôs rule. Table\nI\nlists the truncated Maclaurin series expansion for each function explored in this study.\nFigure 3:\nConventional designs of simple polynomial functions in SC, (a) Quadratic function (\nx\n2\nx^{2}\n), (b) Cubic function (\nx\n3\nx^{3}\n), (c) Quartic function (\nx\n4\nx^{4}\n), and (d) Quintic function (\nx\n5\nx^{5}\n).\nIII-A\nPolynomial Design in SC\nTo facilitate the design of complex transcendental functions, we start by implementing basic polynomial functions, including quadratic (\nx\n2\nx^{2}\n), cubic (\nx\n3\nx^{3}\n), quartic (\nx\n4\nx^{4}\n), quintic (\nx\n5\nx^{5}\n), and higher-order polynomials in SC. The quadratic function (\nx\n2\nx^{2}\n) can be implemented in SC by using a single\nAND\ngate combined with a decorrelator element (e.g., a one-bit shift register or a D-type flip-flop (\nD-FF\n)).\nSimilarly, the\nx\n3\nx^{3}\n,\nx\n4\nx^{4}\n, and\nx\n5\nx^{5}\nfunctions can be implemented using two, three, and four\nAND\ngates paired with two, three, and four delay elements, respectively, to ensure the necessary level of independence required at the input of each\nAND\ngate (see Section\nII\n). Figs.\n3\n(a)-(d) illustrate the circuit designs for these polynomial functions for the bit-stream length of\nN\n=\n8\nN=8\n.\nAs an example, to compute the polynomial values of\n0.875\n0.875\nwith a bit-stream length of 8, the corresponding bit-stream\nX\nt\n=\n11111101\nX_{t}=11111101\nis generated along with its one-bit shifted version\nX\nt\n‚àí\n1\n=\n11111011\nX_{t-1}=11111011\n. The resulting bit-stream (\nY\nY\n) represents the expected outcome of\n(\n0.87\n)\n2\n(0.87)^{2}\nas depicted in Fig.\n3\n(a). Higher-order polynomials are implemented in a similar manner by incrementally adding delay elements into the intermediate circuitry, as shown in Figs.\n3\n(b)-(d).\nBuilding on these foundational SC implementations of simple polynomials, we explore the design of more complex transcendental functions in the following section.\nThe polynomial order for each function is chosen to align with those used in conventional approaches to provide a fair comparison with our method.\nIV\nProposed Framework:\nTranSC\nOur proposed framework,\nTranSC\n, enhances the BSG unit, enabling modifications to CLBs for more efficient SC implementation of transcendental functions. While recent SOTA works have increasingly emphasized the design of configurable CLBs to support these functions‚Äìprimarily targeting the function blocks\n[\n43\n,\n12\n,\n33\n]\n‚Äìthe role of the BSG unit has often been overlooked. Most existing SC designs assume BSG units rely on pseudo-random sequences generated using LFSRs (Fig.\n4\n(a)). However, achieving high accuracy with short bit-streams‚Äìessential for low latency and energy-efficient processing‚Äìrequires innovative bit-stream generation techniques. LD sequence generators, such as Sobol\ngenerators\n[\n25\n,\n39\n,\n42\n]\n, offer promising alternatives by producing fast-converging quasi-random bit-streams, albeit with higher hardware cost (Fig.\n4\n(b)). The proposed\nTranSC\nframework adopts an alternative LD sequence to optimize the RNG block, thereby improving both design efficiency and accuracy. We demonstrate that properly employing novel LD sequences can significantly enhance hardware efficiency and computational accuracy.\nIn the next section, we introduce\nVan der Corput (VDC)\nsequences as a specific type of LD quasi-random sequences, along with a hardware-friendly implementation.\nFigure 4:\nThe overall design of the state-of-the-art RNGs (a) LFSR design (8-bit);\nmaximal length LFSR with polynomial\nx\n8\n+\nx\n7\n+\nx\n6\n+\n1\nx^{8}+x^{7}+x^{6}+1\nis demonstrated as an example\n, and (b) Sobol design.\nIV-A\nVan der Corput (VDC) Sequences\nVDC sequences are a class of random sequences widely studied in number and discrepancy theory, particularly recognized for their uniform distribution properties\n[\n41\n]\n. They are generated using the radical inverse function, defined for any base\n‚Ñ¨\n‚â•\n2\n\\mathcal{B}\\geq 2\n[\n34\n]\n. A defining feature of VDC sequences is their LD property, which ensures even coverage of the unit interval. This makes them particularly valuable in numerical integration, quasi-Monte Carlo methods, and applications in computer graphics and computational mathematics\n[\n40\n]\n. To construct a VDC sequence, natural numbers are mapped to the unit interval [0,1) through base\n‚Ñ¨\n\\mathcal{B}\nexpansions (denoted as VDC-\n‚Ñ¨\n\\mathcal{B}\n). Each term is obtained by reversing the digits of a natural number expressed in base\n‚Ñ¨\n\\mathcal{B}\n, then interpreting the reversed digits as a fractional value. This process guarantees the equidistribution property modulo one. For example, the decimal number 77 is represented as\n(\n302\n)\n5\n(302)_{5}\nin base-5. Reversing the digits yields\n(\n0.203\n)\n5\n=\n2\n√ó\n5\n‚àí\n1\n+\n0\n√ó\n5\n‚àí\n2\n+\n3\n√ó\n5\n‚àí\n3\n=\n53\n125\n=\n(\n0.424\n)\n10\n(0.203)_{5}=2\\times 5^{-1}+0\\times 5^{-2}+3\\times 5^{-3}=\\frac{53}{125}=(0.424)_{10}\n.\nIV-B\nVDC-\n2\nn\n2^{n}\n: An Accurate and Hardware-Friendly Case\nInspired by the general concept of VDC sequences, we employ a hardware-friendly variant with powers-of-2 radices (VDC-\n2\nn\n2^{n}\n) for the BSG unit.\nGenerating VDC-\n2\nn\n2^{n}\nsequences requires only a simple modulo-\nm\nm\nup counter, where\nm\n‚â•\nn\nm\\geq n\n. This up counter may operate in either asynchronous or synchronous mode. The binary output of this counter is partitioned into subgroups of\nn\nn\nbits; if the final subgroup contains fewer than\nn\nn\nbits, zero-padding is applied to ensure a complete\nn\nn\n-bit. These subgroups are then reordered through hardwiring, such that the least significant subgroup becomes the most significant, and vice versa. The resulting\nm\nm\n-bit binary number is subsequently mapped to the\n[\n0\n,\n1\n)\n[0,1)\ninterval, producing the desired VDC-\n2\nn\n2^{n}\nsequence.\nIntegrating VDC-\n2\nn\n2^{n}\ninto\nTranSC\nenables low-cost bit-stream generation using a simple\nlog\n2\n‚Å°\nN\n\\log_{2}{N}\n-bit up counter, where\nN\nN\ndenotes the bit-stream length. The counter output can be flexibly configured for any desired powers-of-2 radix. A key advantage of VDC-\n2\nn\n2^{n}\nis its flexibility: up to\nlog\n2\n‚Å°\nN\n\\log_{2}N\ndistinct and independent sequences can be generated simultaneously without additional hardware. Fig.\n5\n(a)-(d) illustrates the hardware design of VDC-2, VDC-4, VDC-8, and VDC-16, respectively. All designs share the same counter but differ in their hardwired reordering logic. By leveraging LD sequences in the form of VDC-\n2\nn\n2^{n}\n,\nTranSC\nachieves a lightweight and efficient BSG design, offering a compelling alternative to existing RNG designs for both the primary inputs and\nscalar coefficients in the mid-stages of transcendental functions implementation.\nFigure 5:\nThe overall designs of VDC-\n2\nn\n2^{n}\nRNGs using binary up counter (a) VDC-\n2\n2\n; reversing every single bit of the counter output,\n(b) VDC-\n4\n4\n; reversing every 2-bit subgroup of counter outputs, (c) VDC-\n8\n8\n; reversing every 3-bit subgroup of counter outputs, and (d) VDC-\n16\n16\n; reversing every 4-bit subgroup of counter outputs. All designs are considered as\nn\nn\n-bit precision - the same circuit is used with different hardwiring.\nFigure 6:\nProposed\nTranSC\nframework for transcendental functions: Eliminating the delay elements by utilizing efficient BSG units. (a)\nùê¨ùê¢ùêß\n‚Äã\n(\nùê±\n)\n\\mathbf{sin(x)}\n, (b)\nùêúùê®ùê¨\n‚Äã\n(\nùê±\n)\n\\mathbf{cos(x)}\n, (c)\nùê≠ùêöùêß\n‚Äã\n(\nùê±\n)\n\\mathbf{tan(x)}\n, (d)\nùê≠ùêöùêßùê°\n‚Äã\n(\nùê±\n)\n\\mathbf{tanh(x)}\n, (e)\nùêöùê´ùêúùê≠ùêöùêß\n‚Äã\n(\nùê±\n)\n\\mathbf{arctan(x)}\n, (f)\nùê¨ùê¢ùê†ùê¶ùê®ùê¢ùêù\n‚Äã\n(\nùê±\n)\n\\mathbf{sigmoid(x)}\n, (g)\nùêíùê¢ùêßùêú\n‚Äã\n(\nùê±\n)\n\\mathbf{Sinc(x)}\n, (h)\nùêû\n‚àí\nùê±\n\\mathbf{e^{-x}}\n, and (i)\nùê•ùêß\n‚Äã\n(\nùüè\n+\nùê±\n)\n\\mathbf{ln(1+x)}\n.\nTABLE II:\nAccuracy Evaluation of\nTranSC\nand SOTA Methods for Implementing Transcendental Functions-Part1\n(N: Bit-stream length)\nFunction\nDesign\nApproach\nN\nRNG Sources\nNo. of\nDelay Elements\nMSE\n(√ó10\n-4\n)\nInput\nCoefficients\n1\nst\nstage\n2\nnd\nstage\n3\nrd\nstage\n4\nth\nstage\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\nTranSC\n‚úΩ\n1024\n512\n256\n128\n64\nVDC-4\nVDC-128,256,512\nVDC-128,256,512\nVDC-128\nVDC-2,8,128\nVDC-2,8,8\n2\n0\n0\n0\n0.523\n0.582\n0.576\n0.967\n1.743\n[1pt/1pt]\nTranSC\n‚ú¶\n1024\n512\n256\n128\n64\nVDC-2\nVDC-1024\nVDC-512\nVDC-256\nVDC-128\nVDC-64\n1\n0\n0\n0\n0.888\n0.999\n1.221\n1.894\n5.373\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nSobol-1\nSobol-2\n3\n1\n1\n3\n3.133\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nSobol-1\nSobol-2\n1\n1\n1\n1\n0.917\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nLFSR1\nLFSR2\n3\n1\n1\n3\n2.256\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nLFSR1\nLFSR2\n1\n1\n1\n1\n5.036\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\nTranSC\n‚úΩ\n1024\n512\n256\n128\n64\nVDC-8\nVDC-8,4,16,256\nVDC-8,4,16,256\nVDC-8,4,16,256\nVDC-8,4,16,128\nVDC-8,4,16,64\n2\n0\n0\n0\n1.073\n1.087\n1.096\n1.119\n3.815\n[1pt/1pt]\nTranSC\n‚ú¶\n1024\n512\n256\n128\n64\nVDC-4\nVDC-16,4,8,32\n1\n0\n0\n0\n1.342\n1.374\n1.352\n1.678\n1.484\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nSobol-1\nSobol-2\n4\n1\n1\n1\n42.243\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nSobol-1\nSobol-2\n1\n1\n1\n1\n1.343\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nLFSR1\nLFSR2\n4\n1\n1\n1\n2.518\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nLFSR1\nLFSR2\n1\n1\n1\n1\n4.934\ntan\n‚Å°\n(\nx\n)\n\\tan(x)\nTranSC\n‚úΩ\n1024\n512\n256\n128\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\n:VDC-8\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\n:VDC-4\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\n:\nVDC-128,128,128\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\n:\nVDC-16,8,2,128\n3\n3\n0\n0\n0\n0\n1\n2\n0.721\n0.780\n1.099\n1.349\n[1pt/1pt]\nTranSC\n‚ú¶\n1024\n512\n256\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\n:VDC-32\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\n:VDC-8\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\n:\nVDC-256,256,16\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\n:\nVDC-256,256,256,256\n1\n1\n0\n0\n0\n0\n2\n0\n5.471\n3.938\n4.942\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\n:Sobol-1\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\n:Sobol-1\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\n:Sobol-2\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\n:Sobol-2\n3\n4\n1\n1\n1\n1\n1\n1\n124.403\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\n:Sobol-1\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\n:Sobol-1\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\n:Sobol-2\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\n:Sobol-2\n1\n1\n1\n1\n89.835\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\n:LFSR1\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\n:LFSR1\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\n:LFSR1\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\n:LFSR2\n3\n4\n1\n1\n1\n1\n3\n1\n9.845\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nLFSR1\nLFSR2\n1\n1\n1\n1\n4.564\ntanh\n‚Å°\n(\nx\n)\n\\tanh(x)\nTranSC\n‚úΩ\n1024\n512\n256\n128\n64\nVDC-16\nVDC-32,16,2\n3\n0\n0\n0\n2.881\n2.944\n3.273\n3.244\n5.800\n[1pt/1pt]\nTranSC\n‚ú¶\n1024\n512\n256\n128\n64\nVDC-2\nVDC-4,64,64\n1\n0\n0\n0\n3.164\n3.172\n3.190\n3.240\n3.392\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nSobol-1\nSobol-2\n3\n1\n1\n3\n7.731\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nSobol-1\nSobol-2\n1\n1\n1\n1\n2.390\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nLFSR1\nLFSR2\n3\n1\n1\n3\n6.579\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nLFSR1\nLFSR2\n1\n1\n1\n1\n12.548\n\\justify\n‚úΩ: Applying\nTranSC\nto the design of\n[\n33\n]\n, ‚ú¶: Applying\nTranSC\nto the design of\n[\n12\n]\n. Different VDC-\n2\nn\n2^{n}\nbases come from the same hardware source via simple hardwiring.\nTABLE III:\nAccuracy Evaluation of the\nTranSC\nand SOTA Methods for Implementing Transcendental Functions-Part2\n(N: Bit-stream length)\nFunction\nDesign\nApproach\nN\nRNG Sources\nNo. of\nDelay Elements\nMSE\n(√ó10\n-4\n)\nInput\nCoefficients\n1\nst\nstage\n2\nnd\nstage\n3\nrd\nstage\n4\nth\nstage\ns\n‚Äã\ni\n‚Äã\ng\n‚Äã\nm\n‚Äã\no\n‚Äã\ni\n‚Äã\nd\n‚Äã\n(\nx\n)\nsigmoid(x)\nTranSC\n‚úΩ\n1024\n512\n256\n128\n64\nVDC-1024\nVDC-512\nVDC-256\nVDC-2,4,32\n2\n0\n0\n-\n0.072\n0.099\n0.418\n2.109\n9.648\n[1pt/1pt]\nTranSC\n‚ú¶\n1024\n512\n256\n128\n64\nVDC-128\nVDC-4\n1\n0\n0\n-\n0.151\n0.152\n0.153\n0.187\n0.547\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nSobol-1\nSobol-2\n2\n1\n2\n-\n189.310\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nSobol-1\nSobol-2\n1\n1\n1\n-\n282.834\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nLFSR1\nLFSR2\n2\n1\n2\n-\n2.903\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nLFSR1\nLFSR2\n1\n1\n1\n-\n0.383\ne\ne\n‚àí\nx\n-x\nTranSC\n‚úΩ\n1024\n512\n256\n128\n64\nVDC-128\nVDC-128\nVDC-32\nVDC-8\nVDC-8\nVDC-16,1024,512,512\nVDC-128,512,512,512\nVDC-32,256,256,256\nVDC-64,128,128,128\nVDC-64,64,128,128\n0\n0\n0\n0\n3.032\n3.517\n2.508\n3.738\n2.391\n[1pt/1pt]\nTranSC\n‚ú¶\n1024\n512\n256\n128\n64\nVDC-32\nVDC-32\nVDC-32\nVDC-32\nVDC-32\nVDC-64\nVDC-64\nVDC-64\nVDC-4\nVDC-64\n0\n0\n0\n2\n1.730\n2.647\n3.412\n2.996\n2.871\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nSobol-1\nSobol-2\n1\n1\n1\n1\n22.231\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nSobol-1\nSobol-2\n1\n1\n1\n1\n21.210\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nLFSR1\nLFSR2\n1\n1\n1\n1\n9.331\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nLFSR1\nLFSR2\n1\n1\n1\n1\n6.807\narctan\n\\arctan\n(\nx\nx\n)\nTranSC\n‚úΩ\n1024\n512\n256\n128\n64\nVDC-8\nVDC-512,8,256\nVDC-512,8,256\nVDC-16,8,64\nVDC-128,8,64\nVDC-16,8,64\n2\n0\n0\n0\n0.835\n0.854\n2.544\n2.600\n3.271\n[1pt/1pt]\nTranSC\n‚ú¶\n1024\n512\n256\n128\n64\nVDC-4\nVDC-4,2,2\n1\n0\n0\n0\n1.733\n1.853\n1.678\n2.336\n2.006\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nSobol-1\nSobol-2\n3\n1\n1\n3\n8.028\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nSobol-1\nSobol-2\n1\n1\n1\n1\n2.327\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nLFSR1\nLFSR2\n3\n1\n1\n3\n1.947\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nLFSR1\nLFSR2\n1\n1\n1\n1\n7.518\nS\n‚Äã\ni\n‚Äã\nn\n‚Äã\nc\n‚Äã\n(\nx\n)\nSinc(x)\nTranSC\n‚úΩ\n1024\n512\n256\n128\n64\nVDC-8\nVDC-256,32,1024\nVDC-256,32,512\nVDC-256,32,256\nVDC-4,64,128\nVDC-4,8,64\n2\n0\n0\n-\n0.124\n0.186\n0.297\n0.386\n1.145\n[1pt/1pt]\nTranSC\n‚ú¶\n1024\n512\n256\n128\n64\nVDC-4\nVDC-512\nVDC-256\nVDC-128\nVDC-128\nVDC-64\n1\n0\n0\n-\n0.181\n0.258\n0.365\n0.416\n2.917\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nSobol-1\nSobol-2\n3\n1\n1\n-\n4.324\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nSobol-1\nSobol-2\n1\n1\n1\n-\n3.450\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nLFSR1\nLFSR2\n3\n1\n1\n-\n7.081\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nLFSR1\nLFSR2\n1\n1\n1\n-\n1.952\nln\n‚Å°\n(\n1\n+\nx\n)\n\\ln(1+x)\nTranSC\n‚úΩ\n1024\n512\n256\n128\n64\nVDC-64\nVDC-64\nVDC-16\nVDC-8\nVDC-4\nVDC-4,512,1024,512\nVDC-4,256,512,256\nVDC-64,128,2\nVDC-32,64,2\nVDC-8,32,2\n0\n0\n0\n0\n0.996\n2.482\n1.367\n3.470\n4.973\n[1pt/1pt]\nTranSC\n‚ú¶\n1024\n512\n256\n128\n64\nVDC-16\nVDC-16\nVDC-16\nVDC-16\nVDC-4\nVDC-32,64,256,256\nVDC-32,64,256,256\nVDC-32,64,256,256\nVDC-32,8,128,128\nVDC-2,32,64,64\n0\n0\n0\n0\n0.734\n1.023\n0.979\n2.277\n1.593\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nSobol-1\nSobol-2\n1\n1\n1\n1\n15.262\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nSobol-1\nSobol-2\n1\n1\n1\n1\n17.258\n[1pt/1pt]\nWork in\n[\n33\n]\n1024\nLFSR1\nLFSR2\n1\n1\n1\n1\n4.131\n[1pt/1pt]\nWork in\n[\n12\n]\n1024\nLFSR1\nLFSR2\n1\n1\n1\n1\n3.294\n\\justify\n‚úΩ: Applying\nTranSC\nto the design of\n[\n33\n]\n, ‚ú¶: Applying\nTranSC\nto the design of\n[\n12\n]\n. Different VDC-\n2\nn\n2^{n}\nbases come from the same hardware source via simple hardwiring.\nTABLE IV:\nHardware Cost Comparison of\nTranSC\nand SOTA Designs for Implementing Transcendental Functions\nFunctions\nN\nTranSC\n‚úΩ\nTranSC\n‚ú¶\nWork in\n[\n33\n]\nWork in\n[\n12\n]\nArea\n(\nŒº\n\\mu\nm\n2\n)\nCPL\n(ns)\nPower\n(\nŒº\n\\mu\nW)\nEnergy\n(pJ)\nArea\n(\nŒº\n\\mu\nm\n2\n)\nCPL\n(ns)\nPower\n(\nŒº\n\\mu\nW)\nEnergy\n(pJ)\nArea\n(\nŒº\n\\mu\nm\n2\n)\nCPL\n(ns)\nPower\n(\nŒº\n\\mu\nW)\nEnergy\n(pJ)\nArea\n(\nŒº\n\\mu\nm\n2\n)\nCPL\n(ns)\nPower\n(\nŒº\n\\mu\nW)\nEnergy\n(pJ)\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\ntanh\n‚Å°\n(\nx\n)\n\\tanh(x)\narctan\n‚Å°\n(\nx\n)\n\\arctan(x)\n‚ú†\n256\n512\n1024\n435\n497\n554\n0.42\n0.43\n0.44\n706.5\n759.7\n812.8\n76.0\n167.3\n366.2\n430\n487\n544\n0.42\n0.43\n0.44\n666.0\n740.6\n777.9\n71.6\n163.0\n350.5\n655\n734\n801\n0.39\n0.40\n0.42\n1965.3\n2092.7\n2178.2\n196.2\n428.6\n936.8\n618\n683\n757\n0.39\n0.40\n0.41\n1786.0\n1914.5\n2042.6\n178.3\n392.1\n857.6\ncos\n‚Å°\n(\nx\n)\n\\cos(x)\n256\n512\n1024\n489\n575\n632\n0.44\n0.46\n0.44\n761.7\n767.7\n829.8\n85.8\n180.8\n390.9\n479\n565\n621\n0.45\n0.46\n0.46\n705.5\n704.2\n780.5\n81.3\n165.8\n367.6\n723\n797\n883\n0.38\n0.39\n0.42\n2159.3\n2296.3\n2284.0\n210.0\n458.5\n982.3\n692\n766\n852\n0.41\n0.41\n0.42\n1887.5\n2041.6\n2180.8\n198.1\n402.3\n937.9\ntan\n‚Å°\n(\nx\n)\n\\tan(x)\n256\n512\n1024\n1286\n1513\n1630\n0.54\n0.54\n0.55\n1826.7\n1925.7\n1994.8\n252.5\n532.4\n1123.5\n1273\n1493\n1609\n0.53\n0.55\n0.53\n1783.6\n1860.8\n2040.9\n242.0\n524.0\n1107.6\n1728\n1924\n2092\n0.49\n0.49\n0.49\n3600.4\n4178.0\n4473.5\n451.6\n1048.2\n2244.6\n1653\n1850\n2018\n0.48\n0.45\n0.47\n3594.7\n4326.1\n4540.0\n441.7\n996.7\n2185.0\ns\n‚Äã\ni\n‚Äã\ng\n‚Äã\nm\n‚Äã\no\n‚Äã\ni\n‚Äã\nd\n‚Äã\n(\nx\n)\nsigmoid(x)\n256\n512\n1024\n490\n567\n628\n0.44\n0.45\n0.47\n739.8\n835.1\n858.9\n83.3\n192.4\n413.4\n480\n557\n618\n0.45\n0.45\n0.46\n671.0\n787.0\n830.0\n90.7\n181.3\n391.0\n707\n785\n852\n0.39\n0.40\n0.41\n1969.6\n2172.9\n2264.3\n222.5\n463.7\n989.0\n687\n764\n831\n0.38\n0.38\n0.40\n1921.4\n2267.3\n2355.8\n196.4\n463.6\n989.0\ne\ne\n‚àí\nx\n-x\n256\n512\n1024\n481\n537\n602\n0.43\n0.50\n0.46\n653.7\n613.0\n734.9\n72.0\n156.9\n346.2\n481\n537\n602\n0.43\n0.50\n0.46\n653.7\n613.0\n734.9\n72.0\n156.9\n346.2\n701\n778\n845\n0.37\n0.39\n0.40\n2064.0\n2195.5\n2302.2\n195.5\n438.9\n943.0\n701\n778\n845\n0.38\n0.39\n0.40\n1981.7\n2198.0\n2399.9\n192.8\n438.9\n983.0\nS\n‚Äã\ni\n‚Äã\nn\n‚Äã\nc\n‚Äã\n(\nx\n)\nSinc(x)\n256\n512\n1024\n432\n494\n554\n0.41\n0.42\n0.43\n742.6\n764.8\n809.7\n78.0\n164.5\n338.0\n422\n483\n544\n0.41\n0.42\n0.43\n682.2\n712.8\n767.7\n71.6\n153.3\n338.0\n619\n698\n757\n0.38\n0.40\n0.39\n1900.2\n1978.8\n2288.4\n184.9\n405.3\n958.0\n598\n678\n736\n0.37\n0.37\n0.39\n1842.5\n2039.5\n2154.1\n174.5\n407.2\n860.3\nln\n‚Å°\n(\n1\n+\nx\n)\n\\ln(1+x)\n256\n512\n1024\n475\n551\n608\n0.45\n0.45\n0.45\n620.6\n736.0\n744.6\n71.5\n169.6\n343.1\n475\n551\n608\n0.45\n0.45\n0.45\n620.6\n736.0\n744.6\n71.5\n169.6\n343.1\n699\n779\n846\n0.38\n0.41\n0.40\n1938.5\n2105.2\n2373.4\n193\n450.6\n972.1\n701\n779\n846\n0.38\n0.39\n0.40\n1983.3\n2256.5\n2332.0\n193\n450.6\n955.2\n\\justify\n‚úΩ and ‚ú¶ are the modification of Works in\n[\n33\n]\nand\n[\n12\n]\n, respectively\n. ‚ú†: The hardware design of these functions are the same; The coefficients are different. Power consumption is reported at the maximum frequency.\nParhi and Liu\n[\n33\n]\ninvestigated SC designs for implementing complex transcendental functions using polynomial approximations, where positive and negative coefficients were arranged in decreasing order for each polynomial function. Chu et al.\n[\n12\n]\nproposed a correlation-based SC implementation of polynomial functions with unipolar bit-streams. They introduced a\nNAND\n-\nAND\nstructure with fewer delay elements to realize trigonometric functions. Both approaches rely on Horner‚Äôs rule for polynomial evaluation.\nSimilarly, our proposed\nTranSC\napplies Horner‚Äôs rule to the Maclaurin series expansion of the target function.\nIn existing SOTA designs, two separate RNG units are used to generate independent bit-streams for inputs and coefficients. All coefficient bit-streams are generated from a shared RNG unit\n[\n33\n,\n12\n]\n. To decorrelate the intermediate bit-streams, these works employ additional delay elements (e.g.\nD-FFs\n). In contrast,\nTranSC\neliminates the need for such delay elements\nby leveraging the LD and distinct distribution properties of VDC-\n2\nn\n2^{n}\nsequences. This allows both input and coefficient bit-streams to be generated using a single VDC-\n2\nn\n2^{n}\nBSG unit, resulting in significant hardware cost reductions while maintaining accuracy and independence in intermediate computations.\nFig.\n6\npresents the set of transcendental functions implemented within the proposed\nTranSC\nframework. We revisit the CLB of prior SOTA designs by integrating our newly developed BSG inputs. In the revised designs, the delay blocks (previously required to decorrelate bit-streams) are either completely eliminated or significantly reduced. Figs.\n6\n(a) and\n6\n(b) illustrate the enhanced designs for\nùê¨ùê¢ùêß\n‚Äã\n(\nùê±\n)\n\\mathbf{sin(x)}\nand\nùêúùê®ùê¨\n‚Äã\n(\nùê±\n)\n\\mathbf{cos(x)}\nfunctions, respectively. The key distinctions between our design and the SOTA approaches are twofold: i) the use of a versatile, single-source quasi-random BSG unit based on VDC-\n2\nn\n2^{n}\nsequences, and ii) the removal of the mid-stage decorrelation blocks (e.g.,\nD-FF\ns), which reduces both hardware cost and computational latency.\nFor\nùê≠ùêöùêß\n‚Äã\n(\nùê±\n)\n\\mathbf{tan(x)}\n, shown in Fig.\n6\n(c), we utilize an efficient SC division circuit that derives results from\nùê¨ùê¢ùêß\n‚Äã\n(\nùê±\n)\n\\mathbf{sin(x)}\nand\nùêúùê®ùê¨\n‚Äã\n(\nùê±\n)\n\\mathbf{cos(x)}\n. This circuit integrates a correlator block (consisting of a down counter and an\nAND\ngate) and the CORDIV architecture\n[\n11\n]\n. Figs.\n6\n(d)-(i) depict the\nTranSC\ndesign of additional transcendental functions, including\nùê≠ùêöùêßùê°\n‚Äã\n(\nùê±\n)\n\\mathbf{tanh(x)}\n,\nùêöùê´ùêúùê≠ùêöùêß\n‚Äã\n(\nùê±\n)\n\\mathbf{arctan(x)}\n,\nùê¨ùê¢ùê†ùê¶ùê®ùê¢ùêù\n‚Äã\n(\nùê±\n)\n\\mathbf{sigmoid(x)}\n,\nùêíùê¢ùêßùêú\n‚Äã\n(\nùê±\n)\n\\mathbf{Sinc(x)}\n,\nùêû\n‚Äã\n-\nx\n\\mathbf{e\\textsuperscript{{$-x$}}}\n, and\nùê•ùêß\n‚Äã\n(\nùüè\n+\nùê±\n)\n\\mathbf{ln(1+x)}\n.\nV\nExperimental Results\nThe VDC-\n2\nn\n2^{n}\n-based BSG inherently exhibits quasi-randomness, providing the desired statistical independence between mid-level circuit elements without requiring additional decorrelation components.\nOur evaluation demonstrates that\nTranSC\nachieves significantly higher accuracy compared to SOTA designs. Tables\nII\nand\nIII\npresent a comparative accuracy analysis between\nTranSC\n-based and SOTA designs.\nFor the SOTA baselines, we used maximal period LFSRs (two LFSRs defined by the polynomials\nx\n10\n+\nx\n8\n+\nx\n6\n+\n1\nx^{10}+x^{8}+x^{6}+1\nand\nx\n10\n+\nx\n8\n+\nx\n5\n+\nx\n4\nx^{10}+x^{8}+x^{5}+x^{4}\n) and executed each operation\n1\n,\n000\n1,000\ntimes to ensure statistically significant results. Additionally, we tested the SOTA designs with Sobol sequences (generated using\nMATLAB\n‚Äôs built-in Sobol sequence generator), applied separately to the input and coefficient BSGs. However, incorporating these quasi-random sequences into SOTA designs degraded performance, as delay elements disrupted the independence properties of the sequences. Our findings indicate that when quasi-random RNGs are used in SC implementations of transcendental functions, delay elements must be minimized or eliminated to preserve independence.\nOwing to their substantial hardware cost, Sobol sequences were not adopted in\nTranSC\n.\nThe input BSGs in the\nTranSC\nframework are parameterized using different VDC-\n2\nn\n2^{n}\nconfigurations, as detailed in Tables\nII\nand\nIII\n. The coefficient BSG module generates bit-streams representing the function-specific coefficients for each transcendental function.\nFor each test case, we evaluate all possible input values within the\n[\n0\n,\nN\n]\n[0,N]\ninterval, corresponding to a\nlog\n2\n‚Å°\nN\n\\log_{2}N\n-bit precision. We explore multiple VDC-\n2\nn\n2^{n}\nsequences for both input and coefficient bit-streams and report the mean squared error (MSE) along with\nthe total number of decorrelating delay elements used in any stage of the circuit.\nAs shown, the\nTranSC\ndesigns eliminate all mid-level delay elements, unlike prior approaches.\nA key advantage of our methodology is its ability to maintain high\naccuracy even with significantly shorter bit-stream lengths. This is clearly demonstrated in Tables\nII\nand\nIII\n, where\nTranSC\noutperforms SOTA designs even when the bit-stream length is reduced to as low as\nN\n=\n64\nN=64\n.\nFurthermore, while existing designs require two separate BSGs (e.g., LFSR1/LFSR2 or Sobol-1/Sobol-2,as shown in Tables\nII\nand\nIII\n),\nTranSC\nachieves independence with a single BSG unit\neliminating the need for additional hardware.\nFor example, in\nTranSC\n-based design of\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\nfunction, VDC-128, VDC-256, and VDC-512 sequences are assigned to the coefficients\n1\n42\n\\frac{1}{42}\n,\n1\n20\n\\frac{1}{20}\n, and\n1\n6\n\\frac{1}{6}\n, respectively, when using\nN\n=\n1024\n,\n512\nN=1024,512\n(first and second rows of Table\nII\nfor\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\nfunction).\nWe compare the hardware costs of the proposed\nTranSC\nframework against SOTA designs for implementing various transcendental functions.\nWe synthesized all designs using Synopsys Design Compiler v2018.06 with the 45\nn\n‚Äã\nm\nnm\nFreePDK gate library.\nTable\nIV\nsummarizes the synthesis results in terms of area, critical path latency (CPL), power consumption at the maximum working frequency, and energy consumption for each design. As shown,\nTranSC\nconsistently outperforms the SOTA methods by utilizing a highly efficient BSG as the core of the SC architecture. By eliminating mid-stage delay elements and consolidating multiple BSGs into a single unit,\nTranSC\nachieves significant hardware efficiency gains. Specifically, the proposed designs reduce hardware area, power, and energy consumption by up to 33%, 72%, and 64%, respectively, while maintaining computational accuracy.\nFigure 7:\nAn overview of accuracy improvements: (a)\nTranSC\nover the work in\n[\n33\n]\nand (b)\nTranSC\nover the work in\n[\n12\n]\n.\nFigure 8:\nComparison of\nFigure of Merit\nmetric for different design approaches.\nVI\nProof of Concept\nVI-A\nPerformance Analysis\nBy incorporating distinct and independent BSGs, the proposed\nTranSC\nframework eliminates the need for decorrelator blocks (i.e., delay elements) in intermediate stages, thereby enhancing hardware efficiency compared to SOTA designs. Fig.\n7\nillustrates the accuracy improvements (y-axis) achieved by\nTranSC\nover SOTA implementations across various transcendental functions (x-axis), using a fixed bit-stream length of\nN\n=\n1024\nN=1024\n.\nTo further validate the effectiveness of the\nTranSC\ndesign, we evaluate the\nFigure of Merit (FoM)\n, a comprehensive metric that combines accuracy and hardware (HW) costs to reflect overall design efficiency. The\nFoM\nis defined as:\nF\n‚Äã\no\n‚Äã\nM\n=\nA\n‚Äã\nc\n‚Äã\nc\n‚Äã\nu\n‚Äã\nr\n‚Äã\na\n‚Äã\nc\n‚Äã\ny\nH\n‚Äã\nW\n‚Äã\nC\n‚Äã\no\n‚Äã\ns\n‚Äã\nt\n‚Äã\ns\n=\n1\nM\n‚Äã\nS\n‚Äã\nE\nA\n‚Äã\nr\n‚Äã\ne\n‚Äã\na\n√ó\nP\n‚Äã\no\n‚Äã\nw\n‚Äã\ne\n‚Äã\nr\n√ó\nL\n‚Äã\na\n‚Äã\nt\n‚Äã\ne\n‚Äã\nn\n‚Äã\nc\n‚Äã\ny\nFoM=\\frac{Accuracy}{HWCosts}=\\frac{\\frac{1}{MSE}}{Area\\times Power\\times Latency}\n(2)\nThis metric provides a unified basis for comparing different designs by jointly considering MSE, hardware footprint, power consumption, and latency.\nFig.\n8\npresents the\nFoM\nevaluation across various designs, using data extracted from Tables\nII\n,\nIII\n, and\nIV\n. As defined in Equation\n2\n, a higher\nFoM\nvalue indicates superior overall performance, achieved through a combination of higher computational accuracy and reduced hardware cost.\nVI-B\nWhy does VDC-\n2\nn\n2^{n}\nperform well?\nTo further explain why the\nTranSC\ndesigns‚Äìpowered by VDC-\n2\nn\n2^{n}\nsequences‚Äìoutperform the SOTA\nmethods; we evaluated the\nS\n‚Äã\nC\n‚Äã\nC\nSCC\n(Equation\n1\n) and the\nZero Correlation Error (\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\n)\nmetrics.\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\nquantifies the degree of independence between SC bit-streams, producing a value of zero for configurations that exhibit maximal independence\n[\n15\n]\n. It is formally defined as:\nZ\n‚Äã\nC\n‚Äã\nE\n=\nŒî\n‚ãÖ\n(\n1\n‚àí\nŒî\n0\nŒî\n)\nZCE=\\Delta\\cdot\\left(1-\\frac{\\Delta_{0}}{\\Delta}\\right)\n(3)\nwhere,\nŒî\n=\na\nN\n‚àí\n(\na\n+\nb\n)\n‚Äã\n(\na\n+\nc\n)\nN\n2\n\\Delta=\\frac{a}{N}-\\frac{(a+b)(a+c)}{N^{2}}\n, and\nŒî\n0\n=\n‚åä\n(\na\n+\nb\n)\n‚Äã\n(\na\n+\nc\n)\nN\n+\n1\n2\n‚åã\nN\n‚àí\n(\na\n+\nb\n)\n‚Äã\n(\na\n+\nc\n)\nN\n2\n\\Delta_{0}=\\frac{\\left\\lfloor\\frac{(a+b)(a+c)}{N}+\\frac{1}{2}\\right\\rfloor}{N}-\\frac{(a+b)(a+c)}{N^{2}}\n. Similar to the\nS\n‚Äã\nC\n‚Äã\nC\nSCC\nmetric, the values\na\na\n,\nb\nb\n,\nc\nc\n, and\nd\nd\nin the\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\nformulation represent the occurrence counts of logic pairs\n11\n11\n,\n10\n10\n,\n01\n01\n, and\n00\n00\n, respectively, obtained from corresponding bit positions of two bit-streams. Using both\nS\n‚Äã\nC\n‚Äã\nC\nSCC\nand\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\nmetrics, we evaluate the design performance through a representative case: the\nsin\n‚Å°\n(\nùê±\n)\n\\mathbf{\\sin(x)}\nfunction.\nFigs.\n9\n(a) and (b) compare the conventional method\n[\n33\n]\nwith the proposed\nTranSC\ndesign, highlighting the intermediate computational terms for each approach as follows:\ni\n1\n\\displaystyle i_{1}\n=\nX\n2\n\\displaystyle=X^{2}\n(4)\ni\n2\n\\displaystyle i_{2}\n=\n1\n‚àí\n1\n42\n‚Äã\ni\n1\n=\n1\n‚àí\n1\n42\n‚Äã\nX\n2\n\\displaystyle=1-\\frac{1}{42}i_{1}=1-\\frac{1}{42}X^{2}\ni\n3\n\\displaystyle i_{3}\n=\n1\n‚àí\n1\n20\n‚Äã\ni\n1\n‚Äã\ni\n2\n=\n1\n‚àí\n1\n20\n‚Äã\nX\n2\n‚Äã\n(\n1\n‚àí\n1\n42\n‚Äã\nX\n2\n)\n\\displaystyle=1-\\frac{1}{20}i_{1}i_{2}=1-\\frac{1}{20}X^{2}(1-\\frac{1}{42}X^{2})\ni\n4\n\\displaystyle i_{4}\n=\n1\n‚àí\n1\n6\n‚Äã\ni\n1\n‚Äã\ni\n3\n=\n1\n‚àí\n1\n6\n‚Äã\nX\n2\n‚Äã\n(\n1\n‚àí\n1\n20\n‚Äã\nX\n2\n‚Äã\n(\n1\n‚àí\n1\n42\n‚Äã\nX\n2\n)\n)\n.\n\\displaystyle=1-\\frac{1}{6}i_{1}i_{3}=1-\\frac{1}{6}X^{2}(1-\\frac{1}{20}X^{2}(1-\\frac{1}{42}X^{2})).\nFigure 9:\nMeasuring the independence level of intermediate bit-streams in\nùê¨ùê¢ùêß\n‚Äã\n(\nùê±\n)\n\\mathbf{sin(x)}\nfunction. (a) Conventional design\n[\n33\n]\n, (b)\nTranSC\ndesign, (c)\nS\n‚Äã\nC\n‚Äã\nC\nSCC\nmeasurement, and (d) ZCE measurement considering conventional and\nTranSC\napproaches for intermediate bit-streams of\ni\n1\ni_{1}\n,\ni\n2\ni_{2}\n,\ni\n3\ni_{3}\n, and\ni\n4\ni_{4}\n.\nFigure 10:\nTranSC\nuse cases: (a) 2D image transformation with visual markers, (b) Absolute angle error (\nE\n‚àò\nE^{\\circ}\n) and SIFT descriptor deviation (SIFT\nœÉ\n), (c) Two-joint arm kinematics, (d) Manipulator position estimation error (\nPErr\n).\nFig.\n9\n(c) presents the\nS\n‚Äã\nC\n‚Äã\nC\nSCC\nmeasurements‚Äìexpressed in terms of normalized probability‚Äìfor each intermediate bit-stream. To ensure fair comparison and consistency with the SOTA designs, we employed SC bit-streams of length\n1024\n1024\n, adhering to the design configurations specified in Table\nII\n. These measurements were obtained by evaluating all possible 10-bit precision input values within the\n[\n0\n,\n1\n]\n[0,1]\ninterval.\nIn the first intermediate stage (\ni\n1\ni_{1}\n), the conventional (SOTA) method exhibits at most\n20\n%\n20\\%\nzero correlation (\nS\n‚Äã\nC\n‚Äã\nC\n=\n0\nSCC=0\n), whereas the\nTranSC\ndesign consistently achieves minimum correlation (\nS\n‚Äã\nC\n‚Äã\nC\n=\n‚àí\n1\nSCC=-1\n) across all bit-streams.\nIn the second intermediate stage (\ni\n2\ni_{2}\n), the\nS\n‚Äã\nC\n‚Äã\nC\nSCC\nvalues for the conventional design are broadly distributed within the range of\n‚àí\n1\n-1\nto\n+\n1\n+1\n, indicating considerable dependency among bit-streams. Conversely, the\nTranSC\ndesign shows\nS\n‚Äã\nC\n‚Äã\nC\nSCC\nvalues tightly clustered around\n0\n, with minimal spread, demonstrating superior decorrelation between bit-streams in this stage.\nFor the third and fourth intermediate stages (\ni\n3\n,\ni\n4\ni_{3},i_{4}\n), the conventional design continues to show a wide\nS\n‚Äã\nC\n‚Äã\nC\nSCC\ndistribution‚Äìsome clustering near\n0\n, but with significant fluctuations throughout the full range of (\n‚àí\n1\n-1\nto\n+\n1\n+1\n). Meanwhile, the\nTranSC\ndesign maintains either perfect independence (\nS\n‚Äã\nC\n‚Äã\nC\n=\n0\nSCC=0\n) or minimum correlation (\nS\n‚Äã\nC\n‚Äã\nC\n=\n‚àí\n1\nSCC=-1\n) for the\ni\n3\ni_{3}\nand\ni\n4\ni_{4}\nstages.\nNotably, the\nS\n‚Äã\nC\n‚Äã\nC\nSCC\ntrends observed in the\nTranSC\ndesign align with those of\nthe conventional approach only when the latter explicitly uses decorrelator elements to enforce independence. The fluctuation patterns in the\nS\n‚Äã\nC\n‚Äã\nC\nSCC\nplots of the SOTA design are attributed to the inherent randomness and correlation drift in LFSR-based generators. In contrast, the\nTranSC\nframework‚Äìleveraging the LD nature of VDC sequences‚Äìavoids such inconsistencies and delivers stable inter-stream correlation properties.\nFig.\n9\n(d) illustrates the\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\nplots as an alternative metric for evaluating the independence between SC bit-streams in the intermediate stages of the\nsin\n‚Å°\n(\nùê±\n)\n\\mathbf{\\sin(x)}\nfunction designs.\nIn the first intermediate stage (\ni\n1\ni_{1}\n), the conventional design exhibits\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\nvalues that peak near\n0\nbut show a noticeable spread towards higher positive errors. In contrast, the\nTranSC\ndesign shows\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\nvalues tightly clustered around\n0\nwith minimal variation, indicating stronger independence.\nIn the second stage (\ni\n2\ni_{2}\n), the\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\nvalues for the conventional design span a wide range, with peaks near\n0\nbut substantial dispersion extending toward both positive and negative extremes. Meanwhile, the\nTranSC\ndesign maintains\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\nvalues closely centered around\n0\n, again with minimal deviation.\nFor the third stage (\ni\n3\ni_{3}\n), the conventional design exhibits an even broader\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\ndistribution, covering a wide spectrum of values. In contrast, the\nTranSC\ndesign retains a narrow\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\ndistribution concentrated near\n0\n, signifying better inter-stream decorrelation.\nFinally, in the fourth stage (\ni\n4\ni_{4}\n), the conventional design exhibits considerable variability in\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\nvalues, including peaks near\n0\nalong with significant outliers in both directions. In contrast, the\nTranSC\ndesign continues to show\nZ\n‚Äã\nC\n‚Äã\nE\nZCE\nvalues densely concentrated around\n0\n, with very limited deviation, highlighting its ability to maintain inter-stream independence consistently across all computation stages.\nThese analyses collectively validate the effectiveness of the proposed\nTranSC\ndesign, establishing it as a lightweight yet highly accurate solution for efficiently implementing transcendental functions with the SC paradigm. Building on this foundation, we next demonstrate the practical applicability of\nTranSC\nin real-world scenarios‚Äìintroducing SC-based designs, for the first time, to the domains of image transformation and robotics.\nVII\nUse-Case Studies\nIn this section, we evaluate the performance of the proposed\nTranSC\ndesign approach in two novel applications, explored for the first time in the SC literature: ‚ûÄ\n2D Image Transformation\nand ‚ûÅ\nRobot Arm Kinematics\n.\n2D Image Transformation\nis a fundamental operation widely employed in Quick Response (QR) code-based image rectification, with many applications in mobile robot navigation and camera posture calibration. These tasks often require computationally intensive trigonometric operations, demanding low-cost hardware implementations\n[\n35\n]\n. Fig.\n10\n(a) illustrates the square finder patterns of a QR code in a still image, which are used to determine the reference rotation angle.\nA typical QR code features three finder patterns located at the top-left, top-right, and bottom-left corners.\nThe diagonal line connecting these patterns (depicted in green) forms a 45\n‚àò\nangle with the\nx\nx\n-axis; any deviation\nŒ±\n\\alpha\nfrom this ideal angle signifies a rotation of the image.\nTo correct for such rotation, a transformation matrix\nT\nT\nis applied, which encapsulates common image manipulation operations such as translation, scaling, shear, reflection, and rotation. In particular, the rotation operations in\nT\nT\ninvolve\ntrigonometric\nfunctions such as\nsine\nand\ncosine\n. The inverse transformation\n1\nT\n\\frac{1}{T}\nis crucial in rectifying image orientation by compensating for any rotation angle\nŒ±\n\\alpha\n. Conventional QR code processing also employs the inverse of\nT\nT\nto reverse any rotation incurred during image acquisition, thereby restoring the image to its correct alignment.\nFig.\n10\n(a) illustrates the rotation-wise\nT\nT\nmatrix, which employs\nsine\nand\ncosine\noperations. The inverse operation is used to determine the corrected pixel positions\nx\n‚Äã\n_\n‚Äã\nc\n‚Äã\no\n‚Äã\nr\n‚Äã\nr\n‚Äã\ne\n‚Äã\nc\n‚Äã\nt\n‚Äã\ne\n‚Äã\nd\nx\\_corrected\nand\ny\n‚Äã\n_\n‚Äã\nc\n‚Äã\no\n‚Äã\nr\n‚Äã\nr\n‚Äã\ne\n‚Äã\nc\n‚Äã\nt\n‚Äã\ne\n‚Äã\nd\ny\\_corrected\n.\nFig.\n10\n(b) presents the evaluation metrics we use to assess the performance.\nAbsolute Angle Error\nassesses the performance of the SC designs (proposed and SOTA) compared to the reference binary model, based on the transformation angle error\nœµ\n\\epsilon\n. Following image correction,\nœµ\n\\epsilon\nindicates the deviation error from the expected angle, as depicted in Fig.\n10\n(a).\nSIFT Descriptor Deviation\nevaluates the deviation from scale-invariant feature transform (SIFT)-based descriptors. We compare the output images with reference images after transformation, and analyze the matched descriptors using the\n‚Ñí\n‚Äã\n1\n\\mathcal{L}1\nnorm to quantify average alterations when using the implemented designs in image transformation.\nWe also employ the SC-based\ntrigonometric\ndesigns\nin a\nrobotic kinematics\napplication. Fig.\n10\n(c) illustrates the operations for a 2-joint robotic arm involving a manipulator system with two links with lengths of\nL\n‚Äã\n1\nL1\nand\nL\n‚Äã\n2\nL2\n. The\nŒ±\n1\n\\alpha_{1}\nand\nŒ±\n2\n\\alpha_{2}\nangles define the movement ranges of links shown in green and red shaded regions in the\nx\n‚Äã\ny\nxy\n-coordinate. The manipulator edge point\n(\nx\n,\ny\n)\n(x,y)\nis estimated using the forward kinematics equations that involve\nsine\nand\ncosine\nfunctions.\nWhen SC operations are used for calculating edge positioning, we compare the estimated points\n(\nx\n‚àó\n,\ny\n‚àó\n)\n(x^{*},y^{*})\nwith the binary calculation as the reference to find the positioning error (\nPErr\n) in Fig.\n10\n(d).\nTABLE V:\nPerformance of\nTranSC\nin Different Use Cases\nDesign\nApproach\nUse-Case I: Image Orientation\nUse-Case II: Robotics Positioning\n[1pt/1pt]\nAngle Error (\nE\n‚àò\nE^{\\circ}\n) &¬†SIFT Deviation (SIFT\nœÉ\n)\nPosition Estimation Error (PErr)\nN=256\nN=512\nN=1024\nN=256\nN=512\nN=1024\nTranSC\n‚úΩ\nE\n‚àò\nE^{\\circ}\n:\n0.091\nSIFT\nœÉ\n:\n6.368\nE\n‚àò\nE^{\\circ}\n:\n0.084\nSIFT\nœÉ\n:\n6.367\nE\n‚àò\nE^{\\circ}\n:\n0.068\nSIFT\nœÉ\n:\n6.366\nPErr:\n0.158\nPErr:\n0.157\nPErr:\n0.155\n[1pt/1pt]\nTranSC\n‚ú¶\nE\n‚àò\nE^{\\circ}\n:\n0.177\nSIFT\nœÉ\n:\n6.457\nE\n‚àò\nE^{\\circ}\n:\n0.164\nSIFT\nœÉ\n:\n6.405\nE\n‚àò\nE^{\\circ}\n:\n0.163\nSIFT\nœÉ\n:\n6.373\nPErr:\n0.176\nPErr:\n0.174\nPErr:\n0.173\n[1pt/1pt]\nWork in\n[\n33\n]\nE\n‚àò\nE^{\\circ}\n: 0.386\nSIFT\nœÉ\n: 6.594\nE\n‚àò\nE^{\\circ}\n: 0.207\nSIFT\nœÉ\n: 6.531\nE\n‚àò\nE^{\\circ}\n: 0.178\nSIFT\nœÉ\n: 6.448\nPErr: 0.546\nPErr: 0.542\nPErr: 0.541\n[1pt/1pt]\nWork in\n[\n12\n]\nE\n‚àò\nE^{\\circ}\n: 0.858\nSIFT\nœÉ\n: 6.602\nE\n‚àò\nE^{\\circ}\n: 0.652\nSIFT\nœÉ\n: 6.597\nE\n‚àò\nE^{\\circ}\n: 0.493\nSIFT\nœÉ\n: 6.543\nPErr: 0.756\nPErr: 0.636\nPErr: 0.468\n\\justify\n‚úΩ:\nTranSC\napplied to the design of\n[\n33\n]\n, ‚ú¶:\nTranSC\napplied to the design of\n[\n12\n]\n. The best-performing BSGs from Table\nII\nare used for\nTranSC\n‚úΩ\nand\nTranSC\n‚ú¶\n.\nTable\nV\ndisplays the performance results for the two implemented use cases. For the first case, we examine a dataset of QR code images\n[\n37\n]\ncaptured in a real-world environment and report mean angle error and SIFT descriptor deviations. For the second use case, we analyze navigation ranges of links for all possible Cartesian pairs of\n(\nŒ±\n1\n,\nŒ±\n2\n)\n(\\alpha_{1},\\alpha_{2})\nand report the mean\nPErr\n. As it can be seen, across all test scenarios, our proposed architectures outperform\nthe SOTA designs for different bit-stream lengths from 256 to 1024.\nVIII\nDiscussion\nVIII-A\nComparison Against SOTA RNGs\nSobol sequences are well known for their excellent uniformity properties and strong performance for SC designs. Our argument for employing VDC-\n2\nn\n2^{n}\nsequences is not that they are universally more uniform, but rather that they are better suited to the architecture requirements of the\nTranSC\nframework. The primary objective of\nTranSC\nis to eliminate the mid-stage decorrelation elements (\nD-FF\ns), which have been a major source of hardware cost and latency in prior SOTA designs. We eliminate these elements by generating multiple, distinct, and statistically independent bit-streams for both the function inputs and polynomial coefficients from a\nsingle, shared hardware source\n.\nThe hardware architecture of the VDC-\n2\nn\n2^{n}\ngenerator‚Äîa simple up-counter with configurable bit-reversal hardwiring‚Äîis exceptionally lightweight. It can produce up to\nl\n‚Äã\no\n‚Äã\ng\n2\n‚Äã\nN\nlog_{2}N\ndistinct and independent sequences simultaneously with virtually zero additional hardware cost. In contrast, a Sobol sequence generator is far more complex, requiring an address generator, storage for direction vectors, and\nXOR\nlogic networks\n[\n25\n,\n31\n]\n. Generating multiple independent Sobol streams would necessitate either replicating this complex logic or employing even more complex multi-dimensional generators, both of which substantially increase hardware costs. By comparison, VDC-\n2\nn\n2^{n}\nsequences provide the\nTranSC\nframework with a highly efficient BSG unit at a fraction of the hardware cost of Sobol-based alternatives.\nThe results presented in Tables\nII\nand\nIII\ndemonstrate that the\nTranSC\ndesign achieves superior accuracy and stronger decorrelation, as reflected by lower SCC and ZCE values in Fig.\n9\n. These results validate that the uniformity provided by the VDC-\n2\nn\n2^{n}\nsequences is sufficient to ensure the required level of independence in the implemented designs.\nTable\nVI\ncompares the hardware cost of bit-stream generation across three approaches: an LFSR-based generator, an SOTA FSM-based Sobol generator, and a VDC-\n2\nn\n2^{n}\n-based bit-stream generator.\nThe results show that the VDC-based generator achieves about 28% and 14% smaller area, while consuming 24% and 43% less power than the FSM-based Sobol\n[\n5\n]\nand the LFSR-based bit-stream generator, respectively.\nThis hardware advantage becomes even more significant when multiple independent sequences are required, thereby justifying the choice of\nVDC-\n2\nn\n2^{n}\nas the core enabler of the lightweight\nTranSC\narchitecture.\nTABLE VI:\nHardware implementation cost of SC bit-stream generation considering 8-bit precision RNG sources\nRNG Type\nArea\n(\nŒº\n‚Äã\nm\n2\n\\mu m^{2}\n)\nPower@Max Freq.\n(\nŒº\n‚Äã\nW\n\\mu W\n)\nCPL\n(\nn\n‚Äã\ns\nns\n)\nLFSR\n233\n949.2\n0.37\nSobol-FSM\n[\n5\n]\n281\n720.4\n0.36\nVDC-\n2\nn\n2^{n}\n201\n544.4\n0.34\n\\justify\nThe maximal period with the polynomial\nx\n8\n+\nx\n6\n+\nx\n3\n+\nx\n2\nx^{8}+x^{6}+x^{3}+x^{2}\nis used for LFSR.\nVIII-B\nComparison Against Conventional Binary Designs\nVIII-B\n1\nTranSC\nvs. CORDIC\nThe CORDIC (Coordinate Rotation Digital Computer) algorithm\n[\n30\n]\nis a classic and widely-used ‚Äúshift-and-add‚Äù technique for computing transcendental functions, particularly efficient on hardware without dedicated multipliers, such as FPGAs or simple microcontrollers. As an iterative method, CORDIC‚Äôs latency scales with the required precision.\nTranSC\n‚Äôs accuracy and latency are determined by\nN\nN\n, while its hardware implementation comprises a BSG and simple combinational logic. The primary distinction lies in their target applications: CORDIC is well-suited for systems that demand high, guaranteed accuracy where iterative latency is acceptable. In contrast,\nTranSC\nis optimized for scenarios where ultra-low power, minimal hardware area, and high fault tolerance are the dominant design requirements, and where the inherent inaccuracy of SC is tolerable.\nThe presented use cases highlight domains where this trade-off proves especially advantageous.\nVIII-B\n2\nTranSC\nvs. Piecewise Polynomial Interpolation (PPI)\nPPI methods represent another major class of function evaluators. In these techniques, the input range is partitioned into smaller segments, and a low-degree polynomial, often stored as coefficients in a look-up table, is used to approximate the function within each segment. This approach can achieve high accuracy, often surpassing what is practical with SC-based methods, by increasing either the number of segments or the polynomial degree\n[\n20\n]\n.\nA comparison with\nTranSC\nhighlights a fundamental trade-off in hardware design. PPI methods rely on traditional binary arithmetic units (e.g., multipliers and adders) along with memory blocks, with hardware cost scaling with the required precision and polynomial complexity. By contrast,\nTranSC\n‚Äôs hardware is dominated by the BSG and simple bit-wise logic, offering a lightweight alternative.\nTable\nVII\nbenchmarks\nTranSC\nagainst CORDIC and a second-order PPI method for the\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\nfunction, with all designs targeting a 10-bit equivalent input precision.\nWhile CORDIC and PPI offer significantly higher accuracy (lower MSE), this comes at a substantial cost in hardware area and power consumption.\nTranSC\nis nearly\n12\n√ó\n12\\times\nand\n8\n√ó\n8\\times\nsmaller and consumes\n18\n√ó\n18\\times\nand\n7\n√ó\n7\\times\nless power than CORDIC and PPI designs, respectively. Its only drawback is energy consumption, a known limitation of SC designs due to the serial processing of bit-streams. However, this inefficiency can be substantially mitigated through parallelism.\nOverall, this quantitative comparison positions\nTranSC\nnot as a universal replacement for high-accuracy conventional binary methods, but as a competitive solution for a specific class of applications‚Äìthose that are severely resource-constrained and can tolerate modest accuracy trade-offs in exchange for significant gains in efficiency and robustness.\nTABLE VII:\nCross-Paradigm Performance and Resource Benchmark for\nsin\n‚Å°\n(\nx\n)\n\\sin(x)\nFunction with 10-bit Binary Precision\nMethodology\nArea\n(\nŒº\n‚Äã\nm\n2\n\\mu m^{2}\n)\nPower@Max\nFreq.\n(\nŒº\n‚Äã\nW\n\\mu W\n)\nCPL\n(\nn\n‚Äã\ns\nns\n)\nEnergy\n(\np\n‚Äã\nJ\npJ\n)\nMSE\n(\n√ó\n10\n‚àí\n4\n\\times 10^{-4}\n)\nCORDIC\n6562\n14500\n0.60\n8.7\n‚â™\n0.01\n\\ll 0.01\nPPI\n4419\n5500\n0.90\n4.9\n‚â™\n0.005\n\\ll 0.005\nTranSC\n554\n‚Üì\n\\downarrow\n812.8\n‚Üì\n\\downarrow\n0.44\n‚Üì\n\\downarrow\n366.2\n‚Üë\n\\uparrow\n0.523\n‚Üë\n\\uparrow\n\\justify\nCORDIC uses unrolled 10-iteration hardware implementation. PPI uses ROMs and multiplier-accumulator units designed for 2nd-order polynomials.\nIX\nConclusions\nThis work introduced a hardware-efficient methodology for implementing transcendental functions using SC with quasi-random Van der Corput (VDC) sequences. The proposed\nTranSC\nframework eliminates the need for decorrelator elements, thereby reducing both hardware cost and latency while achieving higher accuracy compared to state-of-the-art SC designs. We demonstrated the effectiveness of the approach through extensive evaluation across various functions, including two novel SC applications in robotics vision and maneuvering. The results show the potential of\nTranSC\nfor lightweight and efficient systems that rely on trigonometric and transcendental computations. Future work will explore the development of end-to-end SC architectures, particularly in neural networks, by incorporating our designs for non-linear functions such as sigmoid activations and logarithmic functions. These advancements could further extend the applicability of SC to emerging domains such as robotic learning and low-power AI systems.\nReferences\n[1]\nA. Alaghi and J. P. Hayes\n(2013)\nExploiting correlation in stochastic circuit design\n.\nIn\nICCD\n,\nVol.\n,\nAsheville, NC, USA\n,\npp.¬†39‚Äì46\n.\nExternal Links:\nDocument\nCited by:\n¬ßII\n.\n[2]\nA. Alaghi and J. P. Hayes\n(2013-05)\nSurvey of stochastic computing\n.\nACM Trans. Embed. Comput. Syst.\n12\n(\n2s\n).\nExternal Links:\nISSN 1539-9087\n,\nLink\n,\nDocument\nCited by:\n¬ßI\n,\n¬ßII\n.\n[3]\nJ. H. Anderson, Y. Hara-Azumi, and S. Yamashita\nEffect of lfsr seeding, scrambling and feedback polynomial on stochastic computing accuracy\n.\nIn\n2016 DATE\n,\nCited by:\n¬ßII\n.\n[4]\nS. Ankalaki and M. N. Thippeswamy\n(2023)\nA novel optimized parametric hyperbolic tangent swish activation function for 1d-cnn: application of sensor-based human activity recognition and anomaly detection\n.\nMultimedia Tools and Applications\n.\nCited by:\n¬ßIII\n.\n[5]\nS. Asadi, M. H. Najafi, and M. Imani\n(2021)\nA low-cost fsm-based bit-stream generator for low-discrepancy stochastic computing\n.\nIn\n2021 Design, Automation & Test in Europe Conference & Exhibition (DATE)\n,\nVol.\n,\npp.¬†908‚Äì913\n.\nExternal Links:\nDocument\nCited by:\n¬ß\nVIII-A\n,\nTABLE VI\n.\n[6]\nS. Aygun, E. O. Gunes, and C. De Vleeschouwer\n(2021)\nEfficient and robust bitstream processing in binarised neural networks\n.\nElectronics Letters\n57\n(\n5\n),\npp.¬†219‚Äì222\n.\nCited by:\n¬ßI\n.\n[7]\nS. Aygun, M. S. Moghadam, and M. H. Najafi\n(2024)\nLate Breaking Results: TriSC: Low-Cost Design of Trigonometric Functions with Quasi Stochastic Computing\n.\nIn\nProceedings of the 61st ACM/IEEE Design Automation Conference\n,\nDAC‚Äô24\n,\n.\nExternal Links:\nISBN 9798400706011\n,\nLink\n,\nDocument\nCited by:\nTranSC: Hardware-Aware Design of Transcendental Functions Using Stochastic Logic\n.\n[8]\nT. J. Baker and J. P. Hayes\n(2022)\nCeMux: maximizing the accuracy of stochastic mux adders and an application to filter design\n.\nACM TODAES\n27\n(\n3\n).\nExternal Links:\nISSN 1084-4309\nCited by:\n¬ßII\n.\n[9]\nO. Chen, R. Zhang, W. Luo, Y. Wang, and N. Yoshikawa\n(2024)\nExtremely energy-efficient non-linear function approximation framework using stochastic superconductor devices\n.\nIEEE Transactions on Emerging Topics in Computing\n12\n(\n4\n),\npp.¬†956‚Äì967\n.\nExternal Links:\nDocument\nCited by:\n¬ßIII\n.\n[10]\nR. Chen, L. Hei, and Y. Lai\n(2023)\nObject detection in optical imaging of the internet of things based on deep learning\n.\nPeerJ Comp. Sc.\n9\n,\npp.¬†e1718\n.\nCited by:\n¬ßIII\n.\n[11]\nT. Chen and J. P. Hayes\n(2016)\nDesign of division circuits for stochastic computing\n.\nIn\nISVLSI\n,\nVol.\n,\npp.¬†116‚Äì121\n.\nExternal Links:\nDocument\nCited by:\n¬ß\nIV-B\n.\n[12]\nS. Chu, C. Wu, T. N. Nguyen, and B. Liu\n(2022)\nPolynomial computation using unipolar stochastic logic and correlation technique\n.\nIEEE TC\n71\n(\n6\n),\npp.¬†1358‚Äì1373\n.\nExternal Links:\nDocument\nCited by:\n¬ßI\n,\n¬ßIII\n,\n¬ßIII\n,\n¬ß\nIV-B\n,\n¬ß\nIV-B\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE IV\n,\nTABLE IV\n,\n¬ßIV\n,\nFigure 7\n,\nTABLE V\n,\nTABLE V\n.\n[13]\nS. Chu\n(2020)\nNew divider design for stochastic computing\n.\nIEEE TCAS II\n67\n(\n1\n),\npp.¬†147‚Äì151\n.\nExternal Links:\nDocument\nCited by:\n¬ßII\n.\n[14]\nA. M. Dalloo, A. J. Humaidi, A. K. A. Mhdawi, and H. Al-Raweshidy\n(2024)\nLow-power and low-latency hardware implementation of approximate hyperbolic and exponential functions for embedded system applications\n.\nIEEE Access\n12\n(\n),\npp.¬†24151‚Äì24163\n.\nExternal Links:\nDocument\nCited by:\n¬ßI\n.\n[15]\nH. Hsiao, J. S. Miguel, Y. Hara-Azumi, and J. Anderson\n(2021)\nZero correlation error: a metric for finite-length bitstream independence in stochastic computing\n.\nIn\n26th Asia and South Pacific Design Automation Conf.\n,\nASPDAC ‚Äô21\n,\npp.¬†260‚Äì265\n.\nCited by:\n¬ß\nVI-B\n.\n[16]\nL. Huai, P. Li, G. E. Sobelman, and D. J. Lilja\n(2017)\nStochastic computing implementation of trigonometric and hyperbolic functions\n.\nIn\nIEEE 12th ASICON\n,\nVol.\n,\npp.¬†553‚Äì556\n.\nExternal Links:\nDocument\nCited by:\n¬ßIII\n.\n[17]\nH. Joe and Y. Kim\n(2019)\nNovel stochastic computing for energy-efficient image processors\n.\nElectronics\n8\n(\n6\n).\nExternal Links:\nLink\n,\nISSN 2079-9292\n,\nDocument\nCited by:\n¬ßI\n.\n[18]\nA. Khataei, G. Singh, and K. Bazargan\n(2024)\nSimBU: self-similarity-based hybrid binary-unary computing for nonlinear functions\n.\nIEEE TC\n73\n(\n9\n),\npp.¬†2192‚Äì2205\n.\nExternal Links:\nDocument\nCited by:\n¬ßI\n.\n[19]\nA. Kind\n(2025)\nApproximation of general functions using stochastic computing\n.\nElectronics\n14\n(\n9\n).\nExternal Links:\nLink\n,\nISSN 2079-9292\n,\nDocument\nCited by:\n¬ßIII\n.\n[20]\nD. Lee, R. Cheung, W. Luk, and J. Villasenor\n(2008)\nHardware implementation trade-offs of polynomial approximations and interpolations\n.\nIEEE Transactions on Computers\n57\n(\n5\n),\npp.¬†686‚Äì701\n.\nExternal Links:\nDocument\nCited by:\n¬ß\nVIII-B\n2\n.\n[21]\nA. Li, S. L. Song, M. Wijtvliet, A. Kumar, and H. Corporaal\n(2016)\nSFU-driven transparent approximation acceleration on gpus\n.\nIn\nProceedings of the 2016 International Conference on Supercomputing\n,\nICS ‚Äô16\n,\nNew York, NY, USA\n.\nExternal Links:\nISBN 9781450343619\n,\nLink\n,\nDocument\nCited by:\n¬ßI\n.\n[22]\nH. Li and Y. Chen\n(2024-03)\nHybrid stochastic number and its neural network computation\n.\nIEEE TVLSI\n32\n(\n03\n),\npp.¬†432‚Äì441\n.\nExternal Links:\nISSN 1557-9999\n,\nDocument\nCited by:\n¬ßI\n.\n[23]\nS. Liu, J. L. Rossell√≥, S. Liu, X. Tang, J. Font-Rossell√≥, C. F. Frasser, W. Qian, J. Han, P. Reviriego, and F. Lombardi\n(2024)\nFrom multipliers to integrators: a survey of stochastic computing primitives\n.\nIEEE TNANO.\n23\n(\n),\npp.¬†238‚Äì249\n.\nExternal Links:\nDocument\nCited by:\n¬ßI\n.\n[24]\nS. Liu, W. J. Gross, and J. Han\n(2020)\nIntroduction to dynamic stochastic computing\n.\nIEEE Circuits and Systems Magazine\n20\n(\n3\n),\npp.¬†19‚Äì33\n.\nExternal Links:\nDocument\nCited by:\n¬ßI\n.\n[25]\nS. Liu and J. Han\n(2018)\nToward energy-efficient stochastic circuits using parallel sobol sequences\n.\nIEEE TVLSI\n26\n(\n7\n),\npp.¬†1326‚Äì1339\n.\nExternal Links:\nDocument\nCited by:\n¬ßI\n,\n¬ßIV\n,\n¬ß\nVIII-A\n.\n[26]\nY. Liu and K. K. Parhi\n(2016)\nComputing complex functions using factorization in unipolar stochastic logic\n.\nIn\n,\nGLSVLSI ‚Äô16\n,\nNew York, NY, USA\n,\npp.¬†109‚Äì112\n.\nExternal Links:\nISBN 9781450342742\n,\nLink\n,\nDocument\nCited by:\n¬ßIII\n.\n[27]\nY. Liu and K. K. Parhi\n(2017-04)\nComputing polynomials using unipolar stochastic logic\n.\nJ. Emerg. Technol. Comput. Syst.\n13\n(\n3\n).\nExternal Links:\nISSN 1550-4832\n,\nLink\n,\nDocument\nCited by:\n¬ßI\n.\n[28]\nT. Luong, V. Nguyen, A. Nguyen, and E. Popovici\n(2019)\nEfficient architectures and implementation of arithmetic functions approximation based stochastic computing\n.\nIn\nIEEE ASAP\n,\npp.¬†281‚Äì287\n.\nExternal Links:\nDocument\nCited by:\n¬ßIII\n.\n[29]\nC. Ma and D. J. Lilja\n(2018)\nParallel implementation of finite state machines for reducing the latency of stochastic computing\n.\nIn\n19th ISQED\n,\nVol.\n,\npp.¬†335‚Äì340\n.\nExternal Links:\nDocument\nCited by:\n¬ßIII\n.\n[30]\nP. K. Meher, J. Valls, T. Juang, K. Sridharan, and K. Maharatna\n(2009)\n50 years of cordic: algorithms, architectures, and applications\n.\nIEEE Transactions on Circuits and Systems I: Regular Papers\n56\n(\n9\n),\npp.¬†1893‚Äì1907\n.\nExternal Links:\nDocument\nCited by:\n¬ß\nVIII-B\n1\n.\n[31]\nM. H. Najafi, D. Jenson, D. J. Lilja, and M. D. Riedel\n(2019)\nPerforming stochastic computation deterministically\n.\nIEEE TVLSI\n27\n(\n12\n),\npp.¬†2925‚Äì2938\n.\nExternal Links:\nDocument\nCited by:\n¬ßII\n,\n¬ß\nVIII-A\n.\n[32]\nV. Nguyen, T. Luong, E. Popovici, Q. Trinh, R. Zhang, and Y. Nakashima\n(2021)\nAn accurate and compact hyperbolic tangent and sigmoid computation based stochastic logic\n.\nIn\nIEEE MWSCAS\n,\nVol.\n,\npp.¬†386‚Äì390\n.\nExternal Links:\nDocument\nCited by:\n¬ßIII\n.\n[33]\nK. K. Parhi and Y. Liu\n(2019)\nComputing arithmetic functions using stochastic logic by series expansion\n.\nIEEE TETC\n7\n(\n1\n),\npp.¬†44‚Äì59\n.\nExternal Links:\nDocument\nCited by:\n¬ßI\n,\n¬ßIII\n,\n¬ßIII\n,\n¬ß\nIV-B\n,\n¬ß\nIV-B\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE II\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE III\n,\nTABLE IV\n,\nTABLE IV\n,\n¬ßIV\n,\nFigure 7\n,\nFigure 9\n,\n¬ß\nVI-B\n,\nTABLE V\n,\nTABLE V\n.\n[34]\nF. Pausinger and A. Topuzoƒülu\n(2018)\nOn the discrepancy of two families of permuted van der corput sequences\n.\nUniform distribution theory\n13\n(\n1\n),\npp.¬†47‚Äì64\n.\nExternal Links:\nDocument\nCited by:\n¬ß\nIV-A\n.\n[35]\nM. R. Pedersen, L. Nalpantidis, R. S. Andersen, C. Schou, S. B√∏gh, V. Kr√ºger, and O. Madsen\n(2016)\nRobot skills for manufacturing: from concept to industrial deployment\n.\nRobotics and Computer-Integrated Manufacturing\n37\n,\npp.¬†282‚Äì291\n.\nExternal Links:\nISSN 0736-5845\n,\nDocument\nCited by:\n¬ßVII\n.\n[36]\nW. Qian, X. Li, M. D. Riedel, K. Bazargan, and D. J. Lilja\n(2011-01)\nAn Architecture for Fault-Tolerant Computation with Stochastic Logic\n.\nComputers, IEEE Trans. on\n60\n(\n1\n),\npp.¬†93‚Äì105\n.\nExternal Links:\nDocument\n,\nISSN 0018-9340\nCited by:\n¬ßIII\n.\n[37]\nI. Szentandr√°si, A. Herout, and M. Dubsk√°\n(2012)\nFast detection and recognition of qr codes in high-resolution images\n.\nIn\nConf. on Comp. Graph.\n,\nSCCG‚Äô12\n.\nCited by:\n¬ßVII\n.\n[38]\nN. Temenos and P. P. Sotiriadis\n(2022)\nModeling a stochastic computing nonscaling adder and its application in image sharpening\n.\nIEEE TCAS II\n69\n(\n5\n),\npp.¬†2543‚Äì2547\n.\nExternal Links:\nDocument\nCited by:\n¬ßI\n.\n[39]\nN. Temenos and P. P. Sotiriadis\n(2023)\nA stochastic computing sigma-delta adder architecture for efficient neural network design\n.\nIEEE J. on Emerging and Sel. Topics in Circ. and Sys.\n13\n(\n1\n),\npp.¬†285‚Äì294\n.\nExternal Links:\nDocument\nCited by:\n¬ßIV\n.\n[40]\nV. Todorov, T. Ostromsky, I. Dimov, and S. Fidanova\n(2020-09)\nOptimized quasi-monte carlo method based on low discrepancy sequences for sensitivity analysis in air pollution modelling\n.\npp.¬†25‚Äì28\n.\nExternal Links:\nDocument\nCited by:\n¬ß\nIV-A\n.\n[41]\nJ. G. van der Corput\n(1935)\nVerteilungsfunktionen. I\n.\nProc. Akad. Wet. Amsterdam\n38\n,\npp.¬†813‚Äì821\n(\nGerman\n).\nExternal Links:\nISSN 0370-0348\nCited by:\n¬ß\nIV-A\n.\n[42]\nJ. Wang, H. Chen, D. Wang, K. Mei, S. Zhang, and X. Fan\n(2023)\nA noise-driven heterogeneous stochastic computing multiplier for heuristic precision improvement in energy-efficient dnns\n.\nIEEE TCAD\n42\n(\n2\n),\npp.¬†630‚Äì643\n.\nExternal Links:\nDocument\nCited by:\n¬ßIV\n.\n[43]\nS. Wang, G. Xie, X. Cheng, and Y. Zhang\n(2022)\nWeighted-adder-based polynomial computation using correlated unipolar stochastic bitstreams\n.\nIEEE TCAS II\n69\n(\n11\n),\npp.¬†4528‚Äì4532\n.\nExternal Links:\nDocument\nCited by:\n¬ßI\n,\n¬ßIII\n,\n¬ßIV\n.\n[44]\nZ. Wang, Z. Xu, D. He, and S. Chan\n(2021-08-01)\nDeep logarithmic neural network for internet intrusion detection\n.\nSoft Computing\n25\n(\n15\n),\npp.¬†10129‚Äì10152\n.\nCited by:\n¬ßIII\n.\n[45]\nD. Wu, R. Yin, and J. S. Miguel\n(2021)\nIn-stream correlation-based division and bit-inserting square root in stochastic computing\n.\nIEEE Design & Test\n38\n(\n6\n),\npp.¬†53‚Äì59\n.\nExternal Links:\nDocument\nCited by:\n¬ßII\n.\n[46]\nQ. Zhang, Y. Chen, S. Li, X. Zeng, and K. K. Parhi\n(2020)\nA high-performance stochastic ldpc decoder architecture designed via correlation analysis\n.\nIEEE TCAS I\n67\n(\n12\n),\npp.¬†5429‚Äì5442\n.\nExternal Links:\nDocument\nCited by:\n¬ßII\n.\n[47]\nH. Zhou, S. P. Khatri, J. Hu, and F. Liu\n(2020)\nScaled population arithmetic for efficient stochastic computing\n.\nIn\n2020 25th ASP-DAC\n,\nCited by:\n¬ßI\n.\nMehran Moghadam\n(S‚Äô22) received his B.Sc. degree in Computer Engineering, and M.Sc. degree in\nComputer Systems Architecture\nfrom the University of Isfahan, Iran, in 2010 and 2016. He graduated as one of the top-ranking students in both programs.\nIn 2022, he began his Ph.D. studies in Computer Engineering at the School of Computing and Informatics, University of Louisiana at Lafayette, Lafayette, LA, USA. In 2024, he transferred to the Electrical, Computer, and Systems Engineering department at Case Western Reserve University, Cleveland, OH, USA, to continue pursuing his Ph.D. in Computer Engineering.\nMehran became a finalist in the ACM SIGBED Student Research Competition (SRC) at ESWEEK and ICCAD in 2024 and was selected as a DAC Young Fellow in DAC 2024. His research interests include emerging and unconventional computing paradigms, such as energy-efficient stochastic computing models, real-time and high-accuracy hyperdimensional computing systems, bit-stream processing, robust in-memory arithmetic computation, and low-power in/near-sensor computing designs for edge AI.\nSercan Aygun\n(S‚Äô09-M‚Äô22-SM‚Äô24) received a B.Sc. degree in Electrical & Electronics Engineering and a double major in Computer Engineering from Eskisehir Osmangazi University, Turkey, in 2013. He completed his M.Sc. degree in Electronics Engineering from Istanbul Technical University in 2015 and a second M.Sc. degree in Computer Engineering from Anadolu University in 2016. Dr. Aygun received his Ph.D. in Electronics Engineering from Istanbul Technical University in 2022. Dr. Aygun received the Best Scientific Research Award of the ACM SIGBED Student Research Competition (SRC) ESWEEK 2022, the Best Paper Award at GLSVLSI‚Äô23, and the Best Poster Award at GLSVLSI‚Äô24. Dr. Aygun‚Äôs Ph.D. work was recognized with the Best Scientific Application Ph.D. Award by the Turkish Electronic Manufacturers Association and was also ranked first nationwide in the Science and Engineering Ph.D. Thesis Awards by the Turkish Academy of Sciences. He is currently an Assistant Professor at the School of Computing and Informatics, University of Louisiana at Lafayette, Lafayette, LA, USA. He works on tiny machine learning and emerging computing, including stochastic and hyperdimensional computing.\nM. Hassan Najafi\n(S‚Äô15-M‚Äô18-SM‚Äô23) received the B.Sc. degree in Computer Engineering from the University of Isfahan, Iran, the M.Sc. degree in Computer Architecture from the University of Tehran, Iran, and the Ph.D. degree in Electrical Engineering from University of Minnesota, Twin Cities, USA, in 2011, 2014, and 2018, respectively. He was an Assistant Professor at the School of Computing and Informatics, University of Louisiana at Lafayette, Lafayette, LA, USA, from 2018 to 2024. He is currently an Associate Professor at the Electrical, Computer, and Systems Engineering Department at Case Western Reserve University, Cleveland, OH, USA. His research interests include stochastic and approximate computing, unary processing, in-memory computing, and hyperdimensional computing. He has authored/co-authored more than 80 peer-reviewed papers and has been granted 6 U.S. patents, with more pending. Dr. Najafi received the NSF CAREER Award in 2024, the Best Paper Award at GLSVLSI‚Äô23 and ICCD‚Äô17, the Best Poster Award at GLSVLSI‚Äô24, the 2018 EDAA Outstanding Dissertation Award, and the Doctoral Dissertation Fellowship from the University of Minnesota. Dr. Najafi has been an editor for the IEEE Journal on Emerging and Selected Topics in Circuits and Systems and a Technical Program Committee Member for many EDA conferences.",
    "preview_text": "The hardware-friendly implementation of transcendental functions remains a longstanding challenge in design automation. These functions, which cannot be expressed as finite combinations of algebraic operations, pose significant complexity in digital circuit design. This study introduces a novel approach, TranSC, that utilizes stochastic computing (SC) for lightweight yet accurate implementation of transcendental functions. Building on established SC techniques, our method explores alternative random sources-specifically, quasi-random Van der Corput low-discrepancy (LD) sequences-instead of conventional pseudo-randomness. This shift enhances both the accuracy and efficiency of SC-based computations. We validate our approach through extensive experiments on various function types, including trigonometric, hyperbolic, and activation functions. The proposed design approach significantly reduces MSE by up to 98% compared to the state-of-the-art solutions while reducing hardware area, power consumption, and energy usage by 33%, 72%, and 64%, respectively.\n\nTranSC: Hardware-Aware Design of Transcendental Functions Using Stochastic Logic\nIEEE Publication Technology\nThis paper was produced by the IEEE Publication Technology Group. They are in Piscataway, NJ.Manuscript received April 19, 2021; revised August 16, 2021.\nMehran¬†Moghadam\nID\n,¬†, Sercan¬†Aygun\nID\n,¬†, and\nM.¬†Hassan¬†Najafi\nID\n,\nThis work is supported in part by National Science Foundation (NSF) under grants #2019511, #2339701, NASA grant 80NSSC25C0335, and generous gifts from NVIDIA.\nMehran Moghadam and M. Hassan Najafi are with the Electrical, Computer, and Systems Engineering Department, Case Western Reserve University, Cleveland, OH, USA.\nE-mail:{moghadam, najafi}@case.edu. Sercan Aygun is with the School of Computing and Informatics, University of Louisiana at Lafayette, Lafayette, LA, USA. E-mail: sercan.aygun@louisiana.edu. A preliminary version of this paper appeared as\n[\n7\n]\n.\nAbstract\nThe hardware-friendly im",
    "is_relevant": false,
    "relevance_score": 0.0,
    "extracted_keywords": [
        "stochastic computing",
        "transcendental functions",
        "hardware design",
        "Van der Corput sequences",
        "MSE reduction"
    ],
    "one_line_summary": "ËøôÁØáËÆ∫ÊñáÊèêÂá∫‰∫Ü‰∏ÄÁßçÂü∫‰∫éÈöèÊú∫ËÆ°ÁÆóÂíåVan der CorputÂ∫èÂàóÁöÑÁ°¨‰ª∂ÊÑüÁü•ÊñπÊ≥ïTranSCÔºåÁî®‰∫éÈ´òÊïàÂÆûÁé∞Ë∂ÖË∂äÂáΩÊï∞ÔºåÊòæËëóÈôç‰Ωé‰∫ÜËØØÂ∑ÆÂíåÁ°¨‰ª∂ËµÑÊ∫êÊ∂àËÄó„ÄÇ",
    "detailed_summary": "",
    "qa_pairs": [],
    "is_hidden": false,
    "is_starred": false,
    "flag": true,
    "published_date": "2026-01-12T03:33:21Z",
    "created_at": "2026-01-21T12:09:07.618339",
    "updated_at": "2026-01-21T12:09:07.618347"
}