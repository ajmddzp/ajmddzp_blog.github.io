{
    "id": "2601.10827v1",
    "title": "Approximately Optimal Global Planning for Contact-Rich SE(2) Manipulation on a Graph of Reachable Sets",
    "authors": [
        "Simin Liu",
        "Tong Zhao",
        "Bernhard Paus Graesdal",
        "Peter Werner",
        "Jiuguang Wang",
        "John Dolan",
        "Changliu Liu",
        "Tao Pang"
    ],
    "abstract": "è‹¥è€ƒé‡äººç±»æ“ä½œæ–¹å¼ï¼Œæ˜¾ç„¶æ¥è§¦å¼å¯Œæ“ä½œï¼ˆCRMï¼‰â€”â€”å³åˆ©ç”¨æ“ä½œå™¨ä»»æ„è¡¨é¢ä¸ç‰©ä½“æ¥è§¦çš„èƒ½åŠ›â€”â€”è¿œæ¯”ä»…ä¾èµ–æœ«ç«¯æ‰§è¡Œå™¨ï¼ˆå³æŒ‡å°–ï¼‰æ›´ä¸ºé«˜æ•ˆè‡ªç„¶ã€‚ç„¶è€Œï¼Œå½“å‰æœ€å…ˆè¿›çš„åŸºäºæ¨¡å‹çš„CRMè§„åˆ’å™¨ä»ä¾§é‡äºå¯è¡Œæ€§è€Œéæœ€ä¼˜æ€§ï¼Œè¿™é™åˆ¶äº†å…¶å……åˆ†å‘æŒ¥CRMä¼˜åŠ¿çš„èƒ½åŠ›ã€‚æˆ‘ä»¬æå‡ºä¸€ç§è®¡ç®—è¿‘ä¼¼æœ€ä¼˜æ“ä½œå™¨è§„åˆ’çš„æ–°èŒƒå¼ï¼Œè¯¥æ–¹æ³•åŒ…å«ä¸¤ä¸ªé˜¶æ®µï¼šç¦»çº¿é˜¶æ®µæ„å»ºäº’è¾¾é›†åˆå›¾ï¼Œå…¶ä¸­æ¯ä¸ªé›†åˆåŒ…å«ä»èµ·å§‹ç‰©ä½“å§¿æ€å’ŒæŠ“æ¡çŠ¶æ€å¯è¾¾çš„æ‰€æœ‰ç‰©ä½“æœå‘ï¼›åœ¨çº¿é˜¶æ®µåŸºäºè¯¥å›¾è¿›è¡Œè§„åˆ’ï¼Œé€šè¿‡è®¡ç®—å¹¶ç¼–æ’å±€éƒ¨è§„åˆ’åºåˆ—å®ç°å…¨å±€è¿åŠ¨ä¼˜åŒ–ã€‚åœ¨ä¸€é¡¹å…·æœ‰æŒ‘æˆ˜æ€§çš„ä»£è¡¨æ€§æ¥è§¦å¼å¯Œæ“ä½œä»»åŠ¡ä¸­ï¼Œæœ¬æ–¹æ³•ä¼˜äºä¸»æµè§„åˆ’å™¨ï¼Œä»»åŠ¡æˆæœ¬é™ä½61%ã€‚åœ¨250æ¬¡æŸ¥è¯¢ä¸­è¾¾åˆ°91%çš„æˆåŠŸç‡ï¼Œå¹¶ä¿æŒäºšåˆ†é’Ÿçº§æŸ¥è¯¢è€—æ—¶ï¼Œæœ€ç»ˆè¯æ˜å…¨å±€ä¼˜åŒ–çš„æ¥è§¦å¼å¯Œæ“ä½œå·²å…·å¤‡å®é™…åº”ç”¨ä»·å€¼ã€‚",
    "url": "https://arxiv.org/abs/2601.10827v1",
    "html_url": "https://arxiv.org/html/2601.10827v1",
    "html_content": "Approximately Optimal Global Planning\nfor Contact-Rich SE(2) Manipulation\non a Graph of Reachable Sets\nâ€ \nâ€ \nthanks:\nThis manuscript is under submission to IEEE Transactions on Robotics.\nSimin Liu\n1,2,âˆ—\n, Tong Zhao\n2,âˆ—\n, Bernhard Paus Graesdal\n3\n, Peter Werner\n3\n, Jiuguang Wang\n2\n, John Dolan\n1\n, Changliu Liu\n1\n, Tao Pang\n2\n1\nRobotics Institute, Carnegie Mellon University\n2\nRobotics and AI Institute\n3\nCSAIL, Massachusetts Institute of Technology\nAbstract\nIf we consider human manipulation, it is clear that contact-rich manipulation (CRM)-the ability to use any surface of the manipulator to make contact with objects-can be far more efficient and natural than relying solely on end-effectors (i.e., fingertips). However, state-of-the-art model-based planners for CRM are still focused on feasibility rather than optimality, limiting their ability to fully exploit CRMâ€™s advantages.\nWe introduce a new paradigm that computes approximately optimal manipulator plans. This approach has two phases. Offline, we construct a graph of\nmutual reachable sets\n, where each set contains all object orientations reachable from a starting object orientation and grasp. Online, we plan over this graph, effectively computing and sequencing local plans for globally optimized motion.\nOn a challenging, representative contact-rich task, our approach outperforms a leading planner, reducing task cost by\n61\n%\n61\\%\n. It also achieves a\n91\n%\n91\\%\nsuccess rate across 250 queries and maintains sub-minute query times, ultimately demonstrating that globally optimized contact-rich manipulation is now practical for real-world tasks.\nIndex Terms:\nFull-body manipulation, dexterous manipulation, manipulation planning\nI\nIntroduction\nRecent advances in large-scale behavior cloning (BC) have enabled robots to accomplish an unprecedented range of table-top tasks with remarkable success. However, due to limitations in teleoperation interfaces, BC is largely confined to end-effector manipulation, which struggles with large, bulky objects as well as small, delicate ones\n[\n5\n,\n28\n,\n13\n,\n50\n,\n45\n,\n42\n,\n22\n]\n.\nHandling such objects often requires contact-rich interactions between the manipuland and the manipulator or environment. For bulky objects (e.g., the cylinder in\nFigure\n1\n), bracing the object against the arms allows the robot to apply a wider range of wrenches, enabling more efficient plans. For small objects, multi-point support along the manipulator can provide the stability needed to achieve millimeter-level precision.\nContact-rich manipulation (CRM)\n, which leverages the robotâ€™s entire surface for making contact with objects, remains a challenging problem for global planning. In contrast, there has been a spate of recent breakthroughs in\nlocal\nplanning for CRM (improving a trajectory given a feasible initialization), making it higher quality and more reliable. Most of this progress addresses the challenge posed by non-smooth, hybrid contact dynamics to gradient-based trajectory optimization methods. Some of these breakthroughs smooth the dynamics to enable gradient-based optimization\n[\n41\n,\n43\n,\n39\n,\n38\n,\n26\n,\n40\n,\n44\n]\n, while others turn to sampling-based optimization\n[\n20\n,\n30\n]\n.\nDespite this advancement in local planning, the global planning problem (computing a feasible and optimal path from scratch) remains underexplored. Existing global planners largely prioritize feasibility, with little consideration for optimality\n[\n40\n,\n11\n]\n. One reason optimality is so challenging is that the global planning search space is both high-dimensional and hybrid. In particular, the discrete component (typically contact-state or mode sequencing) is an intractable combinatorial problem. Our key insight is that for global path optimization to be tractable, we need to redefine this\ndiscrete decision space\nto be more compact and tractable for global search.\nSo, what is the right decision space for this problem?\nFigure 1:\nThe bimanual KUKA iiwa-7 hardware setup with the cylindrical object. Because both the manipulators and the object are constrained to the\nx\nâ€‹\ny\nxy\n-plane, only the three indicated joints are actuated on each arm. The object pose (shown) is defined with respect to the world frame located at the bimanual base (also shown).\nContact modes are one of the most low-level and common choices of discrete decision space. They specify which pairs of contact geometries are in contact and their relative velocities. Contact modes have been used with global optimization based on Mixed-Integer Programming (MIP)\n[\n32\n,\n34\n,\n16\n,\n2\n,\n1\n]\n, sampling-based search\n[\n10\n,\n11\n]\n, A-star search\n[\n29\n]\n, and Monte-Carlo Tree Search (MCTS)\n[\n12\n,\n52\n]\n. However, since the number of contact modes grows quickly with the number of contact points and degrees of freedom\n[\n21\n]\n, they can only be applied to the simplest of systems, like spherical point manipulators with a single polygonal object.\nAnother common discrete decision space is hand-crafted motion primitives, such as â€œpush leftâ€\n[\n18\n,\n31\n,\n47\n,\n52\n]\n. Although such high-level discretization can drastically reduce the scale of the search, it can also make the planner too rigid, incapable of generating fine-grained motions.\nFigure 2:\nAn illustration of different configurations (\nq\nseed\nq_{\\text{seed}}\n,\nq\n1\nq_{1}\n,\nq\n2\nq_{2}\n,\nq\n3\nq_{3}\n) inside an example MRS. Note how this single MRS encapsulates different contact modes (in\nq\nseed\nq_{\\text{seed}}\n, both wrists make contact; in\nq\n2\nq_{2}\n, a white end-effector makes contact; etc.). This is what makes MRS a useful discrete decision space - it abstracts away some of the combinatorial complexity of contact modes.\nOur first contribution is a\nnovel, object-centric discrete decision space consisting of mutual reachable sets\n. A mutual reachable set (MRS) comprises object states both forward and backward reachable in finite time from an initial object orientation and grasp. Roughly, our approach is to first cover object space with convex approximations of MRS, link them into a planning graph, and then apply recent optimal planning techniques for graphs of convex sets\n[\n35\n]\n. This produces an optimal object path, which is finally translated into a configuration path and a sequence of manipulator inputs.\nWe adopt an object-centric paradigm because object space is lower-dimensional than the full configuration (object and manipulator) space, making it feasible to cover with MRS. Object-centrism is also natural for contact-rich manipulation. In CRM, object motions are tightly coupled with manipulator motions, so object paths and initial grasps are highly descriptive on their own.\nThe key advantage of the MRS decision space is that it strikes a balance between the expressiveness of low-level decision spaces (e.g., contact modes) and the efficiency of high-level ones (e.g., motion primitives). Each MRS aggregates many low-level contact modes into a single set (\nFigure\n2\n), substantially reducing the combinatorial complexity of global search. This reduction makes it possible to apply optimal search techniques and compute object-space plans in seconds (\nSection\nV\n).\nAt the same time, MRS are more expressive than fixed motion primitives. Each MRS represents a variety of different motions achievable by the local planner, and the decision-space granularity can be increased by adding more MRS as needed (\nFigure\n9\n). Together, these properties enable fast planning while maintaining broad coverage of feasible behaviors, resulting in high planning success rates across a wide range of queries (\nSection\nV\n).\nOur second contribution is an\noffline procedure to construct a graph of MRS\n. In\nSection\nIII\n, we describe algorithms for constructing convex-approximated MRS and producing an approximate cover of object space. Finally, we define a planning graph over this set cover. We also introduce a graph cost-fitting feature that improves the correspondence between object-space and full-space planning.\nOur third contribution is an\nonline hierarchical, multi-query planner\n(\nSection\nIV\n). This planner operates in two stages: first, it uses the GCS algorithm\n[\n35\n]\nto produce an optimal object-space plan; second, it translates this plan into a full-space plan and manipulator input sequence by tracking the object plan with local planners. Three key features distinguish this planner: (1)\napproximately\noptimal plans (empirically significantly better than SOTA), (2) sub-minute query times, and (3) high planning success rates across diverse queries.\nWhile sampling-based motion planners for CRM also perform global search, none are asymptotically optimal in the CRM setting, and they often perform poorly in practice because their random growth strategies produce inefficient trajectories\n[\n7\n,\n8\n,\n37\n,\n40\n,\n48\n]\n. Moreover, post-processing techniques that work well for sampling-based planners in collision-free settings are difficult to apply in the CRM setting.\nFurthermore, our planner is much more efficient than Reinforcement Learning (RL) methods, which search for global policies through uninformed search and extensive reward shaping\n[\n23\n,\n3\n,\n9\n,\n51\n,\n17\n]\n. While RL methods can require years of simulation time, we can build our search graph in a few hours.\nIn summary, our contributions are:\nâ€¢\nA novel, object-centric discrete decision space of mutual reachable sets (\nSection\nII-C\n)\nâ€¢\nAn offline framework for constructing a planning graph over a group of MRS (\nSection\nIII\n)\nâ€¢\nA hierarchical, multi-query planner for use with this graph (\nSection\nIV\n)\nPlus, empirical results (\nSection\nV\n-\nSection\nVII\n) that demonstrate:\nâ€¢\nApplicability to challenging systems and tasks of real-world complexity\nâ€¢\nSignificantly higher-quality plans than the SOTA sampling-based planner\n[\n44\n]\n(66% cost improvement)\nâ€¢\nNear-perfect planning success rates over a broad set of queries, highlighting robustness\nâ€¢\nSub-minute query times\nII\nPreliminaries\nIn this section, we begin by defining our problem setting formally. Then, we describe the local planners that we use as subroutines in our method. With all this preliminary information, we can then formally define mutual reachable sets, our object-centric decision space. Next, we review the GCS algorithm that we leverage to quickly compute optimal object paths over our graph of MRS. Finally, we wrap up by describing our challenging representative task.\nII-A\nProblem Formulation\nWe consider a discrete-time, quasi-dynamic\n[\n36\n]\ndynamical system of the form\nq\n+\n=\nf\nâ€‹\n(\nq\n,\nu\n)\n,\nq_{+}=f(q,u),\n(1)\nwhere\nq\nâ‰”\n(\nq\na\n,\nq\no\n)\nâˆˆ\nğ’¬\nâŠ†\nâ„\nn\na\nÃ—\nSE\nâ€‹\n(\n2\n)\nq\\coloneqq(q^{a},q^{o})\\in\\mathcal{Q}\\subseteq\\mathbb{R}^{n_{a}}\\times\\mathrm{SE}(2)\nis the system configuration, and\nu\nu\nthe action or control input. We omit velocities due the quasi-dynamic assumption. The configuration\nq\nq\nis divided into the manipulatorâ€™s actuated configurations\nq\na\nâˆˆ\nğ’¬\na\nâŠ†\nâ„\nn\na\nq^{a}\\in\\mathcal{Q}^{a}\\subseteq\\mathbb{R}^{n_{a}}\nand the unactuated object configurations\nq\no\nâ‰”\n(\nq\nx\no\n,\nq\ny\no\n,\nq\nÎ¸\no\n)\nâˆˆ\nğ’¬\no\nâŠ†\nSE\nâ€‹\n(\n2\n)\nq^{o}\\coloneqq(q^{o}_{x},q^{o}_{y},q^{o}_{\\theta})\\in\\mathcal{Q}^{o}\\subseteq\\mathrm{SE}(2)\nwhere\nğ’¬\no\n\\mathcal{Q}^{o}\nis all object configurations that can be grasped (see\nFigure\n4\nfor an illustration on an example). The action\nu\nâˆˆ\nğ’°\nâŠ†\nâ„\nn\na\nu\\in\\mathcal{U}\\subseteq\\mathbb{R}^{n_{a}}\nconsists of position commands tracked by a stiffness controller with diagonal gain matrix\nğŠ\na\nâˆˆ\nâ„\nn\na\nÃ—\nn\na\n\\mathbf{K}_{a}\\in\\mathbb{R}^{n_{a}\\times n_{a}}\n.\nSince we construct a planning graph over\nSE\nâ€‹\n(\n2\n)\n\\mathrm{SE}(2)\n, we need to carefully define the distance function and set operations (inclusion, intersection, etc.) over this space. We view\nSE\nâ€‹\n(\n2\n)\nâ‰…\nâ„\n2\nÃ—\nS\n1\n\\mathrm{SE}(2)\\cong\\mathbb{R}^{2}\\times S^{1}\nand equip it with the product Riemannian metric\ng\n=\nd\nâ€‹\np\nx\n2\n+\nd\nâ€‹\np\ny\n2\n+\nw\nâ€‹\nd\nâ€‹\nÎ¸\n2\ng=\\mathrm{d}p_{x}^{2}+\\mathrm{d}p_{y}^{2}+w\\,\\mathrm{d}\\theta^{2}\n. The associated geodesic distance between\nq\n1\no\n=\n(\np\n1\n,\nÎ¸\n1\n)\nq_{1}^{o}=(p_{1},\\theta_{1})\nand\nq\n2\no\n=\n(\np\n2\n,\nÎ¸\n2\n)\nq_{2}^{o}=(p_{2},\\theta_{2})\nis\nd\nSE\nâ€‹\n(\n2\n)\nâ€‹\n(\nq\n1\no\n,\nq\n2\no\n)\nâ‰”\nâ€–\np\n1\nâˆ’\np\n2\nâ€–\n2\n+\nw\nâ€‹\nÎ”\nâ€‹\nÎ¸\n2\n,\n\\displaystyle d_{\\mathrm{SE}(2)}(q_{1}^{o},q_{2}^{o})\\coloneqq\\sqrt{\\|p_{1}-p_{2}\\|^{2}+w\\,\\Delta\\theta^{2}},\n(2)\nwhere\nÎ”\nâ€‹\nÎ¸\n=\nwrap\n(\nâˆ’\nÏ€\n,\nÏ€\n]\nâ€‹\n(\nÎ¸\n2\nâˆ’\nÎ¸\n1\n)\n\\Delta\\theta=\\mathrm{wrap}_{(-\\pi,\\pi]}(\\theta_{2}-\\theta_{1})\n. We set\nw\nw\nto\n1\n1\n. We take operations like equality, set inclusion, and set intersection to mean operations under this metric.\nNext, we formally define our reorientation task. Our task assumes as input an object start pose\nq\nstart\no\nâˆˆ\nğ’¬\no\nq^{o}_{\\text{start}}\\in\\mathcal{Q}^{o}\n, an object goal region\nğ’¬\ngoal\no\n=\n{\nq\no\nâˆˆ\nğ’¬\no\nâˆ£\nd\nSE\nâ€‹\n(\n2\n)\nâ€‹\n(\nq\no\n,\nq\ngoal\no\n)\nâ‰¤\nr\n}\n\\displaystyle\\mathcal{Q}_{\\text{goal}}^{o}=\\{q^{o}\\in\\mathcal{Q}^{o}\\mid d_{\\mathrm{SE(2)}}(q^{o},q_{\\text{goal}}^{o})\\leq r\\}\n(3)\ndefined by goal state\nq\ngoal\no\nâˆˆ\nğ’¬\no\nq^{o}_{\\text{goal}}\\in\\mathcal{Q}^{o}\nand tolerance\nr\nâˆˆ\nâ„\n+\nr\\in\\mathbb{R}^{+}\n, horizon\nT\nâˆˆ\nâ„¤\n+\nT\\in\\mathbb{Z}^{+}\nand a cost function of the form\nc\nâ€‹\n(\nq\n0\n:\nT\n)\n=\nâˆ‘\nt\n=\n0\nT\nâˆ’\n1\nd\nâ€‹\n(\nq\nt\n,\nq\nt\n+\n1\n)\n\\displaystyle c\\left(q_{0:T}\\right)=\\sum_{t=0}^{T-1}d\\left(q_{t},q_{t+1}\\right)\n(4)\n. We use task cost\nd\nâ€‹\n(\nq\nt\n,\nq\nt\n+\n1\n)\n=\nâˆ¥\nq\nt\na\nâˆ’\nq\nt\n+\n1\na\nâˆ¥\n2\n\\displaystyle d(q_{t},q_{t+1})=\\lVert q^{a}_{t}-q^{a}_{t+1}\\rVert_{2}\n(5)\nthroughout, which encourages velocity smoothness and the minimal path length in actuated space. However, the framework readily accommodates other task costs, such as deviation from a reference object trajectory,\nd\nâ€‹\n(\nq\nt\n,\nq\nt\n+\n1\n)\n=\nâˆ¥\nq\nt\no\nâˆ’\nq\nt\n,\nref\no\nâˆ¥\n2\nd(q_{t},q_{t+1})=\\lVert q^{o}_{t}-q^{o}_{t,\\text{ref}}\\rVert_{2}\n, or travel time, assuming a maximum joint velocity\nv\nmax\nv_{\\text{max}}\n,\nd\nâ€‹\n(\nq\nt\n,\nq\nt\n+\n1\n)\n=\nâˆ¥\nq\nt\na\nâˆ’\nq\nt\n+\n1\na\nâˆ¥\nâˆ\n/\nv\nmax\nd(q_{t},q_{t+1})=\\lVert q^{a}_{t}-q^{a}_{t+1}\\rVert_{\\infty}/v_{\\text{max}}\n.\nAltogether, our task is to find configuration and control sequences\nq\n0\n:\nT\n,\nu\n0\n:\nT\nâˆ’\n1\nq_{0:T},u_{0:T-1}\nthat reach the goal region while minimizing the cost:\nmin\nq\n0\n:\nT\n,\nu\n0\n:\nT\nâˆ’\n1\n\\displaystyle\\min_{q_{0:T},u_{0:T-1}}\nc\nâ€‹\n(\nq\n0\n:\nT\n)\n\\displaystyle c(q_{0:T})\n(6a)\ns.t.\nq\n0\no\n=\nq\nstart\no\n,\n\\displaystyle q_{0}^{o}=q^{o}_{\\text{start}},\n(6b)\nq\nt\n+\n1\n=\nf\nâ€‹\n(\nq\nt\n,\nu\nt\n)\n,\nâˆ€\nt\n=\n0\n,\nâ€¦\n,\nT\nâˆ’\n1\n,\n\\displaystyle q_{t+1}=f(q_{t},u_{t}),\\;\\;\\forall t=0,\\ldots,T-1,\n(6c)\nq\nT\no\nâˆˆ\nğ’¬\ng\nâ€‹\no\nâ€‹\na\nâ€‹\nl\no\n.\n\\displaystyle q^{o}_{T}\\in\\mathcal{Q}^{o}_{goal}.\n(6d)\nII-B\nLocal Planners\nWe describe the local planners that we use as subroutines in our method: a contact-aware trajectory optimizer and a collision-free motion planner. The first kind of planner is used in the offline graph construction phase to find which states are reachable. Both kinds are used online in the hierarchical planner to translate the object path to a full-configuration space path. Following classical robotics literature\n[\n24\n]\n, we define two types of motions relevant to translation:\ntransfer\nmotions, where the manipulator moves the object, and\ntransit\nmotions, where the object is kept stationary during a regrasp. The contact-aware trajectory optimizer is used to translate transfer motions and the collision-free motion planner translates transit motions.\nFirst, we describe our contact-aware trajectory optimizer. Given an initial configuration\nq\nq\n, an object goal configuration\nq\ngoal\no\nq^{o}_{\\text{goal}}\n, and a horizon\nT\nÏ€\nT_{\\pi}\n, a contact-aware trajectory optimizer\nÏ€\n:\nğ’¬\nÃ—\nğ’¬\no\nâ†’\nğ’°\nT\nÏ€\n\\pi:\\mathcal{Q}\\times\\mathcal{Q}^{o}\\rightarrow\\mathcal{U}^{T_{\\pi}}\ntakes in\n(\nq\n,\nq\ngoal\no\n)\n(q,q^{o}_{\\text{goal}})\nand produces\nu\n0\n:\nT\nÏ€\nâˆ’\n1\nu_{0:T_{\\pi}-1}\n, a control trajectory which reaches\nq\ngoal\no\nq^{o}_{\\text{goal}}\nunder the dynamics of (\n17\n). Some popular ones are\n[\n41\n,\n4\n,\n19\n,\n44\n]\n. Based on our quasi-dynamic assumption, we choose\n[\n44\n]\n, which poses a trajectory optimization program subject to a convex, differentiable quasi-dynamics (CQDC) constraint. This is solved in the fashion of receding-horizon model predictive control (MPC); hence, we call it CQDC-MPC. CQDC-MPC also offers additional benefits, like numerical robustness, gradient-based contact-discovery via smoothing, and the ability to predict dynamics over longer timesteps. See\nSection\nA-A\nfor more details.\nNext, we describe our collision-free motion planner. Given an initial configuration\nq\n=\n(\nq\na\n,\nq\no\n)\nq=(q^{a},q^{o})\n, a desired robot configuration\nq\ngoal\na\nq^{a}_{\\text{goal}}\n, and a horizon\nT\nÏˆ\nT_{\\psi}\n, a collision-free motion planner\nÏˆ\n:\nğ’¬\nÃ—\nğ’¬\na\nâ†’\nğ’°\nT\nÏˆ\n\\psi:\\mathcal{Q}\\times\\mathcal{Q}^{a}\\to\\mathcal{U}^{T_{\\psi}}\ntakes in\n(\nq\n,\nq\ngoal\na\n)\n(q,q^{a}_{\\text{goal}})\nand produces\nu\n0\n:\nT\nÏˆ\nâˆ’\n1\nu_{0:T_{\\psi}-1}\n, a control trajectory which brings the robot from\nq\na\nq^{a}\nto\nq\ngoal\na\nq^{a}_{\\text{goal}}\nwithout colliding with the stationary object at\nq\no\nq^{o}\n.\nCollision-free motion planning is a richly studied field, with planners such as\n[\n33\n]\nable to synthesize globally optimal collision-free trajectories in high-dimensional spaces. For this work, we choose the simple RRT-Connect planner\n[\n25\n]\nand post-process with trajectory optimization. See\nSection\nA-B\nfor details.\nII-C\nMutual Reachable Sets\nFigure 3:\nThis figure shows the relationship between FRS\nâ„›\n+\nâˆˆ\nğ’¬\n\\mathcal{R}^{+}\\in\\mathcal{Q}\n, BRS\nâ„›\nâˆ’\nâˆˆ\nğ’¬\n\\mathcal{R}^{-}\\in\\mathcal{Q}\n, and MRS\nâ„›\no\nâˆˆ\nğ’¬\no\n\\mathcal{R}^{o}\\in\\mathcal{Q}^{o}\n. The FRS and BRS lie on contact manifolds in the full configuration space. They are defined by seed configuration\nq\ns\nâ€‹\ne\nâ€‹\ne\nâ€‹\nd\nq_{seed}\n, where they intersect, and the choice of contact-aware trajectory optimizer\nÏ€\n\\pi\n. The MRS is defined in lower-dimensional object space, as the intersection of the projections of the FRS and BRS. We also illustrate the inverse projection operator,\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâˆ’\n1\n\\mathbf{proj}_{\\mathcal{Q}^{o}}^{-1}\n, that maps object states in the MRS to their full configurations.\nNow we define the mutual reachable sets (MRS) of our contact-aware trajectory optimizer\nÏ€\n\\pi\n, which serve as the basis of our framework. An MRS consists of all object configurations that are forward and backward reachable from a\nseed configuration\nq\nseed\nâˆˆ\nğ’¬\nq_{\\text{seed}}\\in\\mathcal{Q}\n(a configuration where the manipulator and object are in contact) under\nÏ€\n\\pi\n. The core innovation of our framework is that we take MRS to be our discrete elements, rather than contact modes or higher-level skills (e.g. rotating, pivoting). This choice of discretization reduces combinatorial complexity while still remaining fine-grained enough to solve general reorientation queries.\nWe begin by defining\nforward\nand\nbackward reachable sets\n(FRS, BRS). For convenience, we define\nf\nT\n:\nğ’¬\nÃ—\nğ’°\nT\nâ†’\nğ’¬\nf_{T}:\\mathcal{Q}\\times\\mathcal{U}^{T}\\rightarrow\\mathcal{Q}\n, which recursively applies dynamics for a length-\nT\nT\ncontrol sequence\nu\n0\n:\nT\nâˆ’\n1\nu_{0:T-1}\nfrom some initial state\nq\nq\n. The finite-time FRS of a local planner\nÏ€\n\\pi\nis the set of all configurations that are reachable from\nq\nseed\nq_{\\text{seed}}\nunder\nÏ€\n\\pi\n:\nâ„›\nÏ€\n,\nT\n+\nâ€‹\n(\nq\nseed\n)\n=\n{\nq\nâˆ£\nq\n=\nf\nT\nâ€‹\n(\nq\nseed\n,\nÏ€\nâ€‹\n(\nq\nseed\n,\nq\no\n)\n)\n}\nâŠ†\nğ’¬\n.\n\\displaystyle\\mathcal{R}^{+}_{\\pi,T}(q_{\\text{seed}})=\\{q\\mid q=f_{T}(q_{\\text{seed}},\\pi(q_{\\text{seed}},q^{o}))\\}\\subseteq\\mathcal{Q}.\n(7)\nAnalogously, the finite-time BRS is all configurations that can reach\nq\nseed\nq_{\\text{seed}}\nunder\nÏ€\n\\pi\n:\nâ„›\nÏ€\n,\nT\nâˆ’\nâ€‹\n(\nq\nseed\n)\n=\n{\nq\nâˆ£\nf\nT\nâ€‹\n(\nq\n,\nÏ€\nâ€‹\n(\nq\n,\nq\nseed\no\n)\n)\n=\nq\nseed\n}\nâŠ†\nğ’¬\n.\n\\displaystyle\\mathcal{R}^{-}_{\\pi,T}(q_{\\text{seed}})=\\{q\\mid f_{T}(q,\\pi(q,q^{o}_{\\text{seed}}))=q_{\\text{seed}}\\}\\subseteq\\mathcal{Q}.\n(8)\nThough the FRS and BRS lie on contact manifolds (\nFigure\n3\n) in the full configuration space\nğ’¬\n\\mathcal{Q}\n, we are interested in their coordinate projections onto\nğ’¬\no\n\\mathcal{Q}^{o}\n, which we denote by a superscripted\no\no\n:\nâ„›\nÏ€\n,\nT\no\n,\n+\nâ£\n/\nâˆ’\nâ€‹\n(\nq\nseed\n)\n:=\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâ€‹\n(\nâ„›\nÏ€\n,\nT\n+\nâ£\n/\nâˆ’\nâ€‹\n(\nq\nseed\n)\n)\n.\n\\displaystyle\\mathcal{R}^{o,+/-}_{\\pi,T}(q_{\\text{seed}})\\vcentcolon=\\mathbf{proj}_{\\mathcal{Q}^{o}}\\left(\\mathcal{R}^{+/-}_{\\pi,T}(q_{\\text{seed}})\\right).\n(9)\nWe are now ready to define the mutually reachable set.\nDefinition 1\n.\nMutually reachable set (MRS)\n- given a seed configuration\nq\nseed\nq_{\\text{seed}}\n, planner\nÏ€\n\\pi\n, and horizon\nT\nT\n, the MRS is all object configurations that simultaneously can be reached from and can reach back to the seed in\n2\nâ€‹\nT\n2T\n.\nâ„›\nÏ€\n,\nT\no\nâ€‹\n(\nq\nseed\n)\n:=\nâ„›\nÏ€\n,\nT\no\n,\n+\nâ€‹\n(\nq\nseed\n)\nâˆ©\nâ„›\nÏ€\n,\nT\no\n,\nâˆ’\nâ€‹\n(\nq\nseed\n)\nâŠ†\nğ’¬\no\n\\displaystyle\\mathcal{R}_{\\pi,T}^{o}(q_{\\text{seed}})\\vcentcolon=\\mathcal{R}^{o,+}_{\\pi,T}(q_{\\text{seed}})\\cap\\mathcal{R}^{o,-}_{\\pi,T}(q_{\\text{seed}})\\subseteq\\mathcal{Q}^{o}\n(10)\nSee also\nFigure\n3\nfor a visualization. For brevity, we refer to these sets henceforth as\nâ„›\n+\nâ£\n/\nâˆ’\n,\nâ„›\no\n,\n+\nâ£\n/\nâˆ’\n,\nâ„›\no\n\\mathcal{R}^{+/-},\\mathcal{R}^{o,+/-},\\mathcal{R}^{o}\n, dropping the dependency on\nq\nseed\n,\nÏ€\n,\nT\nq_{\\text{seed}},\\pi,T\n.\nLemma 1\n.\nAny two object states\nq\n1\no\n,\nq\n2\no\nq^{o}_{1},q^{o}_{2}\nin the MRS are mutually reachable:\nq\n1\no\nq^{o}_{1}\nis reachable from\nq\n2\no\nq^{o}_{2}\nand vice versa.\nSee\nSection\nA-C\nfor formal statement and proof. We will use this lemma later to show that our object plans are kinematically and dynamically feasible by construction, under some assumptions (\nSection\nIV\n).\nWe also define an inverse projection operator that will be useful later (\nSection\nIV\n). Although each MRS\nâ„›\no\n\\mathcal{R}^{o}\nis defined in object space, it implicitly specifies a mapping between object configurations\nq\no\nâˆˆ\nâ„›\no\nq^{o}\\in\\mathcal{R}^{o}\nand corresponding full configurations\nq\nâˆˆ\nğ’¬\nq\\in\\mathcal{Q}\n.\nWe define this as:\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâˆ’\n1\nâ€‹\n(\nq\no\n,\nâ„›\no\n)\n=\nf\nT\nâ€‹\n(\nâ„›\no\nâ€‹\n(\nq\nseed\n)\n,\nÏ€\nâ€‹\n(\nâ„›\no\nâ€‹\n(\nq\nseed\n)\n,\nq\no\n)\n)\n.\n\\displaystyle\\mathbf{proj}_{\\mathcal{Q}^{o}}^{-1}(q^{o},\\mathcal{R}^{o})=f_{T}(\\mathcal{R}^{o}(q_{\\text{seed}}),\\pi(\\mathcal{R}^{o}(q_{\\text{seed}}),q^{o})).\n(11)\nwhere\nâ„›\no\nâ€‹\n(\nq\nseed\n)\n\\mathcal{R}^{o}(q_{\\text{seed}})\ndenotes the seed configuration of set\nâ„›\no\n\\mathcal{R}^{o}\n. This means that the inverse projection is computed by reaching forward to\nq\no\nq^{o}\nfrom\nâ„›\no\nâ€‹\n(\nq\nseed\n)\n\\mathcal{R}^{o}(q_{\\text{seed}})\nusing\nÏ€\n\\pi\n.\nSee\nFigure\n3\nfor an illustration.\nII-D\nShortest Paths on Graph of Convex Sets\nOffline, we use our local planner to cover object space with MRS and then connect them into a graph. At query-time, the first step of\nour hierarchical planner is to search for the shortest path through the MRS graph, yielding an object path,\nq\n0\n:\nT\no\nq^{o}_{0:T}\n. To find the shortest path on this graph of convex sets, we apply the Graph of Convex Sets (GCS) framework\n[\n35\n]\n.\nGCS takes in a directed graph\nG\n=\n(\nğ’±\n,\nâ„°\n)\nG=(\\mathcal{V},\\mathcal{E})\nwith vertex set\nğ’±\n\\mathcal{V}\nand edge set\nâ„°\nâŠ†\nğ’±\n2\n\\mathcal{E}\\subseteq\\mathcal{V}^{2}\n.\nEach vertex\nv\nâˆˆ\nğ’±\nv\\in\\mathcal{V}\nis associated with a convex set\nğ’³\nv\n\\mathcal{X}_{v}\nand a nonnegative convex cost\nâ„“\nv\n:\nğ’³\nv\nâ†’\nâ„\n+\n\\ell_{v}:\\mathcal{X}_{v}\\rightarrow\\mathbb{R}^{+}\n.\nAn element of\nğ’³\nv\n\\mathcal{X}_{v}\nis denoted by\nx\nv\nâˆˆ\nğ’³\nv\nx_{v}\\in\\mathcal{X}_{v}\n.\nSimilarly, each edge\ne\n=\n(\nu\n,\nv\n)\nâˆˆ\nâ„°\ne=(u,v)\\in\\mathcal{E}\nis associated with a Cartesian product of convex sets\nğ’³\ne\nâŠ†\nğ’³\nu\nÃ—\nğ’³\nv\n\\mathcal{X}_{e}\\subseteq\\mathcal{X}_{u}\\times\\mathcal{X}_{v}\nand a nonnegative convex cost\nâ„“\ne\n:\nğ’³\nu\nÃ—\nğ’³\nv\nâ†’\nâ„\n+\n\\ell_{e}:\\mathcal{X}_{u}\\times\\mathcal{X}_{v}\\rightarrow\\mathbb{R}^{+}\n.\nAn element of\nğ’³\ne\n\\mathcal{X}_{e}\nis denoted by\n(\nx\nu\n,\nx\nv\n)\nâˆˆ\nğ’³\ne\n(x_{u},x_{v})\\in\\mathcal{X}_{e}\n.\nNext, we define a path\np\np\nas a sequence of distinct vertices that connect a source\ns\nâˆˆ\nğ’±\ns\\in\\mathcal{V}\nto a target\nt\nâˆˆ\nğ’±\nt\\in\\mathcal{V}\n, with\nâ„°\np\n\\mathcal{E}_{p}\nas the edges traversed by\np\np\n. Let\nğ’«\n\\mathcal{P}\nbe the set of all such paths.\nThe shortest path is the solution to the following optimization problem:\nmin\np\nâˆˆ\nğ’«\n\\displaystyle\\min_{p\\in\\mathcal{P}}\\quad\nâˆ‘\nv\nâˆˆ\np\nâ„“\nv\nâ€‹\n(\nx\nv\n)\n+\nâˆ‘\ne\n=\n(\nu\n,\nv\n)\nâˆˆ\nâ„°\np\nâ„“\ne\nâ€‹\n(\nx\nu\n,\nx\nv\n)\n,\n\\displaystyle\\sum_{v\\in p}\\ell_{v}(x_{v})+\\sum_{e=(u,v)\\in\\mathcal{E}_{p}}\\ell_{e}(x_{u},x_{v}),\n(12a)\ns.t.\nx\nv\nâˆˆ\nğ’³\nv\n,\nâˆ€\nv\nâˆˆ\np\n,\n\\displaystyle x_{v}\\in\\mathcal{X}_{v},\\;\\;\\forall v\\in p,\n(12b)\n(\nx\nu\n,\nx\nv\n)\nâˆˆ\nğ’³\ne\n,\nâˆ€\ne\n=\n(\nu\n,\nv\n)\nâˆˆ\nâ„°\np\n.\n\\displaystyle(x_{u},x_{v})\\in\\mathcal{X}_{e},\\;\\;\\forall e=(u,v)\\in\\mathcal{E}_{p}.\n(12c)\nThis shortest paths problem can be transcribed into a mixed-integer convex program (MICP). While the MICP program can be solved to optimality using MIP solvers, the GCS framework introduces a tight\nconvex relaxation\nthat can be solved much faster, while yielding effectively optimal results in many cases. We adopt the GCS framework, which enables us to find optimal object paths in seconds. Also, we verify later that the optimality gap with MIP is negligible (\nSection\nV-B\n1\n).\nII-E\nTask Specification\nAlthough the planner we propose is not limited to a particular robotic system, we introduce our experimental setup here to ground subsequent discussions in a concrete context.\nWe consider a bimanual KUKA iiwa system (\nFigure\n1\n), where each arm has 7 joints but only 3 (shoulder, elbow, wrist) are actuated to constrain motion in the\nx\nâ€‹\ny\nxy\n-plane. The task is to move a cylindrical object to a desired pose. The system has 3 unactuated DOFs, 6 actuated DOFs (\nn\na\n=\n6\nn_{a}=6\n), and 29 collision geometries. We assume known geometric models of both the robot and the object, which are shown in\nFigure\n4\n.\nThis is a challenging and representative contact-rich manipulation task: it requires exploiting intrinsic dexterity to complete efficiently, while reasoning about multi-point contacts and complex arm geometries. Compared to the simpler end-effector or gripper systems typically studied in model-based planning for contact-rich manipultion, this setup is significantly higher dimensional and better tests the capabilities of our planner.\n(a)\n(b)\nFigure 4:\nLeft: visual geometry of the bimanual KUKA iiwa-7 system, with the object workspace\nğ’¬\no\n\\mathcal{Q}^{o}\noverlaid in green.\nğ’¬\no\n\\mathcal{Q}^{o}\ndescribes all object positions that can be grasped. Right: collision model used for planning. Each arm has 14 spheres.\nIII\nMethodology - Offline Graph Construction\nWe now present the offline phase of our framework, in which we construct a planning graph over MRS. We first describe how to compute a single MRS and its convex approximation.\nWe then specify a simple algorithm for covering the object space with these convex-approximated MRS. Finally, we explain how we define a graph over this group of sets. In the following\nSection\nIV\n, we will describe the online phase, which uses this graph at query-time to produce a control sequence.\nIII-A\nComputing a Convex-Approximated MRS\nFigure 5:\nDemonstration of computing a convex-approximated MRS on a toy example in 2D object space. Left: after we compute the projected FRS\nâ„›\nÎ”\no\n,\n+\n\\mathcal{R}^{o,+}_{\\Delta}\n(orange) and BRS\nâ„›\nÎ”\no\n,\nâˆ’\n\\mathcal{R}^{o,-}_{\\Delta}\n(green), we intersect them to get the discrete MRS\nâ„›\nÎ”\no\n\\mathcal{R}^{o}_{\\Delta}\n(brown). Right: next, we find a convex approximation of\nâ„›\nÎ”\no\n\\mathcal{R}^{o}_{\\Delta}\n. The figure shows a likely convex approximation produced by the algorithm IRIS-ZO:\nâ„›\n^\nÎ”\no\n\\hat{\\mathcal{R}}^{o}_{\\Delta}\n(violet). It lies mostly within\nâ„›\nÎ”\no\n\\mathcal{R}^{o}_{\\Delta}\n, but may exceed it somewhat. We want to avoid such â€œoverapproximationâ€ as much as possible, since it amounts to introducing unreachable sets into our reachable set approximation.\nInput:\nSeed grasp\nq\nseed\nâˆˆ\nğ’¬\nq_{\\text{seed}}\\in\\mathcal{Q}\n, resolution\nÎ”\nâˆˆ\nâ„\n+\n\\Delta\\in\\mathbb{R}^{+}\nOutput:\nConvex-approximated MRS\nâ„›\n^\nÎ”\no\n\\hat{\\mathcal{R}}_{\\Delta}^{o}\n1\nâ„›\nÎ”\no\n,\n+\nâ†\nset()\n\\mathcal{R}^{o,+}_{\\Delta}\\leftarrow\\texttt{set()}\n;\n2\nâ„›\nÎ”\no\n,\nâˆ’\nâ†\nset()\n\\mathcal{R}^{o,-}_{\\Delta}\\leftarrow\\texttt{set()}\n;\n3\ngrid\nâ†\nDiscretize\nâ€‹\n(\nğ’¬\no\n,\nÎ”\n)\n\\texttt{grid}\\leftarrow\\texttt{Discretize}(\\mathcal{Q}^{o},\\Delta)\n;\n4\nfor\ncell\nâˆˆ\ngrid\n\\texttt{cell}\\in\\texttt{grid}\ndo\n5\nq\ncell\no\nâ†\nGetCenter\nâ€‹\n(\ncell\n)\nq^{o}_{\\text{cell}}\\leftarrow\\texttt{GetCenter}(\\texttt{cell})\n;\n6\nq\nforward\nâ†\nf\nT\nâ€‹\n(\nq\nseed\n,\nÏ€\nâ€‹\n(\nq\nseed\n,\nq\ncell\no\n)\n)\nq_{\\text{forward}}\\leftarrow f_{T}(q_{\\text{seed}},\\pi(q_{\\text{seed}},q^{o}_{\\text{cell}}))\n;\n7\nif\nq\nforward\no\nâˆˆ\ncell\nq^{o}_{\\text{forward}}\\in\\texttt{cell}\nthen\n8\nâ„›\nÎ”\no\n,\n+\n.\nadd\nâ€‹\n(\ncell\n)\n\\mathcal{R}^{o,+}_{\\Delta}.\\texttt{add}(\\texttt{cell})\n;\n9\nq\nbackward\nâ†\nf\nT\nâ€‹\n(\nq\nforward\n,\nÏ€\nâ€‹\n(\nq\nforward\n,\nq\nseed\no\n)\n)\nq_{\\text{backward}}\\leftarrow f_{T}(q_{\\text{forward}},\\pi(q_{\\text{forward}},q^{o}_{\\text{seed}}))\n;\n10\nif\nd\nSE\nâ€‹\n(\n2\n)\nâ€‹\n(\nq\nbackward\no\n,\nq\nseed\no\n)\nâ‰¤\nthreshold\nd_{\\mathrm{SE}(2)}(q^{o}_{\\text{backward}},q^{o}_{\\text{seed}})\\leq\\text{threshold}\nthen\n11\nâ„›\nÎ”\no\n,\nâˆ’\n.\nadd\nâ€‹\n(\ncell\n)\n\\mathcal{R}^{o,-}_{\\Delta}.\\texttt{add}(\\texttt{cell})\n;\n12\n13\n14\n15\nâ„›\nÎ”\no\nâ†\nâ„›\nÎ”\no\n,\n+\nâˆ©\nâ„›\nÎ”\no\n,\nâˆ’\n\\mathcal{R}^{o}_{\\Delta}\\leftarrow\\mathcal{R}^{o,+}_{\\Delta}\\cap\\mathcal{R}^{o,-}_{\\Delta}\n;\n16\nâ„›\n^\nÎ”\no\nâ†\nIrisZo\nâ€‹\n(\nâ„›\nÎ”\no\n)\n\\hat{\\mathcal{R}}^{o}_{\\Delta}\\leftarrow\\texttt{IrisZo}(\\mathcal{R}^{o}_{\\Delta})\n;\n17\nreturn\nâ„›\n^\nÎ”\no\n\\hat{\\mathcal{R}}^{o}_{\\Delta}\n;\nAlgorithmÂ 1\nComputeConvexApproximatedMRS\nWe first describe the process to compute a single MRS for a given seed grasp\nq\nseed\nq_{\\text{seed}}\n(\nAlgorithm\n1\n,\nFigure\n5\n). We begin by discretizing the object space into a grid with resolution\nÎ”\n\\Delta\n. We then compute the projected FRS and BRS (\nEquation\n9\n) on this discretized object space as binary occupancy maps, denoting them\nâ„›\nÎ”\no\n,\n+\n\\mathcal{R}^{o,+}_{\\Delta}\nand\nâ„›\nÎ”\no\n,\nâˆ’\n\\mathcal{R}^{o,-}_{\\Delta}\n. Specifically, to compute the\nâ„›\nÎ”\no\n,\n+\n\\mathcal{R}^{o,+}_{\\Delta}\n, we attempt to reach each grid cell from\nq\nseed\nq_{\\text{seed}}\n. Similarly, for\nâ„›\nÎ”\no\n,\nâˆ’\n\\mathcal{R}^{o,-}_{\\Delta}\n, we attempt to reach\nq\nseed\nq_{\\text{seed}}\nfrom each grid cell. Then, the MRS is obtained by their intersection:\nâ„›\nÎ”\no\n=\nâ„›\nÎ”\no\n,\n+\nâˆ©\nâ„›\nÎ”\no\n,\nâˆ’\n\\mathcal{R}^{o}_{\\Delta}=\\mathcal{R}^{o,+}_{\\Delta}\\cap\\mathcal{R}^{o,-}_{\\Delta}\n.\nSince an MRS is generally non-convex, we need to approximate it with a convex set,\nâ„›\n^\nÎ”\no\n\\hat{\\mathcal{R}}^{o}_{\\Delta}\n, to use it within the GCS framework\n1\n1\n1\nSince our convex-approximated sets\nâ„›\n^\nÎ”\no\n\\hat{\\mathcal{R}}^{o}_{\\Delta}\nbelong to\nSE\nâ€‹\n(\n2\n)\n\\mathrm{SE}(2)\n, which is non-Euclidean, the notion of convexity requires precise mathematical justification. See\nSection\nA-E\n.\n. We can find a convex polytope that is approximately contained in the MRS using IRIS-ZO\n[\n49\n]\n, a fast stochastic algorithm. IRIS-ZO guarantees the resulting\nâ„›\n^\nÎ”\no\n\\hat{\\mathcal{R}}^{o}_{\\Delta}\nto be\nÏµ\n\\epsilon\n-correct, where correctness refers to the volume of\nâ„›\n^\nÎ”\no\n\\hat{\\mathcal{R}}^{o}_{\\Delta}\nexceeding\nâ„›\nÎ”\no\n\\mathcal{R}^{o}_{\\Delta}\ndivided by the volume of\nâ„›\nÎ”\no\n\\mathcal{R}^{o}_{\\Delta}\n, and\nÏµ\n\\epsilon\ncan be specified. The\nÏµ\n\\epsilon\n-correctness is desirable, as introducing unreachable states into\nâ„›\n^\nÎ”\no\n\\hat{\\mathcal{R}}^{o}_{\\Delta}\nadversely affects planning (\nSection\nIV\n).\nIII-B\nCovering Object Space with MRS\n(a)\n5 MRS\n(b)\n10 MRS\n(c)\n15 MRS\n(d)\n25 MRS\nFigure 6:\nIllustration of object space covering algorithm (\nAlgorithm\n2\n) in\nSE\nâ€‹\n(\n2\n)\n\\mathrm{SE}(2)\nat different iterations.\nInput:\nCover fraction\nÎ±\nâˆˆ\n[\n0\n,\n1\n)\n\\alpha\\in[0,1)\n, resolution\nÎ”\nâˆˆ\nâ„\n\\Delta\\in\\mathbb{R}\nOutput:\nCollection of sets\nC\n=\n{\nâ„›\n^\nÎ”\no\n,\ni\n}\ni\n=\n1\n|\nC\n|\nC=\\{\\hat{\\mathcal{R}}_{\\Delta}^{o,i}\\}_{i=1}^{\\lvert C\\rvert}\n1\nC\nâ†\ncollection\nâ€‹\n(\n)\nC\\leftarrow\\texttt{collection}()\n;\n2\nwhile\nvol\nâ€‹\n(\nâ‹ƒ\ni\n=\n1\n|\nC\n|\nâ„›\n^\nÎ”\no\n,\ni\n)\nvol\nâ€‹\n(\nğ’¬\no\n)\nâ‰¤\nÎ±\n\\dfrac{\\mathrm{vol}\\left(\\bigcup_{i=1}^{\\lvert C\\rvert}\\hat{\\mathcal{R}}^{o,i}_{\\Delta}\\right)}{\\mathrm{vol}(\\mathcal{Q}^{o})}\\leq\\alpha\ndo\n//\nsample uncovered\n3\nq\nseed\no\nâˆ¼\nUniform\nâ€‹\n(\nğ’¬\no\nâˆ–\nâ‹ƒ\ni\n=\n1\n|\nC\n|\nâ„›\n^\nÎ”\no\n,\ni\n)\nq^{o}_{\\text{seed}}\\sim\\mathrm{Uniform}\\left(\\mathcal{Q}^{o}\\setminus\\bigcup_{i=1}^{\\lvert C\\rvert}\\hat{\\mathcal{R}}^{o,i}_{\\Delta}\\right)\n;\n4\nq\nseed\nâ†\nGenerateGrasp\nâ€‹\n(\nq\nseed\no\n)\nq_{\\text{seed}}\\leftarrow\\texttt{GenerateGrasp}(q^{o}_{\\text{seed}})\n;\n5\nâ„›\n^\nÎ”\no\n,\n|\nC\n|\n+\n1\nâ†\nComputeConvexApproximatedMRS\nâ€‹\n(\nq\nseed\n,\nÎ”\n)\n\\hat{\\mathcal{R}}^{o,\\lvert C\\rvert+1}_{\\Delta}\\leftarrow\\texttt{ComputeConvexApproximatedMRS}(q_{\\text{seed}},\\Delta)\n;\n6\nC\n.\nadd\nâ€‹\n(\nâ„›\n^\nÎ”\no\n,\n|\nC\n|\n+\n1\n)\nC.\\texttt{add}\\left(\\hat{\\mathcal{R}}^{o,\\lvert C\\rvert+1}_{\\Delta}\\right)\n;\n7\n8\nreturn\nC\nC\n;\nAlgorithmÂ 2\nComputeObjectSpaceCover\nGiven the ability to compute an approximate MRS from a single seed, we now seek to build an\nÎ±\n\\alpha\n-approximate cover of the object space\nğ’¬\no\n\\mathcal{Q}^{o}\n.\nDefinition 2\n.\nFollowing\n[\n49\n]\n, an\nÎ±\n\\alpha\n-approximate cover\nof\nQ\no\nQ^{o}\nis a collection of convex sets\nâ„›\n^\nÎ”\no\n,\n1\n,\nâ€¦\n,\nâ„›\n^\nÎ”\no\n,\nN\nâŠ†\nQ\no\n\\hat{\\mathcal{R}}_{\\Delta}^{o,1},\\ldots,\\hat{\\mathcal{R}}_{\\Delta}^{o,N}\\subseteq Q^{o}\nwhose union covers at least an\nÎ±\n\\alpha\n-fraction of its volume:\nvol\nâ€‹\n(\nâˆª\ni\n=\n1\nğ‘\nâ€‹\nâ„›\n^\nÎ”\no\n,\ni\n)\nâ‰¥\nÎ±\nâ‹…\nvol\nâ€‹\n(\nQ\no\n)\n\\mathrm{vol}\\left(\\overset{N}{\\underset{i=1}{\\cup}}\\hat{\\mathcal{R}}_{\\Delta}^{o,i}\\right)\\geq\\alpha\\cdot\\mathrm{vol}(Q^{o})\n(13)\nThe closer\nÎ±\n\\alpha\nis to 1, the better: this increases the likelihood that a query\n(\nq\nstart\no\n,\nq\ngoal\no\n)\n(q^{o}_{\\text{start}},q^{o}_{\\text{goal}})\nis contained in some MRS and that our planner can be run. Higher\nÎ±\n\\alpha\nleads to higher planning success rates.\nWe construct the cover iteratively (\nAlgorithm\n2\n,\nFigure\n6\n). At each iteration, we sample the uncovered region of\nğ’¬\no\n\\mathcal{Q}^{o}\nto obtain a new seed object configuration\nq\nseed\no\nq^{o}_{\\text{seed}}\n. We then generate a grasp for\nq\nseed\no\nq^{o}_{\\text{seed}}\n, yielding a full configuration\nq\nseed\nq_{\\text{seed}}\n. The grasp generation technique is system and task specific and detailed in\nSection\nA-D\n. From this\nq\nseed\nq_{\\text{seed}}\n, we construct an approximate MRS (\nAlgorithm\n1\n). Under mild assumptions, this procedure is probabilistically complete (see\nSection\nA-F\nfor proof). Adding more sets can monotonically increase coverage of\nğ’¬\no\n\\mathcal{Q}^{o}\n, converging to full coverage.\nIII-C\nLinking MRS Into a Graph\n(a)\nToy example\n(b)\nGCS graph\n(c)\nOnline: Stage 1\n(d)\nOnline: Stage 1 in GCS graph\n(e)\nOnline: Stage 2, first steps\n(f)\nOnline: Stage 2, next steps\nFigure 7:\nIllustration of online planning with a toy example. First row: example of 3 MRS in 2D object space.\nSecond row: show the first stage of hierarchical planning, producing an optimal object plan. It consists of an MRS sequence (\nFigure\n7d\n) and a continuous object path (\nFigure\n7c\n).\nThird row: shows the second stage of hierarchicla planner, translating the object plan to manipulator inputs. In\nFigure\n7e\n, shown in purple, we compute the initial grasp with\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâˆ’\n1\n\\mathbf{proj}^{-1}_{\\mathcal{Q}^{o}}\nand then track the first transfer segment\n(\nx\n1\nin\n,\nx\n2\nin\n)\n(x^{\\text{in}}_{1},x^{\\text{in}}_{2})\nwith\nÏ€\n\\pi\n. In\nFigure\n7f\n, we find the next grasp with\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâˆ’\n1\n\\mathbf{proj}^{-1}_{\\mathcal{Q}^{o}}\nand then compute the transit with\nÏˆ\n\\psi\n.\nWe shorten the set notation from\nâ„›\n^\nÎ”\no\n,\ni\n\\hat{\\mathcal{R}}^{o,i}_{\\Delta}\nto\nâ„›\ni\n\\mathcal{R}^{i}\n. Supposing we have\nN\nN\nsuch sets\n{\nâ„›\ni\n}\ni\n=\n1\nN\n\\{\\mathcal{R}^{i}\\}_{i=1}^{N}\nfrom the prior section, we can now define a planning graph over them. See the first row in\nFigure\n7\nfor a illustrated example.\nFirst, recall that we consider two types of motion (\nSection\nII-B\n): â€œtransferâ€ motions, where the manipulator moves the object, and â€œtransitâ€ motions, where the object is kept stationary during a regrasp. We handle these motions differently when building the graph.\nIn order to build a smaller GCS graph with fewer edges, we represent transfer motions as graph vertices, rather than edges. Namely, for each convex set\nâ„›\ni\n\\mathcal{R}^{i}\n, we define abstract vertex\nv\ni\nv_{i}\nwith continuous state\nx\nv\ni\n=\n[\nx\nv\ni\nin\nx\nv\ni\nout\n]\nT\nâˆˆ\nâ„›\ni\nÃ—\nâ„›\ni\nx_{v_{i}}=\\begin{bmatrix}x_{v_{i}}^{\\text{in}}&x_{v_{i}}^{\\text{out}}\\end{bmatrix}^{T}\\in\\mathcal{R}^{i}\\times\\mathcal{R}^{i}\n.\nx\nv\ni\nin\nx_{v_{i}}^{\\text{in}}\nand\nx\nv\ni\nout\nx_{v_{i}}^{\\text{out}}\nare interpreted as the endpoints of a motion segment inside\nâ„›\ni\n\\mathcal{R}^{i}\n. The associated vertex cost\nâ„“\nv\ni\nâ€‹\n(\nx\nv\ni\n)\n\\ell_{v_{i}}(x_{v_{i}})\nrepresents the task cost (\nEquation\n4\n) of moving the object from\nx\nv\ni\nin\nx_{v_{i}}^{\\text{in}}\nto\nx\nv\ni\nout\nx_{v_{i}}^{\\text{out}}\nusing\nÏ€\n\\pi\n.\nFor transit motions, we assume a regrasp is possible between any two configurations\nq\ni\n,\nq\nj\nq_{i},q_{j}\nwith the same object configuration (\nq\ni\no\n=\nq\nj\no\nq_{i}^{o}=q_{j}^{o}\n). This means that for all intersecting MRS\nâ„›\ni\n\\mathcal{R}^{i}\nand\nâ„›\nj\n\\mathcal{R}^{j}\n, we add two directed edges. We add an edge\ne\ni\nâ€‹\nj\n=\n(\nv\ni\n,\nv\nj\n)\ne_{ij}=(v_{i},v_{j})\n, with constraint\nx\nv\ni\nout\n=\nx\nv\nj\nin\nx^{\\text{out}}_{v_{i}}=x^{\\text{in}}_{v_{j}}\n. The associated edge cost\nâ„“\ne\ni\nâ€‹\nj\nâ€‹\n(\nx\nv\ni\n,\nx\nv\nj\n)\n\\ell_{e_{ij}}(x_{v_{i}},x_{v_{j}})\nrepresents the task cost (\nEquation\n4\n) of moving the system from\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâˆ’\n1\nâ€‹\n(\nx\nv\ni\nout\n,\nâ„›\ni\n)\n\\mathbf{proj}^{-1}_{\\mathcal{Q}^{o}}(x^{\\text{out}}_{v_{i}},\\mathcal{R}^{i})\nto\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâˆ’\n1\nâ€‹\n(\nx\nv\nj\nin\n,\nâ„›\nj\n)\n\\mathbf{proj}^{-1}_{\\mathcal{Q}^{o}}(x^{\\text{in}}_{v_{j}},\\mathcal{R}^{j})\nusing\nÏˆ\n\\psi\n. The second edge\ne\nj\nâ€‹\ni\ne_{ji}\nis defined analogously.\nFinally, given a query\n(\nq\nstart\no\n,\nq\ngoal\no\n)\n(q^{o}_{\\text{start}},q^{o}_{\\text{goal}})\n, we can incorporate it into the graph by adding singleton sets\nv\nstart\nâ‰”\n{\nq\nstart\no\n}\nv_{\\text{start}}\\coloneqq\\{q^{o}_{\\text{start}}\\}\nand\nv\ngoal\nâ‰”\n{\nq\ngoal\no\n}\nv_{\\text{goal}}\\coloneqq\\{q^{o}_{\\text{goal}}\\}\nto the graph and connecting them to any set which contains them.\nNamely, we create zero-cost edges\ne\nstart\n,\ni\n=\n(\nv\nstart\n,\nv\ni\n)\ne_{\\text{start},i}=(v_{\\text{start}},v_{i})\nfor all\ni\ni\nsuch that\nq\nstart\no\nâˆˆ\nâ„›\ni\nq^{o}_{\\text{start}}\\in\\mathcal{R}^{i}\n, and\ne\ni\n,\ngoal\n=\n(\nv\ni\n,\nv\ngoal\n)\ne_{i,\\text{goal}}=(v_{i},v_{\\text{goal}})\nfor all\ni\ni\nsuch that\nq\ngoal\no\nâˆˆ\nâ„›\ni\nq^{o}_{\\text{goal}}\\in\\mathcal{R}^{i}\n.\nIII-D\nFitting Surrogate GCS Vertex and Edge Costs\nA key design question is how to assign costs to GCS vertices and edges.\nEach GCS vertex and edge specifies only the start and goal configurations of a transit or transfer motion. To evaluate their corresponding task costs, we must therefore run a local planner (\nÏ€\n,\nÏˆ\n\\pi,\\psi\n) to generate a physically realizable trajectory between these configurations. As a result, vertex and edge task costs are only available as\nblack-box\nfunctions, since evaluating them requires executing a planner.\nHowever, GCS requires vertex and edge costs to be non-negative and convex. To satisfy these requirements, we fit non-negative, convex surrogate cost functions to samples of the black-box task cost. This fitting is performed independently for each edge using least-squares regression (see\nSection\nA-G\nfor details).\n(a)\nStage 1: object-space planning over MRS graph\n(b)\nStage 2: translation to full configurations and inputs\nFigure 8:\nIllustration of online hierarchical planning.\nIV\nMethodology - Online Hierarchical Planning\nIn the previous section, we described an offline procedure for constructing a planning graph of mutually reachable sets in object space. We now introduce the hierarchical, multi-query planner that uses this graph to compute plans. The planner operates in two stages: (1) computing an object-space plan over the graph using GCS, and (2) translating this object plan into a full configuration (object and manipulator) plan and manipulator control sequence. This design has three advantages: approximately optimal plans, sub-minute query times, and high planning success rates across diverse queries.\nFirstly, the planner produces optimal object paths and\napproximately optimal\nfull-space plans. While it is difficult to formally bound the suboptimality of the full-space plans, experiments show a 66% reduction in task cost compared to the SOTA baseline. This suggests that object-space optimization is an effective proxy for full-space planning.\nSecondly, the planner achieves fast query times by performing the computationally expensive discrete search in low-dimensional object space rather than full configuration space. This is sensible, as much of the full space is redundant or irrelevant to manipulation tasks. The GCS search typically completes within a second (\nSection\nV-B\n3\n), and the remaining translation steps rely on contact-aware trajectory optimization and collision-free motion planning, which are both well-established and efficient routines. Hence, overall, the planner can obtain sub-minute query times.\nThirdly, the planner achieves a high planning success rate, reliably producing plans that are kinematically and dynamically feasible under the dynamics (\n17\n). A common limitation of hierarchical planners is that high-level plans often become infeasible at lower levels, as the high-level typically ignores kinematic and dynamic constraints. Our approach avoids this issue by design. To see this, recall that object plans contain both transfer and transit segments. Now, transfer segments are within reachable sets, which, by definition, correspond to physically feasible motions\n(\nLemma\n1\n). Next, we always assume transit segments are feasible (\nSection\nIII-C\n). This is often a safe assumption in\nSE\nâ€‹\n(\n2\n)\n\\mathrm{SE}(2)\n, since a regrasp can be performed by letting go of the object and finding a collision-free path to the next grasp.\n2\n2\n2\nIn\nSE\nâ€‹\n(\n3\n)\n\\mathrm{SE}(3)\n, there may be an additional challenge of keeping the object stationary during a regrasp.\nHence, our object plans are largely translatable to valid manipulator plans.\nOverall, this design provides a fast and dependable framework for global planning in contact-rich manipulation. We describe the two stages of planning in detail below.\nIV-A\nStage 1: Object-Space Planning Over the MRS Graph\nGiven a query\n(\nq\nstart\no\n,\nq\ngoal\no\n)\n(q_{\\text{start}}^{o},q_{\\text{goal}}^{o})\n, we first augment the precomputed MRS graph with the start and goal nodes, then run GCS to solve for an optimal object trajectory\nq\n0\n:\nÏ„\no\nq^{o}_{0:\\tau}\nalong with the associated sequence of reachable sets\nâ„›\n0\n:\nÏ„\nâˆ’\n1\n\\mathcal{R}^{0:\\tau-1}\n. See\nFigure\n7c\nand\nFigure\n7d\nfor an illustration on a toy example.\nIV-B\nStage 2: Translation to Full Configurations and Inputs\n1\nInput:\nObject trajectory\nq\n0\n:\nÏ„\no\nq_{0:\\tau}^{o}\n, sequence of sets\nâ„›\n0\n:\nÏ„\nâˆ’\n1\n\\mathcal{R}^{0:\\tau-1}\n;\n2\nOutput:\nControl trajectory\nu\n0\n:\nÏ„\nâ€²\n{u}_{0:\\tau^{{}^{\\prime}}}\n;\n/*\nInitialize state and output  */\n3\nq\nâ†\nğ©ğ«ğ¨ğ£\nâ„›\n0\nâˆ’\n1\nâ€‹\n(\nq\n0\no\n)\nq\\leftarrow\\mathbf{proj}^{-1}_{\\mathcal{R}^{0}}(q_{0}^{o})\n;\n4\nu\ntraj\nâ†\nlist()\nu_{\\text{traj}}\\leftarrow\\texttt{list()}\n;\n5\nfor\nt\n=\n0\n,\nâ€¦\n,\nÏ„\nâˆ’\n2\nt=0,\\dots,\\tau-2\ndo\n/*\nGenerate contact segment  */\n6\nu\n0\n:\nÏ„\nÏ€\nâ†\nÏ€\nâ€‹\n(\nq\n,\nq\nt\n+\n1\no\n)\nu_{0:\\tau_{\\pi}}\\leftarrow\\pi(q,q^{o}_{t+1})\n;\n7\nu\ntraj\n.\nu_{\\text{traj}}.\nextend\n(\nu\n0\n:\nÏ„\nÏ€\n)\n(u_{0:\\tau_{\\pi}})\n;\n/*\nGenerate grasp for next set  */\n8\nq\nâ€²\nâ†\nğ©ğ«ğ¨ğ£\nâ„›\nt\n+\n1\nâˆ’\n1\nâ€‹\n(\nq\nt\n+\n2\no\n)\nq^{\\prime}\\leftarrow\\mathbf{proj}^{-1}_{\\mathcal{R}^{t+1}}(q^{o}_{t+2})\n;\n/*\nGenerate regrasp segment  */\n9\nu\n0\n:\nÏ„\nÏˆ\nâ†\nÏˆ\nâ€‹\n(\nq\n,\nq\nâ€²\n)\nu_{0:\\tau_{\\psi}}\\leftarrow\\psi(q,q^{\\prime})\n;\n10\nu\ntraj\n.\nu_{\\text{traj}}.\nextend\n(\nu\n0\n:\nÏ„\nÏˆ\n)\n(u_{0:\\tau_{\\psi}})\n;\n/*\nUpdate current state  */\n11\nq\nâ†\nq\nâ€²\nq\\leftarrow q^{\\prime}\n;\n12\n/*\nGenerate final contact segment  */\n13\nu\n0\n:\nÏ„\nÏ€\nâ†\nÏ€\nâ€‹\n(\nq\n,\nq\nÏ„\no\n)\nu_{0:\\tau_{\\pi}}\\leftarrow\\pi(q,q^{o}_{\\tau})\n;\n14\nu\ntraj\n.\nu_{\\text{traj}}.\nextend\n(\nu\n0\n:\nÏ„\nÏ€\n)\n(u_{0:\\tau_{\\pi}})\n;\nreturn\nu\ntraj\nu_{\\text{traj}}\nAlgorithmÂ 3\nTranscription of GCS plan\nGiven the object-space plan from StageÂ 1, this stage computes the corresponding full configuration space path\nq\n0\n:\nÏ„\nâ€²\nq_{0:\\tau^{{}^{\\prime}}}\nand control sequence\nu\n0\n:\nÏ„\nâ€²\nu_{0:\\tau^{{}^{\\prime}}}\n. As outlined in\nAlgorithm\n3\n, the procedure alternates between transfer (moving the object within an MRS) and transit (regrasping between MRS).\nDuring each transfer phase, we use the contact-aware trajectory optimizer\nÏ€\n\\pi\n(CQDC-MPC) to track the object path by moving the object using the manipulator. For the transit phase, the new grasp is computed using the inverse projection operator defined in\nSection\nII-C\nand a collision-free path to this grasp is generated using\nÏˆ\n\\psi\n(BiRRT). See\nFigure\n7e\nand\nFigure\n7f\nfor an illustration on a toy example.\nIV-C\nOptimality\nOverall, the object path found by GCS is effectively optimal with respect to the fitted task cost, up to the choice of set cover and continuous path parametrization. As shown in\nSection\nV-B\n1\n, the suboptimality gap between GCS and the optimal MIP solution is negligible. Formal guarantees for the corresponding configuration-space path are harder to make, since GCS optimizes an approximation of the true task cost (\nSection\nIII-D\n). Nonetheless, our experiments show that the resulting configuration-space paths consistently outperform a SOTA baseline (\nSection\nV-B\n1\n).\nIV-D\nSources of Planning Failure\nWe now list the main sources of planning failure,\nwhich generally stem from imperfections in the offline graph construction.\n1.\nIn Stage 1, the start or goal object poses (\nq\nstart\no\nq^{o}_{\\text{start}}\nor\nq\ngoal\no\nq^{o}_{\\text{goal}}\n) may fall outside the graphâ€™s coverage, even if the manipulator can kinematically reach them. This occurs because the graph only provides an\napproximate\ncover of the object workspace.\n2.\nIn Stage 2, translation of a transfer segment may fail if the target object pose is kinematically or dynamically unreachable. This can happen because the convex-approximated MRS include some unreachable states due to discretization and convexification errors.\n3.\nIn Stage 2, grasp generation may fail for similar reasons: the object pose of the regrasp target configuration may be unreachable.\n4.\nIn Stage 2, translation of a transit segment may fail when no collision-free regrasp path exists. While our planner assumes such a path is always available, occasional failures occur when the manipulators become trapped around the object or the environment geometry before the intended regrasp (\nFigure\n14\n).\nIV-E\nSampling Multiple Object Paths to Mitigate Failure\nSince all failure modes except the first can be avoided with a different choice of object path, we address them altogether by sampling multiple candidate object paths in Stage 1. While GCS normally returns the single lowest-cost object path, it also provides traversal probabilities for each edge in the optimal flow (the dual of the shortest-path problem). These probabilities let us sample additional suboptimal paths, with sampling likelihood inversely proportional to their task cost. We then translate all sampled object paths through Stage 2 and select the lowest-cost feasible one. This strategy is highly parallelizable, allowing us to notably improve success rates without significantly increasing wall-clock time (see ablation study in\nSection\nVI-\n1\n).\nV\nPlanning Experiments\nIn this and the following two sections, we present our experimental results. We begin here by comparing our approach, Graph of Reachable Sets (GRS), against a state-of-the-art sampling-based planner, ContactRRT\n[\n44\n]\n, to address three key questions:\n1.\nDoes our global optimization strategy lead to higher-quality plans than SOTA?\n2.\nDoes our object-centric approach enable sub-minute query times?\n3.\nDoes the use of reachable sets produce kinematically and dynamically feasible plans across a range of queries?\nWe find that our new planning paradigm excels along all three frontsâ€”producing higher-quality plans, maintaining sub-minute query times, and reliably generating a plans for different queries. We also analyze which design choices account for these improvements upon SOTA.\nNext, in Sec.\nVI\n, we validate that two of our add-on features further boost plan quality and success rates. We conclude that these additions to our core algorithm are crucial to elevating performance from good to excellent.\nFinally, in Sec.\nVII\n, we transfer our plans to hardware. Most plans are executed reliably, but some struggle at regrasps due to precision issues in\nÏ€\n\\pi\n. We detail these challenges and suggest some potential fixes for future work.\n(a)\nNumber MRS vs. task cost\n(b)\nPlanning success rate\n(c)\nOffline time\nFigure 9:\nPerformance and compute time versus the number of MRS sets in the graph.\nPerformance increases almost monotonically as more sets are added, providing a simple knob to trade off offline compute for higher-quality plans.\nV-A\nExperimental Setup\nV-A\n1\nSystem and Task\nOur system and task are specified in Sec.\nII-E\n. We take goal tolerance\nr\n=\n0.1\nr=0.1\n(\nSection\nII-A\n) and use the task cost in (\n5\n).\nV-A\n2\nHardware and Implementation Details\nThe experiments are run on a desktop with an Intel(R) Core(TM) i9-9980XE CPU (18 cores, 36 threads) and 125 GB of RAM. The code is implemented in Python, with parallelization from Ray, optimization programs from Drake, GCS implementation from Drake, CQDC-MPC from\n[\n44\n]\n, and RRT-Connect from\n[\n25\n]\n. We simulate the controlled system by forward propagating the dynamics (\n17\n) under the action of an open-loop controller executing the action sequence.\nV-A\n3\nBaselines\nFor our baseline, we use ContactRRT\n[\n40\n]\n, a SOTA sampling-based planner for contact-rich manipulation. It is a variant of RRT\n[\n27\n]\nwith a contact-aware trajectory optimizer for the â€œextendâ€ operation, which provides efficient exploration along the contact manifold. After the RRT step, it performs short-cutting to improve the plan. However, in the contact-rich setting, opportunities for short-cutting are limited because transitions cannot occur between arbitrary full configurationsâ€”their object configuration must match. Conveniently, ContactRRT uses our same contact-aware trajectory optimizer (CQDC-MPC) as a subroutine, so this allows us to directly compare our global planning strategies. While ContactRRTâ€™s global strategy focuses on finding feasible paths, GRS additionally seeks\noptimal\npaths. We tune the hyperparameters for both GRS and ContactRRT and report results using the best-performing combinations (see\nSection\nA-I\nfor details).\nV-A\n4\nMetrics\nWe generate a test set of 250 queries, where\nq\nstart\no\n,\nq\ngoal\no\nq^{o}_{\\text{start}},q^{o}_{\\text{goal}}\nare sampled uniformly from the kinematic object workspace (Fig.\n4\n). The following metrics are computed over the whole test set. To understand plan quality, we propose three metrics:\n1.\nTask Cost: choice of cost function that defines the task, in the form of (\n4\n). See Sec.\nII-A\nfor examples.\n2.\nObject Travel Distance Ratio: from\n[\n12\n]\n, this is the total object travel distance divided by the straight-line start-to-goal distance:\nÏ\nt\nâ€‹\nr\nâ€‹\na\nâ€‹\nv\nâ€‹\ne\nâ€‹\nl\n=\nâˆ‘\nt\n=\n1\nT\nâˆ’\n1\nâˆ¥\nq\nt\no\n,\nâˆ—\nâˆ’\nq\nt\n+\n1\no\n,\nâˆ—\nâˆ¥\nâˆ¥\nq\ns\nâ€‹\nt\nâ€‹\na\nâ€‹\nr\nâ€‹\nt\no\nâˆ’\nq\ng\nâ€‹\no\nâ€‹\na\nâ€‹\nl\no\nâˆ¥\n.\n\\displaystyle\\rho_{travel}=\\frac{\\sum_{t=1}^{T-1}\\lVert q^{o,*}_{t}-q^{o,*}_{t+1}\\rVert}{\\lVert q^{o}_{start}-q^{o}_{goal}\\rVert}.\n(14)\n3.\nRobot Contact Change Ratio: from\n[\n12\n]\n, this is the total number of regrasps divded by the configuration path length:\nÏ\nc\nâ€‹\no\nâ€‹\nn\nâ€‹\nt\nâ€‹\na\nâ€‹\nc\nâ€‹\nt\n=\n#\nâ€‹\nof regrasps\nâˆ‘\nt\n=\n1\nT\nâˆ’\n1\nâˆ¥\nq\nt\nâˆ—\nâˆ’\nq\nt\n+\n1\nâˆ—\nâˆ¥\n.\n\\displaystyle\\rho_{contact}=\\frac{\\#\\;\\text{of regrasps}}{\\sum_{t=1}^{T-1}\\lVert q^{*}_{t}-q^{*}_{t+1}\\rVert}.\n(15)\nWe also compute:\n4.\nOffline Time: time to build the graph offline,\n5.\nQuery Time: time of plan inference online,\n6.\nPlanning Success Rate: the percent of queries for which the planner finds a kinematically and dynamically feasible solution.\nV-B\nResults and Discussion\n(a)\n(b)\n(c)\n(d)\n(e)\n(f)\n(g)\n(h)\nFigure 10:\nIllustration of planner rollouts for GRS (left column) and Contact-RRT (right column) on a given query. The images in each column show alternating transfer and transit segments, with the target object orientation overlaid. Both planners produce dexterous, contact-rich behavior (e.g., rolling the bucket along the arm), but GRS uses fewer regrasps by selecting grasps that maximize the length of transfer motions.\n(a)\n(b)\n(c)\n(d)\n(e)\n(f)\n(g)\n(h)\n(i)\n(j)\n(k)\n(l)\nFigure 11:\nPlanner rollouts for GRS (left column) and Contact-RRT (middle and right columns) on another given query. The images in each column show alternating transfer and transit segments. This query requires a large rotation (nearly\n180\nâˆ˜\n180^{\\circ}\n). Contact-RRT requires one more regrasp than GRS, and the quality of its transfer motions also differs: while GRS moves the object along straight, goal-directed paths, Contact-RRT often produces curved or jagged paths that may momentarily move the object away from the goal due to its sampling-based exploration.\nTABLE I:\nOur method, GRS, compared to baseline ContactRRT on path quality, planning success rate, and query time over a test dataset of 250 randomly sampled queries.\nTask Cost\nObject Travel Distance Ratio\nRobot Contact Change Ratio\nPlanning Success Rate\nQuery Time (sec)\nContactRRT\n6.62\nÂ±\n5.41\n6.62\\pm 5.41\n3.70\nÂ±\n3.23\n3.70\\pm 3.23\n0.10\nÂ±\n0.094\n0.10\\pm 0.094\n82.4\n%\n82.4\\%\n62.04\nÂ±\n130.33\n62.04\\pm 130.33\nGRS (Ours)\n2.59\nÂ±\n1.47\n2.59\\pm 1.47\n1.19\nÂ±\n0.36\n1.19\\pm 0.36\n0.075\nÂ±\n0.11\n0.075\\pm 0.11\n91.2\n%\n91.2\\%\n40.34\nÂ±\n24.73\n40.34\\pm 24.73\nFigure 12:\nThree example plans (green, blue, purple) for GRS (solid line) and ContactRRT (dashed line). The goals are marked by â€œxâ€. Note that GRSâ€™s plans tend to be concise, whereas ContactRRTâ€™s tend to be circuitous.\nV-B\n1\nPath Quality\nWe first evaluate the quality of our planned paths. Our object-space plans are effectively optimal with respect to the fitted task cost, up to the choice of set cover and continuous path parameterization. As shown in (\n16\n), the object plans computed using GCS are within 1% of the optimal MIP solutions in cost, while requiring only about 5% of MIPâ€™s runtime.\nÎ´\no\nâ€‹\np\nâ€‹\nt\n=\nğ’\nGCS\nâˆ’\nğ’\nMIP\nğ’\nMIP\n=\n0.0145\nÂ±\n0.0607\n\\displaystyle\\delta_{opt}=\\frac{\\mathcal{C}_{\\mathrm{GCS}}-\\mathcal{C}_{\\mathrm{MIP}}}{\\mathcal{C}_{\\mathrm{MIP}}}=0.0145\\pm 0.0607\n(16)\nAfter translating to full configuration space, the resulting plans remain\napproximately optimal\n, achieving substantially lower costs than the SOTA baseline. As summarized in Table\nI\n, GRS reduces the average task cost by nearly 61%, where the cost metric (\n5\n) measures path length in actuated configuration space, encouraging short robot trajectories and penalizing actuation effort. This strong correspondence between optimal object-space plans and high-quality full-space plans further validates our object-centric formulation.\nGRS also achieves significantly lower auxiliary costs that correlate with task performance. It yields a nearly 68% lower object travel distance ratio, meaning that not only are the paths in actuated space more succinct, but the object paths are too. As seen in Fig.\n12\n, ContactRRT often produces â€œswitchbackâ€ or meandering trajectories, while GRS produces short, direct paths. These kinds of paths reflect ContactRRTâ€™s random growth strategy. Evidently, ContactRRTâ€™s short-cutting offers limited improvement too, as it cannot address this underlying exploration bias. Additionally, GRS exhibits a 25% reduction in the robot contact-change ratio, since under our task metric, regrasps are costly and naturally minimized.\nComparing the two planners visually highlights their qualitative differences (Fig.\n10\n,\n11\n). GRSâ€™s superior path quality can also be explained by its ability to decompose a large reorientation into just a few screw motions. The GCS optimization selects grasps that maximize maneuverability along these intended screws. In essence, GRS leverages global optimization to generate concise, natural motions, often resembling those a human might use. We also observe the merits of the contact-rich manipulation paradigm: it has a substantial advantage over end-effector manipulation where rotation is involved. Large rotations can be accomplished by rolling along manipulator surfaces; end-effector manipulator is limited to small rotations.\nV-B\n2\nPlanning Success Rate\nWe evaluate planning success rate across a diverse test set of 250 queries, where\n(\nq\nstart\no\n,\nq\ngoal\no\n)\n(q^{o}_{\\text{start}},q^{o}_{\\text{goal}})\nare uniformly sampled from the kinematic object workspace (Fig.\n4\n). Planning success rate is defined as the percentage of queries for which the algorithm produces a kinematically and dynamically feasible plan. Possible sources of failure for GRS are discussed in Sec.\nIV-D\n.\nGRS achieves a nearly\n11\n%\n11\\%\nhigher success rate than ContactRRT. At first, this may seem surprising: the ContactRRT timeout was set high enough for all queries to complete, and sampling-based planners are typically good at exploring configuration space and finding solutions. However, a closer look at the failure cases reveals key differences in the two methods.\nIt turns out nearly all of ContactRRTâ€™s failures stem from transit failures. Like GRS, it assumes that arbitrary transits are feasible: i.e. that a collision-free path exists between any two grasps.\n3\n3\n3\nIn\nSE\nâ€‹\n(\n2\n)\n\\mathrm{SE}(2)\n, this is the only requirement for transit. Typically, maintaining static equilibrium of the object is also required. However, here, the object can simply be left resting on the plane.\nHowever, prior to transit, sometimes the manipulator gets trapped behind the object or stuck at a singularity (Fig.\n14\n). This is likely due to ContactRRTâ€™s step size - a large step is needed to explore the space efficiently, but such a step size can also send the arm to extreme configurations from which it is hard to transit.\nOn the other hand, GRS has high planning success rates by design.\nHierarchical planners often fail when their high-level plans cannot be translated into feasible low-level plans. This occurs if the high-level planner is unaware of feasibility constraints - but this is not the case for GRS. Its high-level object space planning uses reachable sets, which embed information about manipulator feasibility.\nSpecifically, each transfer segment within an object plan corresponds to a motion inside an MRS, which is feasible by definition (Lemma\n1\n). Each transit segment is assumed feasible, but unlike in ContactRRT, this assumption generally holds because GRS avoids problematic configurations prior to transit. This is because all configurations belong to an MRS, which by definition excludes singular or trapped states: each configuration must be able to reach the seed configuration, ensuring recoverability (\n1\n).\nV-B\n3\nOffline and Online Runtimes\nDuring offline graph construction, we use a set cover approximation constant of\nÎ±\n=\n0.98\n\\alpha=0.98\n(Sec.\nIII-B\n), resulting in a graph of 25 sets (Fig.\n6\n).\nComputing these discretized MRS requires about 800k total\n(\nq\n,\nu\n,\nq\n+\n)\n(q,u,q^{+})\nsimulation steps, which are generated while attempting to reach grid cells under the local trajectory optimizer\nÏ€\n\\pi\n. This corresponds to 22.25 hours of simulated time, or 1.72 hours of wall-clock time on our machine. Because we can attempt to reach each grid cell independently, MRS generation is highly parallelizable, resulting in short wall-clock times.\nPlan quality and success rate can be monotonically improved by increasing the number of MRS in the graph, at the cost of longer offline compute times (Fig.\n9\n). This highlights another advantage of our approach: it provides a natural way to trade off performance and computation by adjusting the granularity of the discrete decision space. Other popular methods lack this mechanism\n[\n11\n,\n18\n]\n.\nOnline, GRS computes most plans in under a minute, while ContactRRT takes 55% longer. This is as expected, since GRS is multi-query and has shifted much of the computational burden to the offline stage. Further, to breakdown the GRS runtime: running GCS takes\n0.71\n0.71\nseconds on average and translating the object path with\nÏ€\n\\pi\n,\nÏˆ\n\\psi\ntakes\n39.63\n39.63\nseconds.\nVI\nAblation Experiments\nIn this section, we validate that our two additional features contribute meaningfully to planning performance. We aim to answer the following questions:\n1.\nDoes path sampling improve success rate?\n2.\nDo fitted GCS costs improve plan quality?\nWe conduct an ablation study comparing planner performance with and without these features (Table\nII\n) and find that both yield noticeable performance gains.\nVI-\n1\nPath Sampling\nIn the variant with path sampling (\nâ€œAll featuresâ€\nin Table\nII\n), we sample up to 100 distinct paths, averaging\n9.53\nÂ±\n13.40\n9.53\\pm 13.40\nsamples per query.\nIn the variant without path sampling (\nâ€œWithout path samplingâ€\nin Table\nII\n), GCS returns only the single lowest-cost path. We find that including this feature improves the success rate by\n7.5\n%\n7.5\\%\n.\nThis result highlights the benefit of path sampling: it addresses multiple sources of failure simultaneously, including transfer failures caused by MRS mis-approximation and transit failures due to violated assumptions. Because these errors are difficult to eliminate completely, path sampling serves as a practical mitigation strategy. However, it does double the online runtime, so it can optionally be omitted.\nVI-\n2\nFitted Surrogate GCS Vertex and Edge Costs\nIn the run with fitted GCS costs (\nâ€œAll featuresâ€\nin Table\nII\n), we generate costs using the procedure in Sec.\nIII-D\n.\nIn the run without fitted costs (\nâ€œWithout fitted GCS costsâ€\nin Table\nII\n), we use simple heuristic costs: a constant edge cost of 10 for regrasps, and an\nâ„“\n2\n\\ell_{2}\n-norm cost for move-object edges.\nWe find that using fitted costs reduces overall plan cost by\n5.79\n%\n5.79\\%\n, confirming that learned cost models serve as better proxies for true task costs than heuristics.\nOverall, these results show that path sampling and fitted GCS costs improve success rate and average plan cost by roughly\n8\n%\n8\\%\nand\n6\n%\n6\\%\n, respectively. Given the competitiveness of the SOTA baseline, these gains represent a meaningful improvement in planner capability.\nTABLE II:\nAblation study to determine efficacy of two features: path sampling and fitted GCS costs. Statistics computed over a testset of 250 randomly sampled queries.\nTask Cost\nPlanning\nSuccess Rate\nQuery Time\n(seconds)\nAll features\n2.59\nÂ±\n1.47\n2.59\\pm 1.47\n91.2\n%\n91.2\\%\n40.34\nÂ±\n24.73\n40.34\\pm 24.73\nNo path sampling\n2.97\nÂ±\n2.09\n2.97\\pm 2.09\n84.8\n%\n84.8\\%\n19.11\nÂ±\n13.70\n19.11\\pm 13.70\nNo fitted GCS costs\n2.74\nÂ±\n1.89\n2.74\\pm 1.89\n87.6\n%\n87.6\\%\n27.32\nÂ±\n28.50\n27.32\\pm 28.50\nVII\nHardware Experiments\n(a)\n(b)\n(c)\nFigure 13:\nKeyframes from a GRS plan executed on hardware, with the target orientation overlaid on all frames. This plan contains only one transfer segment. Observe the contact-rich behavior, especially in the final frame, where the full surface of the â€œhandâ€ is used to guide the object into precise alignment.\nFinally, we evaluate our approach on hardware. After computing the manipulator input sequence, we execute the plan open-loop. Rollouts without regrasps execute reliably (Fig.\n13\n), indicating that the CQDC dynamics model transfers well to hardware in our task regime (SE(2), slow motions).\nIn contrast, rollouts that include regrasps succeed only intermittently. Two factors contribute to regrasp failure: numerical imprecision when computing the new grasp, and state drift accumulated during open-loop execution. To explain these further, first suppose the planned state immediately before a regrasp is\nq\nq\n, and the next planned MRS is\nâ„›\nâ€²\n\\mathcal{R}^{\\prime}\n.\nRecall that the new grasp is computed using the local planner\nÏ€\n\\pi\n. Specifically, to ensure the grasp lies within\nâ„›\nâ€²\n\\mathcal{R}^{\\prime}\n, we use\nÏ€\n\\pi\nto reach from the seed of\nâ„›\nâ€²\n\\mathcal{R}^{\\prime}\nto the object state\nq\no\nq^{o}\n, which is assumed to remain stationary during the regrasp. However, due to limited numerical precision,\nÏ€\n\\pi\nmay only reach the target up to an accuracy of\nÏµ\nÏ€\n\\epsilon_{\\pi}\n, yielding an object mismatch\nd\nSE\nâ€‹\n(\n2\n)\nâ€‹\n(\nq\nâ€²\n,\no\n,\nq\no\n)\nâ‰¤\nÏµ\nÏ€\n.\nd_{\\mathrm{SE}(2)}(q^{\\prime,o},q^{o})\\leq\\epsilon_{\\pi}.\nAs a result, the manipulator may attempt to regrasp the object at a slightly offset pose. While small mismatches can sometimes be tolerated, larger deviations often cause the regrasp to fail.\nThe second source of failure is drift introduced during open-loop execution. The regrasp target is computed from the planned state\nq\nq\n, while execution error the true state\nq\n~\n\\tilde{q}\nto deviate, increasing misalignment at regrasp time. A straightforward remedy is to replan online rather than execute open-loop. In particular, the target grasp can be recomputed as\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâˆ’\n1\nâ€‹\n(\nq\n~\no\n,\nâ„›\nâ€²\n)\n\\mathbf{proj}^{-1}_{\\mathcal{Q}^{o}}(\\tilde{q}^{o},\\mathcal{R}^{\\prime})\ninstead of\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâˆ’\n1\nâ€‹\n(\nq\no\n,\nâ„›\nâ€²\n)\n\\mathbf{proj}^{-1}_{\\mathcal{Q}^{o}}(q^{o},\\mathcal{R}^{\\prime})\n. We leave this extension to future work.\nVIII\nConclusion\nIn this paper, we introduced an\nintermediate-level\ndiscrete decision space, mutual reachable sets, situated between traditional low-level contact modes and high-level motion primitives.\nThis abstraction is fine-grained enough to handle a wide range of queries, yet coarse enough to shrink the decision space dramatically, enabling optimal planning in object space.\nOur planner (GRS) outperforms a SOTA sampling-based planner on a challenging, representative contact-rich task. It achieves a\n61\n%\n61\\%\nreduction in task cost (producing more natural, concise plans with full-arm contact), a\n91\n%\n91\\%\nplanning success rate across 250 queries, and sub-minute query times. With our new planning paradigm, it is now possible to compute such contact-rich plans for tasks of real-world complexity.\nWe view this as a first step toward a broader family of reachable-set abstractions for planning. For example, we can imagine extensions to\nSE\nâ€‹\n(\n3\n)\n\\mathrm{SE}(3)\n, which will require new methods to handle Riemannian space.\nAppendix A\nAppendix\nA-A\nContact-Aware Trajectory Optimizer Details\nIn this section, we describe the CQDC trajectory optimization program and how we apply it in an MPC-fashion as a local planner.\nRecall that CQDC assumes a quasidynamic, discrete-time model\n[\n40\n]\n.\nq\n+\n=\nf\nâ€‹\n(\nq\n,\nu\n)\n\\displaystyle q_{+}=f(q,u)\n(17)\nWhen used for control, this model is locally smoothed and then linearized:\nq\n^\n+\n=\nğ€\nÎº\nâ€‹\nâˆ‚\nq\n+\nğ\nÎº\nâ€‹\nâˆ‚\nu\n+\nf\nÎº\nâ€‹\n(\nq\nÂ¯\n,\nu\nÂ¯\n)\n\\displaystyle\\hat{q}_{+}=\\mathbf{A_{\\kappa}}\\partial q+\\mathbf{B_{\\kappa}}\\partial u+f_{\\kappa}(\\bar{q},\\bar{u})\n(18)\nğ€\nÎº\n:=\nâˆ‚\nf\nÎº\n/\nâˆ‚\nq\nâ€‹\n(\nq\nÂ¯\n,\nu\nÂ¯\n)\n,\nğ\nÎº\n:=\nâˆ‚\nf\nÎº\n/\nâˆ‚\nu\nâ€‹\n(\nq\nÂ¯\n,\nu\nÂ¯\n)\n\\displaystyle\\mathbf{A_{\\kappa}}\\vcentcolon=\\partial f_{\\kappa}/\\partial q(\\bar{q},\\bar{u}),\\mathbf{B_{\\kappa}}\\vcentcolon=\\partial f_{\\kappa}/\\partial u(\\bar{q},\\bar{u})\n(19)\nâˆ‚\nq\n:=\nq\nâˆ’\nq\nÂ¯\n,\nâˆ‚\nu\n:=\nu\nâˆ’\nu\nÂ¯\n\\displaystyle\\partial q\\vcentcolon=q-\\bar{q},\\partial u\\vcentcolon=u-\\bar{u}\n(20)\nwhere\nf\nÎº\nf_{\\kappa}\nis the smoothed dynamics, implemented as a log-barrier relaxation of the forward convex program with parameter\nÎº\n\\kappa\n[\n6\n]\n.\nThe linearized model is constrained to a trust region\n[\n44\n]\n. Then, we form a convex trajectory optimization program where we provide a starting configuration\nq\n0\nq_{0}\n, a state reference trajectory\nq\nÂ¯\n0\n:\nT\n\\bar{q}_{0:T}\n, an input reference trajectory\nu\nÂ¯\n0\n:\nT\nâˆ’\n1\n\\bar{u}_{0:T-1}\n, and a goal configuration\nq\ngoal\nq_{\\text{goal}}\n. The initial guess for the first timestep is provided by a collection of heuristics; see\n[\n44\n]\nfor more details. This program solves for a control sequence\nâˆ‚\nu\n0\n:\nT\nâˆ’\n1\nâˆ—\n\\partial u_{0:T-1}^{*}\nthat reaches toward the goal and follows the reference.\nCQDCTrajOpt\nâ€‹\n(\nq\n0\n,\nq\nÂ¯\n0\n:\nT\n,\nu\nÂ¯\n0\n:\nT\nâˆ’\n1\n,\nq\ngoal\n)\n=\nâˆ‚\nu\n0\n:\nT\nâˆ’\n1\nâˆ—\n,\nwhere\n\\displaystyle\\text{CQDCTrajOpt}(q_{0},\\bar{q}_{0:T},\\bar{u}_{0:T-1},q_{\\text{goal}})=\\partial u_{0:T-1}^{*},\\text{where}\n(21)\nmin\nÎ´\nâ€‹\nq\n0\n:\nT\n,\nÎ´\nâ€‹\nu\n0\n:\nT\nâˆ’\n1\nâ€–\nq\ngoal\nâˆ’\nq\nT\nâ€–\nğ\n2\n+\nc\nâ€‹\n(\nq\n0\n:\nT\n)\n\\displaystyle\\min_{\\delta q_{0:T},\\delta u_{0:T-1}}\\quad\\|q_{\\text{goal}}-q_{T}\\|^{2}_{\\mathbf{Q}}+c(q_{0:T})\n(22)\ns.t.\nÎ´\nâ€‹\nq\nt\n+\n1\n=\nğ€\nÎº\n,\nt\nâ€‹\nÎ´\nâ€‹\nq\nt\n+\nğ\nÎº\n,\nt\nâ€‹\nÎ´\nâ€‹\nu\nt\n,\nt\n=\n0\nâ€‹\nâ€¦\nâ€‹\nT\nâˆ’\n1\n,\n\\displaystyle\\text{s.t.}\\quad\\delta q_{t+1}=\\mathbf{A}_{\\kappa,t}\\delta q_{t}+\\mathbf{B}_{\\kappa,t}\\delta u_{t},\\;t=0\\dots T-1,\n(23)\n(\nÎ´\nâ€‹\nq\nt\n,\nÎ´\nâ€‹\nu\nt\n)\nâˆˆ\nğ’®\n~\nğšº\n,\nÎº\nâ€‹\n(\nq\nÂ¯\nt\n,\nu\nÂ¯\nt\n)\n,\nt\n=\n0\nâ€‹\nâ€¦\nâ€‹\nT\nâˆ’\n1\n,\n\\displaystyle\\quad\\quad(\\delta q_{t},\\delta u_{t})\\in\\tilde{\\mathcal{S}}_{\\mathbf{\\Sigma,\\kappa}}(\\bar{q}_{t},\\bar{u}_{t}),\\;t=0\\dots T-1,\n(24)\nq\nt\n=\nq\nÂ¯\nt\n+\nÎ´\nâ€‹\nq\nt\n,\nt\n=\n0\nâ€‹\nâ€¦\nâ€‹\nT\n,\n\\displaystyle\\quad\\quad q_{t}=\\bar{q}_{t}+\\delta q_{t},\\;t=0\\dots T,\n(25)\nu\nt\n=\nu\nÂ¯\nt\n+\nÎ´\nâ€‹\nu\nt\n,\nt\n=\n0\nâ€‹\nâ€¦\nâ€‹\nT\nâˆ’\n1\n,\n\\displaystyle\\quad\\quad u_{t}=\\bar{u}_{t}+\\delta u_{t},\\;t=0\\dots T-1,\n(26)\n|\nu\nt\nâˆ’\nu\nt\nâˆ’\n1\n|\nâ‰¤\nÎ·\n,\nt\n=\n1\nâ€‹\nâ€¦\nâ€‹\nT\nâˆ’\n1\n,\n\\displaystyle\\quad\\quad|u_{t}-u_{t-1}|\\leq\\eta,\\;t=1\\dots T-1,\n(27)\nÎ´\nâ€‹\nq\n0\n=\n0\n,\n\\displaystyle\\quad\\quad\\delta q_{0}=0,\n(28)\nwhere\nğ’®\n~\nğšº\n,\nÎº\n\\tilde{\\mathcal{S}}_{\\mathbf{\\Sigma,\\kappa}}\nin (\n24\n) is a trust region.\nWe solve this program in an MPC fashion (CQDC-MPC)\nAlgorithm\n4\nto generate local plans. To improve goal-reaching reliability, we run each goal-reaching query with a set of different state reference trajectories. These trajectories all start at\nq\n0\nq_{0}\nand end with\nq\ngoal\nq_{\\text{goal}}\nbut may have different midpoints. We find that makes goal-reaching succeed more often.\n1\nInput:\nInitial state\nq\n0\nq_{0}\n, goal state\nq\ngoal\nq_{\\text{goal}}\n;\n2\nOutput:\nLists of visited states\nL\nq\nL_{q}\n, applied inputs\nL\nu\nL_{u}\n;\n3\nL\nq\nâ†\n[\nq\n0\n]\nL_{q}\\leftarrow[q_{0}]\n,\nL\nu\nâ†\nL_{u}\\leftarrow\nlist()\n;\n4\nfor\nt\n=\n0\nt=0\nto\nH\nâˆ’\n1\nH-1\ndo\n5\nif\nt\n=\n=\n0\nt==0\nthen\n6\nu\nÂ¯\n0\n:\nT\nâˆ’\n1\nâ†\n\\bar{u}_{0:T-1}\\leftarrow\nApply initial guess heuristics;\n7\nelse\n8\nu\nÂ¯\n0\n:\nT\nâˆ’\n1\nâ†\n\\bar{u}_{0:T-1}\\leftarrow\nInitialize from the previous\nu\n0\n:\nT\nâˆ’\n1\nâ‹†\nu_{0:T-1}^{\\star}\n;\n9\n10\nq\nÂ¯\n0\n:\nT\nâˆ’\n1\nâ†\n\\bar{q}_{0:T-1}\\leftarrow\nCompute state reference from\nq\nt\nq_{t}\n,\nq\ngoal\nq_{\\text{goal}}\n; ;\n11\nu\n0\n:\nT\nâˆ’\n1\nâ‹†\nâ†\nğ‚ğğƒğ‚ğ“ğ«ğšğ£ğğ©ğ­\n(\nq\nt\n,\nq\nÂ¯\n0\n:\nT\n,\nu\nÂ¯\n0\n:\nT\nâˆ’\n1\n,\nq\ngoal\nu_{0:T-1}^{\\star}\\leftarrow\\mathbf{CQDCTrajOpt}(q_{t},\\bar{q}_{0:T},\\bar{u}_{0:T-1},q_{\\text{goal}}\n);\n12\nq\nt\n+\n1\n=\nf\nâ€‹\n(\nq\nt\n,\nu\n0\nâ‹†\n)\nq_{t+1}=f(q_{t},u_{0}^{\\star})\n;\n13\nL\nq\nL_{q}\n.\nappend\n(\nq\nt\n+\n1\nq_{t+1}\n),\nL\nu\nL_{u}\n.\nappend\n(\nu\n0\nâ‹†\nu_{0}^{\\star}\n);\n14\nreturn\nL\nq\n,\nL\nu\n\\;L_{q},\\;L_{u}\nAlgorithmÂ 4\nMPC\nA-B\nCollision-Free Motion Planner Details\nFor collision free motion planning, we use use RRT-Connect\n[\n25\n]\nto generate a feasible collision-free path, and then refine with trajectory optimization. In this section, we elaborate on the trajectory optimization portion of the collision free planner.\nSuppose RRT-Connect returns the sequence of robot configurations which describe a collision free path for the robot that brings the system from\nq\n0\nq_{0}\nto\nq\nT\nq_{T}\nwithout making contact with the object. To minimize the length of the collision free path, we solve the following nonconvex optimization program:\nq\n0\n:\nT\na\n,\nâ‹†\n=\narg\nâ€‹\nmin\nq\n0\n:\nT\na\n\\displaystyle q^{a,\\star}_{0:T}=\\operatorname*{arg\\,min}_{q^{a}_{0:T}}\nâˆ‘\nt\n=\n0\nT\nâˆ’\n1\nâ€–\nq\nt\n+\n1\na\nâˆ’\nq\nt\na\nâ€–\nQ\n2\n\\displaystyle\\sum_{t=0}^{T-1}\\|q^{a}_{t+1}-q^{a}_{t}\\|^{2}_{Q}\n(29a)\ns.t.\nÏ•\nj\nâ€‹\n(\nq\nt\n)\nâ‰¥\nÏµ\n,\nâˆ€\nj\nâ€‹\nâˆ€\nt\n\\displaystyle\\phi_{j}(q_{t})\\geq\\epsilon,\\quad\\forall j\\;\\forall t\n(29b)\nq\nlb\na\nâ‰¤\nq\nt\na\nâ‰¤\nq\nub\na\n,\nâˆ€\nt\n\\displaystyle q^{a}_{\\text{lb}}\\leq q^{a}_{t}\\leq q^{a}_{\\text{ub}},\\quad\\forall t\n(29c)\nwhere\nQ\nQ\nis a cost matrix that penalizes robot movements,\nÏ•\nj\n\\phi_{j}\ndenotes the signed distance function for the\nj\nj\n-th collision pair,\nÏµ\n\\epsilon\ndenotes the minimum acceptable distance between the robot and the object, and\nq\nlb\na\nq^{a}_{\\text{lb}}\nand\nq\nub\na\nq^{a}_{\\text{ub}}\ndenote the lower and upper joint limits for the robot.\nWe solve this nonconvex program in an iterative manner, using sequential quadratic programming (SQP). In each iteration, constraint\nEquation\n29b\nis linearized around the solution to the previous iteration. We use RRT-Connectâ€™s output\nq\nÂ¯\n0\n:\nT\na\n\\bar{q}^{a}_{0:T}\nas an initial guess solution and return\nq\n0\n:\nT\na\n,\nâ‹†\nq^{a,\\star}_{0:T}\n.\nA-C\nProof of Lemma 1\nLemma 1\n.\nSuppose\nq\n1\no\nq^{o}_{1}\nand\nq\n2\no\nq^{o}_{2}\nare elements of the MRS\nâ„›\no\n\\mathcal{R}^{o}\n. Then\nq\n1\no\nq^{o}_{1}\nis reachable from\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâˆ’\n1\nâ€‹\n(\nq\n2\no\n,\nâ„›\no\n)\n\\mathbf{proj}_{\\mathcal{Q}^{o}}^{-1}(q^{o}_{2},\\mathcal{R}^{o})\n, and\nq\n2\no\nq^{o}_{2}\nis reachable from\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâˆ’\n1\nâ€‹\n(\nq\n1\no\n)\n\\mathbf{proj}_{\\mathcal{Q}^{o}}^{-1}(q^{o}_{1})\n.\nIn the following proof, we implicitly assume that if\nÏ€\n\\pi\ncan find a path between\nq\n1\nq_{1}\nand\nq\nseed\no\n)\nq^{o}_{\\text{seed}})\n, and also between\nq\nseed\nq_{\\text{seed}}\nand\nq\n2\no\nq^{o}_{2}\n, it can find a path between\nq\n1\nq_{1}\nand\nq\n2\no\nq^{o}_{2}\n. This is actually true by design of our\nÏ€\n\\pi\n, since for any query, we give it a reference trajectory with\nq\nseed\nq_{\\text{seed}}\nas a midpoint.\nProof.\nBy symmetry, it suffices to show that\nq\n2\no\nq^{o}_{2}\nis reachable from\nq\n1\no\nq_{1}^{o}\n.\nLet\nq\n1\n=\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâˆ’\n1\nâ€‹\n(\nq\n1\no\n,\nâ„›\no\n)\nq_{1}=\\mathbf{proj}_{\\mathcal{Q}^{o}}^{-1}(q^{o}_{1},\\mathcal{R}^{o})\nand\nq\n2\n=\nğ©ğ«ğ¨ğ£\nğ’¬\no\nâˆ’\n1\nâ€‹\n(\nq\n2\no\n,\nâ„›\no\n)\nq_{2}=\\mathbf{proj}_{\\mathcal{Q}^{o}}^{-1}(q^{o}_{2},\\mathcal{R}^{o})\n. Since\nq\n1\nâˆˆ\nâ„›\nâˆ’\nq_{1}\\in\\mathcal{R}^{-}\n,\nÏ€\n\\pi\ncan find a path between\nq\n1\nq_{1}\nand\nq\nseed\n)\nq_{\\text{seed}})\n. Further, since\nq\n2\nâˆˆ\nâ„›\nâˆ’\nq_{2}\\in\\mathcal{R}^{-}\n,\nÏ€\n\\pi\ncan find a path between\nq\nseed\nq_{\\text{seed}}\nand\nq\n2\nq_{2}\n. Hence, a path exists from\nq\n1\nq_{1}\nto\nq\n2\nq_{2}\nthrough\nq\nseed\nq_{\\text{seed}}\nand\nÏ€\n\\pi\ncan find it.\nâˆ\nA-D\nGrasp Generation for\nq\nseed\no\nq^{o}_{\\text{seed}}\non Bimanual Kuka\nWe compute simple antipodal grasps with the wrist joints touching opposite sides of the object. We define a mathematical program for computing such a grasp.\nFirst, for\ni\n=\n1\n,\n2\ni=1,2\n, our two desired contact points, we define a function\nf\ni\na\n:\nğ’¬\na\nâ†’\nâ„\n3\nf^{\\text{a}}_{i}:\\mathcal{Q}^{a}\\to\\mathbb{R}^{3}\nthat maps the robot configuration to a point on the robotâ€™s surface in the world frame, and a corresponding function\nf\ni\no\n:\nğ’¬\no\nâ†’\nâ„\n3\nf^{\\text{o}}_{i}:\\mathcal{Q}^{o}\\to\\mathbb{R}^{3}\nthat maps the object configuration to a point on the objectâ€™s surface in the world frame. Given an object configuration\nq\no\nq^{o}\n, we obtain a grasping robot configuration\nq\ngrasp\na\n,\nâ‹†\nq^{a,\\star}_{\\text{grasp}}\nby solving the following inverse kinematics problem:\nq\ngrasp\na\n,\nâ‹†\n=\narg\nâ€‹\nmin\nq\ngrasp\na\n\\displaystyle q^{a,\\star}_{\\text{grasp}}=\\operatorname*{arg\\,min}_{q^{a}_{\\text{grasp}}}\nâˆ‘\ni\n=\n1\nN\n1\n2\nâ€‹\nâˆ¥\nf\ni\na\nâ€‹\n(\nq\ngrasp\na\n)\nâˆ’\nf\ni\no\nâ€‹\n(\nq\no\n)\nâˆ¥\n2\n2\n\\displaystyle\\sum_{i=1}^{N}\\frac{1}{2}\\lVert f^{a}_{i}(q^{a}_{\\text{grasp}})-f^{o}_{i}(q^{o})\\rVert^{2}_{2}\n(30a)\ns.t.\nÏ•\nj\nâ€‹\n(\n(\nq\ngrasp\na\n,\nq\no\n)\n)\nâ‰¥\n0\n,\nâˆ€\nj\n\\displaystyle\\phi_{j}((q^{a}_{\\text{grasp}},q^{o}))\\geq 0,\\quad\\forall j\n(30b)\nq\ngrasp\na\nâˆˆ\nğ’¬\na\n\\displaystyle q^{a}_{\\text{grasp}}\\in\\mathcal{Q}^{a}\n(30c)\nwhere\n30b\nenforces nonpenetration constraints between the robot and the object and\n30c\nenforces joint limit constraints for the robot. The resulting seed configuration\nq\nseed\n=\n(\nq\ngrasp\na\n,\nâ‹†\n,\nq\no\n)\nq_{\\text{seed}}=(q^{a,\\star}_{\\text{grasp}},q^{o})\nis returned as output. We solve this nonconvex program using\nSnopt\n[\n15\n]\n, provided with\nDrake\n[\n46\n]\n.\nIn our system, we set\nN\n=\n2\nN=2\n. We define\nf\n1\na\nf^{a}_{1}\nsuch that it maps to a point on the left armâ€™s wrist joint, and\nf\n1\no\nf^{o}_{1}\nsuch that it maps to a point on the left side of the object. We define\nf\n2\na\nf^{a}_{2}\nand\nf\n2\no\nf^{o}_{2}\nin a similar manner for the right arm/right side of the object. Additionally,\nf\n1\no\nf^{o}_{1}\nand\nf\n2\no\nf^{o}_{2}\nare constructed to map to points on opposite sides of the object.\nA-E\nConvex Sets in\nSE\nâ€‹\n(\n2\n)\n\\mathrm{SE}(2)\nWe adopt the GCS viewpoint of Cohn et al.\n[\n14\n]\n. The object workspace\nğ’¬\no\nâŠ†\nSE\nâ€‹\n(\n2\n)\n\\mathcal{Q}^{o}\\subseteq\\mathrm{SE}(2)\nis regarded as a Riemannian manifold\n(\nğ’¬\no\n,\ng\n)\n(\\mathcal{Q}^{o},g)\nwith the product metric introduced in\nSection\nII-A\n, whose geodesic distance is\nd\nSE\nâ€‹\n(\n2\n)\nd_{\\mathrm{SE}(2)}\nin\nEquation\n2\n. On\n(\nğ’¬\no\n,\ng\n)\n(\\mathcal{Q}^{o},g)\nwe use the notion of geodesically convex (\ng\ng\n-convex) sets from\n[\n14\n, Sec.Â 3.2]\n: a set is\ng\ng\n-convex if, for any two points in the set, the unique minimizing geodesic between them lies entirely in the set.\nCohn et al. show that\nâ„\n2\nÃ—\nS\n1\n\\mathbb{R}^{2}\\times S^{1}\nwith this product metric is a flat configuration manifold and that, on such flat product manifolds, GGCS reduces to an ordinary Euclidean GCS: under any chart that is a local isometry, a subset is\ng\ng\n-convex whenever its image is Euclidean convex and its diameter in each factor is smaller than the convexity radius\n[\n14\n, Assumption 2 and Theorem 4]\n. In our case we use the global chart\nÏˆ\nâ€‹\n(\nq\no\n)\n=\n(\nq\nx\no\n,\nq\ny\no\n,\nq\nÎ¸\no\n)\nâˆˆ\nâ„\n3\n\\psi(q^{o})=(q^{o}_{x},q^{o}_{y},q^{o}_{\\theta})\\in\\mathbb{R}^{3}\n, and the convex-approximated mutual reachable sets\nâ„›\n^\nÎ”\no\n\\hat{\\mathcal{R}}^{o}_{\\Delta}\nare computed as convex polytopes in these coordinates. We additionally enforce that the angular projection of each\nâ„›\n^\nÎ”\no\n\\hat{\\mathcal{R}}^{o}_{\\Delta}\nhas width strictly less than\nÏ€\n\\pi\n, so that minimizing geodesics between points in the set do not wrap around\nS\n1\nS^{1}\n. By the results of\n[\n14\n]\n, each\nâ„›\n^\nÎ”\no\n\\hat{\\mathcal{R}}^{o}_{\\Delta}\nis therefore\ng\ng\n-convex in\n(\nğ’¬\no\n,\ng\n)\n(\\mathcal{Q}^{o},g)\n, and the GCS problem we solve in these coordinates is the Euclidean reduction of the corresponding GGCS problem on\nğ’¬\no\n\\mathcal{Q}^{o}\n.\nA-F\nProbabilistic Completeness of\nAlgorithm\n2\nIn this section, we prove that for any\nÎ±\n\\alpha\n, the procedure described in\nAlgorithm\n2\ncan produce an\nÎ±\n\\alpha\n-approximate cover. We make the following four assumptions: 1) we assume\nğ’¬\no\n\\mathcal{Q}^{o}\nto be measurable and of finite measure; 2) we assume that in\nAlgorithm\n1\n,\nIrisZo\nalways includes the cell in which\nq\nseed\no\nq^{o}_{\\text{seed}}\nbelongs; 3) we assume\nIrisZo\ndoes not include any regions not in\nğ’¬\no\n\\mathcal{Q}^{o}\n; and 4) we assume that\nGenerateGrasp\nis always successful.\nProof.\nFix\nÎ±\n\\alpha\n. For discretization resolution\nÎ´\n\\delta\n, define\nğ’¬\nin\n,\nÎ´\no\n\\mathcal{Q}^{o}_{\\text{in},\\delta}\nto be the finite union of all cells of which are wholly contained within\nğ’¬\no\n\\mathcal{Q}^{o}\n. From analysis, we know that for every\nÏµ\n>\n0\n\\epsilon>0\n, there exists a\nÎ´\n>\n0\n\\delta>0\nsuch that\nvol\nâ€‹\n(\nğ’¬\no\nâˆ–\nğ’¬\nin\n,\nÎ´\no\n)\nâ‰¤\nÏµ\n\\mathrm{vol}(\\mathcal{Q}^{o}\\setminus\\mathcal{Q}^{o}_{\\text{in},\\delta})\\leq\\epsilon\n. Thus, there exists a\nÎ´\n>\n0\n\\delta>0\nsuch that\nvol\nâ€‹\n(\nğ’¬\nin\n,\nÎ´\no\n)\nâ‰¥\nÎ±\nâ‹…\nvol\nâ€‹\n(\nğ’¬\no\n)\n\\mathrm{vol}(\\mathcal{Q}^{o}_{\\text{in},\\delta})\\geq\\alpha\\cdot\\mathrm{vol}(\\mathcal{Q}^{o})\n.\nPick\nÎ´\n\\delta\nsuch that\nvol\nâ€‹\n(\nğ’¬\nin\n,\nÎ´\no\n)\nâ‰¥\nÎ±\nâ‹…\nvol\nâ€‹\n(\nğ’¬\no\n)\n\\mathrm{vol}(\\mathcal{Q}^{o}_{\\text{in},\\delta})\\geq\\alpha\\cdot\\mathrm{vol}(\\mathcal{Q}^{o})\n. Note that\nğ’¬\nin\n,\nÎ´\no\n\\mathcal{Q}^{o}_{\\text{in},\\delta}\nis a union of\nfinitely\nmany cells. Because each MRS\nâ„›\n^\nÎ´\no\n\\hat{\\mathcal{R}}_{\\delta}^{o}\ncontains the cell in which its seed object configuration belongs (by assumption), we know that finitely many MRS are sufficient to include every cell in\nğ’¬\nin\n,\nÎ´\no\n\\mathcal{Q}^{o}_{\\text{in},\\delta}\n. Because each\nq\nseed\no\nq^{o}_{\\text{seed}}\nis sampled from the uncovered portion of\nğ’¬\no\n\\mathcal{Q}^{o}\n, and because a grasp can always be synthesized around\nq\nseed\no\nq^{o}_{\\text{seed}}\n, we know that each iteration of the\nwhile\nloop (lines 3-6 of\nAlgorithm\n2\n) introduces a cell that was previously at least partially uncovered into\nC\nC\n. Our third assumption guarantees that the union of all the MRS within\nC\nC\ndo not include any regions outside of\nğ’¬\no\n\\mathcal{Q}^{o}\n.\nTherefore, finitely many\nwhile\nloop iterations are sufficient for\nC\nC\nto include every cell in\nğ’¬\nin\n,\nÎ´\no\n\\mathcal{Q}^{o}_{\\text{in},\\delta}\n. It follows that\nvol\nâ€‹\n(\nâ‹ƒ\ni\n=\n1\n|\nC\n|\nâ„›\n^\nÎ´\no\n,\ni\n)\nâ‰¥\nvol\nâ€‹\n(\nğ’¬\nin\n,\nÎ´\no\n)\nâ‰¥\nÎ±\nâ‹…\nvol\nâ€‹\n(\nQ\no\n)\n\\mathrm{vol}(\\bigcup_{i=1}^{|C|}\\hat{\\mathcal{R}}^{o,i}_{\\delta})\\geq\\mathrm{vol}(\\mathcal{Q}^{o}_{\\text{in},\\delta})\\geq\\alpha\\cdot\\mathrm{vol}(Q^{o})\n, as desired.\nâˆ\nA-G\nFitting Surrogate GCS Vertex and Edge Costs\nIn this section, we describe in detail how to fit surrogate edge and vertex costs using least-squares regression.\nA-G\n1\nEdge Costs (Transit Motions)\nConsider an edge\ne\ni\nâ€‹\nj\ne_{ij}\nconnecting sets\nâ„›\ni\n\\mathcal{R}^{i}\nand\nâ„›\nj\n\\mathcal{R}^{j}\nwith seed configurations\nq\nseed\ni\nq^{i}_{\\text{seed}}\nand\nq\nseed\nj\nq^{j}_{\\text{seed}}\n. This edge represents a transit motion that keeps the object fixed at some\nq\no\nâˆˆ\nâ„›\ni\nâˆ©\nâ„›\nj\nq^{o}\\in\\mathcal{R}^{i}\\cap\\mathcal{R}^{j}\n. Let\nq\n0\n=\nğ©ğ«ğ¨ğ£\nğ’¬\no\n,\nÏ€\n,\nq\nseed\ni\nâˆ’\n1\nâ€‹\n(\nq\no\n)\n,\nq\nT\n=\nğ©ğ«ğ¨ğ£\nğ’¬\no\n,\nÏ€\n,\nq\nseed\nj\nâˆ’\n1\nâ€‹\n(\nq\no\n)\nq_{0}=\\mathbf{proj}^{-1}_{\\mathcal{Q}^{o},\\pi,q^{i}_{\\text{seed}}}(q^{o}),\\quad q_{T}=\\mathbf{proj}^{-1}_{\\mathcal{Q}^{o},\\pi,q^{j}_{\\text{seed}}}(q^{o})\ndenote the corresponding full configurations.\nRunning the transit planner\nÏˆ\n\\psi\nfrom\nq\n0\nq_{0}\nto\nq\nT\nq_{T}\nyields a trajectory\nq\n0\n:\nT\nq_{0:T}\nwith cost\nâ„“\ne\ni\nâ€‹\nj\nâ€‹\n(\nq\no\n,\nq\no\n)\n=\nc\nâ€‹\n(\nq\n0\n:\nT\n)\n\\ell_{e_{ij}}(q^{o},q^{o})=c(q_{0:T})\n.\nSince this cost is not available in closed-form and is not convex in\nq\no\nq^{o}\n, we approximate it with a surrogate cost\nâ„“\n^\ne\ni\nâ€‹\nj\n\\hat{\\ell}_{e_{ij}}\n.\nWe sample\nK\nK\nobject configurations\n{\nq\nk\no\n}\nk\n=\n1\nK\nâŠ‚\nâ„›\ni\nâˆ©\nâ„›\nj\n\\{q^{o}_{k}\\}_{k=1}^{K}\\subset\\mathcal{R}^{i}\\cap\\mathcal{R}^{j}\n, compute the corresponding trajectories using\nÏˆ\n\\psi\n, and record the costs\n{\nc\nâ€‹\n(\nq\n0\n:\nT\n,\nk\n)\n}\n\\{c(q_{0:T,k})\\}\n. Because\nÏˆ\n\\psi\n(RRT-Connect) is stochastic, the resulting costs are multimodal. We therefore fit a constant surrogate, which minimizes the least-squares objective and preserves convexity and nonnegativity:\nâ„“\n^\ne\ni\nâ€‹\nj\nâ€‹\n(\nq\no\n,\nq\no\n)\n=\n1\nK\nâ€‹\nâˆ‘\nk\n=\n1\nK\nc\nâ€‹\n(\nq\n0\n:\nT\n,\nk\n)\n.\n\\hat{\\ell}_{e_{ij}}(q^{o},q^{o})=\\frac{1}{K}\\sum_{k=1}^{K}c(q_{0:T,k}).\n(31)\nA-G\n2\nVertex Costs (Transfer Motions)\nConsider a vertex\nv\ni\nv_{i}\ncorresponding to transfer motions within\nâ„›\ni\n\\mathcal{R}^{i}\n, with seed configuration\nq\nseed\ni\nq^{i}_{\\text{seed}}\n. Let\nq\n0\no\n,\nq\nT\no\nâˆˆ\nâ„›\ni\nq^{o}_{0},q^{o}_{T}\\in\\mathcal{R}^{i}\nbe the start and goal object configurations, and let\nq\n0\n=\nğ©ğ«ğ¨ğ£\nğ’¬\no\n,\nÏ€\n,\nq\nseed\ni\nâˆ’\n1\nâ€‹\n(\nq\n0\no\n)\nq_{0}=\\mathbf{proj}^{-1}_{\\mathcal{Q}^{o},\\pi,q^{i}_{\\text{seed}}}(q^{o}_{0})\nbe the corresponding full configuration.\nExecuting the transfer planner\nÏ€\n\\pi\nfrom\nq\n0\nq_{0}\ntoward\nq\nT\no\nq^{o}_{T}\nproduces a trajectory\nq\n0\n:\nT\nq_{0:T}\nwith cost\nâ„“\nv\ni\nâ€‹\n(\nq\n0\no\n,\nq\nT\no\n)\n=\nc\nâ€‹\n(\nq\n0\n:\nT\n)\n\\ell_{v_{i}}(q^{o}_{0},q^{o}_{T})=c(q_{0:T})\n.\nAs before, we approximate this black-box cost with a convex surrogate\nâ„“\n^\nv\ni\n\\hat{\\ell}_{v_{i}}\n.\nWe sample\nK\nK\npairs\n(\nq\n0\n,\nk\no\n,\nq\nT\n,\nk\no\n)\nâˆˆ\nâ„›\ni\nÃ—\nâ„›\ni\n(q^{o}_{0,k},q^{o}_{T,k})\\in\\mathcal{R}^{i}\\times\\mathcal{R}^{i}\n, run\nÏ€\n\\pi\nto obtain trajectories and costs\nc\nâ€‹\n(\nq\n0\n:\nT\n,\nk\n)\nc(q_{0:T,k})\n, and fit a nonnegative convex quadratic. Let\nx\nk\n=\n[\nq\n0\n,\nk\no\nq\nT\n,\nk\no\n]\n,\ny\nk\n=\nc\nâ€‹\n(\nq\n0\n:\nT\n,\nk\n)\n.\nx_{k}=\\begin{bmatrix}q^{o}_{0,k}\\\\\nq^{o}_{T,k}\\end{bmatrix},\\qquad y_{k}=c(q_{0:T,k}).\nThe surrogate has the form\ny\n^\nk\n=\nx\nk\nT\nâ€‹\nA\nâ€‹\nx\nk\n+\nb\nT\nâ€‹\nx\nk\n+\nc\n\\hat{y}_{k}=x_{k}^{T}Ax_{k}+b^{T}x_{k}+c\n, with parameters obtained by solving\nmin\nA\n,\nb\n,\nc\n\\displaystyle\\min_{A,b,c}\\;\\;\nâˆ‘\nk\n=\n1\nK\n1\n2\nâ€‹\n(\ny\n^\nk\nâˆ’\ny\nk\n)\n2\n\\displaystyle\\sum_{k=1}^{K}\\tfrac{1}{2}(\\hat{y}_{k}-y_{k})^{2}\n(32a)\ns.t.\nA\nâª°\n0\n,\n\\displaystyle A\\succeq 0,\n(32b)\n[\nA\n1\n2\nâ€‹\nb\nT\n1\n2\nâ€‹\nb\nc\n]\nâª°\n0\n,\n\\displaystyle\\begin{bmatrix}A&\\tfrac{1}{2}b^{T}\\\\\n\\tfrac{1}{2}b&c\\end{bmatrix}\\succeq 0,\n(32c)\nwhich enforce convexity and nonnegativity, respectively. The resulting vertex cost is\nâ„“\n^\nv\ni\nâ€‹\n(\nq\n0\no\n,\nq\nT\no\n)\n=\n[\nq\n0\no\nq\nT\no\n]\nâ€‹\nA\nâ€‹\n[\nq\n0\no\nq\nT\no\n]\n+\nb\nT\nâ€‹\n[\nq\n0\no\nq\nT\no\n]\n+\nc\n.\n\\hat{\\ell}_{v_{i}}(q^{o}_{0},q^{o}_{T})=\\begin{bmatrix}q^{o}_{0}&q^{o}_{T}\\end{bmatrix}A\\begin{bmatrix}q^{o}_{0}\\\\\nq^{o}_{T}\\end{bmatrix}+b^{T}\\begin{bmatrix}q^{o}_{0}\\\\\nq^{o}_{T}\\end{bmatrix}+c.\n(33)\nA-H\nAdditional Details on Planning Failures\n(a)\nRight arm trapped behind object.\n(b)\nLeft arm at singularity.\nFigure 14:\nIllustration of instances where transit fails because manipulator cannot move from pre-transit grasp.\nA-I\nGRS Hyperparameters\nTABLE III:\nGRS Hyperparameters\nParameter name\nDescription\nValue\nÎ±\n\\alpha\nOffline:\nğ’¬\no\n\\mathcal{Q}^{o}\ncoverage\n0.98\nN\nOffline: number of MRS in graph\n25\nÎ”\n\\Delta\nOffline: MRS discretization size\n0.20\nx range\nğ’¬\no\n\\mathcal{Q}^{o}\nlimits\n[\n0.25\n,\n0.80\n]\n[0.25,0.80]\ny range\nğ’¬\no\n\\mathcal{Q}^{o}\nlimits\n[\nâˆ’\n0.55\n,\n0.55\n]\n[-0.55,0.55]\nÎ¸\n\\theta\nrange\nğ’¬\no\n\\mathcal{Q}^{o}\nlimits\n[\nâˆ’\nÏ€\n,\nÏ€\n]\n[-\\pi,\\pi]\nÏµ\n\\epsilon\nOffline: IRIS-ZO\n0.01\nN\np\nN_{p}\nOffline: IRIS-ZO\n50\nN\nb\nN_{b}\nOffline: IRIS-ZO\n5\nN\nt\nN_{t}\nOffline: IRIS-ZO\n5\nd\nâ€‹\nt\ndt\nCQDC model timestep\n0.01\nReferences\n[1]\nB. Aceituno and A. Rodriguez\n(2022)\nA hierarchical framework for long horizon planning of object-contact trajectories\n.\nIn\n2022 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)\n,\npp.Â 189â€“196\n.\nCited by:\nÂ§I\n.\n[2]\nB. Aceituno-Cabezas and A. Rodriguez\n(2020)\nA global quasi-dynamic model for contact-trajectory optimization in manipulation\n.\nCited by:\nÂ§I\n.\n[3]\nO. M. Andrychowicz, B. Baker, M. Chociej, R. Jozefowicz, B. McGrew, J. Pachocki, A. Petron, M. Plappert, G. Powell, A. Ray,\net al.\n(2020)\nLearning dexterous in-hand manipulation\n.\nThe International Journal of Robotics Research\n39\n(\n1\n),\npp.Â 3â€“20\n.\nCited by:\nÂ§I\n.\n[4]\nA. Aydinoglu and M. Posa\n(2022)\nReal-time multi-contact model predictive control via admm\n.\nIn\n2022 International Conference on Robotics and Automation (ICRA)\n,\nVol.\n,\npp.Â 3414â€“3421\n.\nExternal Links:\nDocument\nCited by:\nÂ§\nII-B\n.\n[5]\nK. Black, N. Brown, D. Driess, A. Esmail, M. Equi, C. Finn, N. Fusai, L. Groom, K. Hausman, B. Ichter,\net al.\n(2024)\nÏ€\n0\n\\pi_{0}\n: A vision-language-action flow model for general robot control\n.\narXiv preprint arXiv:2410.24164\n.\nCited by:\nÂ§I\n.\n[6]\nS. P. Boyd and L. Vandenberghe\n(2004)\nConvex optimization\n.\nCambridge university press\n.\nCited by:\nÂ§\nA-A\n.\n[7]\nN. Chavan-Dafle, R. Holladay, and A. Rodriguez\n(2018)\nIn-hand manipulation via motion cones\n.\narXiv preprint arXiv:1810.00219\n.\nCited by:\nÂ§I\n.\n[8]\nC. Chen, P. Culbertson, M. Lepert, M. Schwager, and J. Bohg\n(2021)\nTrajectotree: trajectory optimization meets tree search for planning multi-contact dexterous manipulation\n.\nIn\n2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)\n,\npp.Â 8262â€“8268\n.\nCited by:\nÂ§I\n.\n[9]\nT. Chen, J. Xu, and P. Agrawal\n(2022-08â€“11 Nov)\nA system for general in-hand object re-orientation\n.\nIn\nProceedings of the 5th Conference on Robot Learning\n,\nA. Faust, D. Hsu, and G. Neumann (Eds.)\n,\nProceedings of Machine Learning Research\n, Vol.\n164\n,\npp.Â 297â€“307\n.\nExternal Links:\nLink\nCited by:\nÂ§I\n.\n[10]\nX. Cheng, E. Huang, Y. Hou, and M. T. Mason\n(2021)\nContact mode guided sampling-based planning for quasistatic dexterous manipulation in 2d\n.\nIn\n2021 IEEE International Conference on Robotics and Automation (ICRA)\n,\npp.Â 6520â€“6526\n.\nCited by:\nÂ§I\n.\n[11]\nX. Cheng, E. Huang, Y. Hou, and M. T. Mason\n(2022)\nContact mode guided motion planning for quasidynamic dexterous manipulation in 3d\n.\nIn\n2022 International Conference on Robotics and Automation (ICRA)\n,\npp.Â 2730â€“2736\n.\nCited by:\nÂ§I\n,\nÂ§I\n,\nÂ§\nV-B\n3\n.\n[12]\nX. Cheng, S. Patil, Z. Temel, O. Kroemer, and M. T. Mason\n(2023)\nEnhancing dexterity in robotic manipulation via hierarchical contact exploration\n.\nIEEE Robotics and Automation Letters\n9\n(\n1\n),\npp.Â 390â€“397\n.\nCited by:\nÂ§I\n,\nitemÂ 2\n,\nitemÂ 3\n.\n[13]\nC. Chi, Z. Xu, S. Feng, E. Cousineau, Y. Du, B. Burchfiel, R. Tedrake, and S. Song\n(2023)\nDiffusion policy: visuomotor policy learning via action diffusion\n.\nThe International Journal of Robotics Research\n,\npp.Â 02783649241273668\n.\nCited by:\nÂ§I\n.\n[14]\nT. Cohn, M. Petersen, M. Simchowitz, and R. Tedrake\n(2025)\nNon-euclidean motion planning with graphs of geodesically convex sets\n.\nThe International Journal of Robotics Research\n44\n(\n10-11\n),\npp.Â 1840â€“1862\n.\nExternal Links:\nDocument\n,\nLink\n,\nhttps://doi.org/10.1177/02783649241302419\nCited by:\nÂ§\nA-E\n,\nÂ§\nA-E\n.\n[15]\nP. E. Gill, W. Murray, and M. A. Saunders\n(2002)\nSNOPT: an sqp algorithm for large-scale constrained optimization\n.\nSIAM Journal on Optimization\n12\n(\n4\n),\npp.Â 979â€“1006\n.\nExternal Links:\nDocument\n,\nLink\n,\nhttps://doi.org/10.1137/S1052623499350013\nCited by:\nÂ§\nA-D\n.\n[16]\nB. P. Graesdal, S. Y. C. Chia, T. Marcucci, S. Morozov, A. Amice, P. A. Parrilo, and R. Tedrake\n(2024)\nTowards tight convex relaxations for contact-rich manipulation\n.\narXiv preprint arXiv:2402.10312\n.\nCited by:\nÂ§I\n.\n[17]\nA. Handa, A. Allshire, V. Makoviychuk, A. Petrenko, R. Singh, J. Liu, D. Makoviichuk, K. Van Wyk, A. Zhurkevich, B. Sundaralingam,\net al.\n(2023)\nDextreme: transfer of agile in-hand manipulation from simulation to reality\n.\nIn\n2023 IEEE International Conference on Robotics and Automation (ICRA)\n,\npp.Â 5977â€“5984\n.\nCited by:\nÂ§I\n.\n[18]\nK. Hauser and J. Latombe\n(2010)\nMulti-modal motion planning in non-expansive spaces\n.\nThe International Journal of Robotics Research\n29\n(\n7\n),\npp.Â 897â€“915\n.\nCited by:\nÂ§I\n,\nÂ§\nV-B\n3\n.\n[19]\nT. A. Howell, S. L. Cleacâ€™h, J. BrÃ¼digam, J. Z. Kolter, M. Schwager, and Z. Manchester\n(2022)\nDojo: a differentiable physics engine for robotics\n.\narXiv preprint arXiv:2203.00806\n.\nCited by:\nÂ§\nII-B\n.\n[20]\nT. Howell, N. Gileadi, S. Tunyasuvunakool, K. Zakka, T. Erez, and Y. Tassa\n(2022)\nPredictive sampling: real-time behaviour synthesis with mujoco\n.\narXiv preprint arXiv:2212.00541\n.\nCited by:\nÂ§I\n.\n[21]\nE. Huang, X. Cheng, and M. T. Mason\n(2020)\nEfficient contact mode enumeration in 3d\n.\nIn\nInternational Workshop on the Algorithmic Foundations of Robotics\n,\npp.Â 485â€“501\n.\nCited by:\nÂ§I\n.\n[22]\nM. Janner, Y. Du, J. B. Tenenbaum, and S. Levine\n(2022)\nPlanning with diffusion for flexible behavior synthesis\n.\narXiv preprint arXiv:2205.09991\n.\nCited by:\nÂ§I\n.\n[23]\nD. Kalashnikov, A. Irpan, P. Pastor, J. Ibarz, A. Herzog, E. Jang, D. Quillen, E. Holly, M. Kalakrishnan, V. Vanhoucke,\net al.\n(2018)\nScalable deep reinforcement learning for vision-based robotic manipulation\n.\nIn\nConference on robot learning\n,\npp.Â 651â€“673\n.\nCited by:\nÂ§I\n.\n[24]\nY. Koga and J.-C. Latombe\n(1994)\nOn multi-arm manipulation planning\n.\nIn\nProceedings of the 1994 IEEE International Conference on Robotics and Automation\n,\nVol.\n,\npp.Â 945â€“952 vol.2\n.\nExternal Links:\nDocument\nCited by:\nÂ§\nII-B\n.\n[25]\nJ. J. Kuffner and S. M. LaValle\n(2000)\nRRT-connect: an efficient approach to single-query path planning\n.\nIn\nProceedings 2000 ICRA. Millennium conference. IEEE international conference on robotics and automation. Symposia proceedings (Cat. No. 00CH37065)\n,\nVol.\n2\n,\npp.Â 995â€“1001\n.\nCited by:\nÂ§\nA-B\n,\nÂ§\nII-B\n,\nÂ§\nV-A\n2\n.\n[26]\nV. Kurtz, A. Castro, A. Ã–. Ã–nol, and H. Lin\n(2023)\nInverse dynamics trajectory optimization for contact-implicit model predictive control\n.\nThe International Journal of Robotics Research\n,\npp.Â 02783649251344635\n.\nCited by:\nÂ§I\n.\n[27]\nS. LaValle\n(1998)\nRapidly-exploring random trees: a new tool for path planning\n.\nResearch Report 9811\n.\nCited by:\nÂ§\nV-A\n3\n.\n[28]\nLBM Team TRI\n(2025)\nA careful examination of large behavior models for multitask dexterous manipulation\n.\nExternal Links:\n2507.05331\n,\nLink\nCited by:\nÂ§I\n.\n[29]\nG. Lee, T. Lozano-PÃ©rez, and L. P. Kaelbling\n(2015)\nHierarchical planning for multi-contact non-prehensile manipulation\n.\nIn\n2015 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)\n,\npp.Â 264â€“271\n.\nCited by:\nÂ§I\n.\n[30]\nA. H. Li, P. Culbertson, V. Kurtz, and A. D. Ames\n(2024)\nDrop: dexterous reorientation via online planning\n.\narXiv preprint arXiv:2409.14562\n.\nCited by:\nÂ§I\n.\n[31]\nT. Lozano-PÃ©rez and L. P. Kaelbling\n(2014)\nA constraint-based method for solving sequential manipulation planning problems\n.\nIn\n2014 IEEE/RSJ International Conference on Intelligent Robots and Systems\n,\npp.Â 3684â€“3691\n.\nCited by:\nÂ§I\n.\n[32]\nT. Marcucci, R. Deits, M. Gabiccini, A. Bicchi, and R. Tedrake\n(2017)\nApproximate hybrid model predictive control for multi-contact push recovery in complex environments\n.\nIn\n2017 IEEE-RAS 17th international conference on humanoid robotics (Humanoids)\n,\npp.Â 31â€“38\n.\nCited by:\nÂ§I\n.\n[33]\nT. Marcucci, M. Petersen, D. von Wrangel, and R. Tedrake\n(2023)\nMotion planning around obstacles with convex optimization\n.\nScience robotics\n8\n(\n84\n),\npp.Â eadf7843\n.\nCited by:\nÂ§\nII-B\n.\n[34]\nT. Marcucci and R. Tedrake\n(2019)\nMixed-integer formulations for optimal control of piecewise-affine systems\n.\nIn\nProceedings of the 22nd ACM International Conference on Hybrid Systems: Computation and Control\n,\npp.Â 230â€“239\n.\nCited by:\nÂ§I\n.\n[35]\nT. Marcucci, J. Umenberger, P. Parrilo, and R. Tedrake\n(2024)\nShortest paths in graphs of convex sets\n.\nSIAM Journal on Optimization\n34\n(\n1\n),\npp.Â 507â€“532\n.\nCited by:\nÂ§I\n,\nÂ§I\n,\nÂ§\nII-D\n.\n[36]\nM. T. Mason\n(2001)\nMechanics of robotic manipulation\n.\nMIT press\n.\nCited by:\nÂ§\nII-A\n.\n[37]\nM. N Simaan, H. Choset,\net al.\n(2023)\nTorque-limited manipulation planning through contact by interleaving graph search and trajectory optimization\n.\nCited by:\nÂ§I\n.\n[38]\nA. Ã–. Ã–nol, R. Corcodel, P. Long, and T. PadÄ±r\n(2020)\nTuning-free contact-implicit trajectory optimization\n.\nIn\n2020 IEEE International Conference on Robotics and Automation (ICRA)\n,\npp.Â 1183â€“1189\n.\nCited by:\nÂ§I\n.\n[39]\nA. Ã–. Ã–nol, P. Long, and T. PadÄ±r\n(2019)\nContact-implicit trajectory optimization based on a variable smooth contact model and successive convexification\n.\nIn\n2019 International Conference on Robotics and Automation (ICRA)\n,\npp.Â 2447â€“2453\n.\nCited by:\nÂ§I\n.\n[40]\nT. Pang, H. T. Suh, L. Yang, and R. Tedrake\n(2023)\nGlobal planning for contact-rich manipulation via local smoothing of quasi-dynamic contact models\n.\nIEEE Transactions on robotics\n39\n(\n6\n),\npp.Â 4691â€“4711\n.\nCited by:\nÂ§\nA-A\n,\nÂ§I\n,\nÂ§I\n,\nÂ§I\n,\nÂ§\nV-A\n3\n.\n[41]\nM. Posa, C. Cantu, and R. Tedrake\n(2014)\nA direct method for trajectory optimization of rigid bodies through contact\n.\nThe International Journal of Robotics Research\n33\n(\n1\n),\npp.Â 69â€“81\n.\nCited by:\nÂ§I\n,\nÂ§\nII-B\n.\n[42]\nN. M. M. Shafiullah, A. Rai, H. Etukuru, Y. Liu, I. Misra, S. Chintala, and L. Pinto\n(2023)\nOn bringing robots home\n.\narXiv preprint arXiv:2311.16098\n.\nCited by:\nÂ§I\n.\n[43]\nJ. Sleiman, J. Carius, R. Grandia, M. Wermelinger, and M. Hutter\n(2019)\nContact-implicit trajectory optimization for dynamic object manipulation\n.\nIn\n2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)\n,\nVol.\n,\npp.Â 6814â€“6821\n.\nExternal Links:\nDocument\nCited by:\nÂ§I\n.\n[44]\nH. Suh, T. Pang, T. Zhao, and R. Tedrake\n(2025)\nDexterous contact-rich manipulation via the contact trust region\n.\narXiv preprint arXiv:2505.02291\n.\nCited by:\nÂ§\nA-A\n,\n2nd item\n,\nÂ§I\n,\nÂ§\nII-B\n,\nÂ§\nV-A\n2\n,\nÂ§V\n.\n[45]\nO. M. Team, D. Ghosh, H. Walke, K. Pertsch, K. Black, O. Mees, S. Dasari, J. Hejna, T. Kreiman, C. Xu,\net al.\n(2024)\nOcto: an open-source generalist robot policy\n.\narXiv preprint arXiv:2405.12213\n.\nCited by:\nÂ§I\n.\n[46]\nR. Tedrake and the Drake Development Team\n(2019)\nDrake: model-based design and verification for robotics\n.\nExternal Links:\nLink\nCited by:\nÂ§\nA-D\n.\n[47]\nM. A. Toussaint, K. R. Allen, K. A. Smith, and J. B. Tenenbaum\n(2018)\nDifferentiable physics and stable modes for tool-use and manipulation planning\n.\nCited by:\nÂ§I\n.\n[48]\nS. Venkatesh, B. Bianchini, A. Aydinoglu, W. Yang, and M. Posa\n(2025)\nApproximating global contact-implicit mpc via sampling and local complementarity\n.\narXiv preprint arXiv:2505.13350\n.\nCited by:\nÂ§I\n.\n[49]\nP. Werner, T. Cohn, R. H. Jiang, T. Seyde, M. Simchowitz, R. Tedrake, and D. Rus\n(2024)\nFaster algorithms for growing collision-free convex polytopes in robot configuration space\n.\narXiv preprint arXiv:2410.12649\n.\nCited by:\nÂ§\nIII-A\n,\nDefinition 2\n.\n[50]\nT. Z. Zhao, J. Tompson, D. Driess, P. Florence, K. Ghasemipour, C. Finn, and A. Wahid\n(2024)\nAloha unleashed: a simple recipe for robot dexterity\n.\narXiv preprint arXiv:2410.13126\n.\nCited by:\nÂ§I\n.\n[51]\nW. Zhou, B. Jiang, F. Yang, C. Paxton, and D. Held\n(2023)\nHACMan: learning hybrid actor-critic maps for 6d non-prehensile manipulation\n.\narXiv preprint arXiv:2305.03942\n.\nCited by:\nÂ§I\n.\n[52]\nH. Zhu, A. Meduri, and L. Righetti\n(2023)\nEfficient object manipulation planning with monte carlo tree search\n.\nIn\n2023 IEEE/RSJ international conference on intelligent robots and systems (IROS)\n,\npp.Â 10628â€“10635\n.\nCited by:\nÂ§I\n,\nÂ§I\n.",
    "preview_text": "If we consider human manipulation, it is clear that contact-rich manipulation (CRM)-the ability to use any surface of the manipulator to make contact with objects-can be far more efficient and natural than relying solely on end-effectors (i.e., fingertips). However, state-of-the-art model-based planners for CRM are still focused on feasibility rather than optimality, limiting their ability to fully exploit CRM's advantages. We introduce a new paradigm that computes approximately optimal manipulator plans. This approach has two phases. Offline, we construct a graph of mutual reachable sets, where each set contains all object orientations reachable from a starting object orientation and grasp. Online, we plan over this graph, effectively computing and sequencing local plans for globally optimized motion. On a challenging, representative contact-rich task, our approach outperforms a leading planner, reducing task cost by 61%. It also achieves a 91% success rate across 250 queries and maintains sub-minute query times, ultimately demonstrating that globally optimized contact-rich manipulation is now practical for real-world tasks.\n\nApproximately Optimal Global Planning\nfor Contact-Rich SE(2) Manipulation\non a Graph of Reachable Sets\nâ€ \nâ€ \nthanks:\nThis manuscript is under submission to IEEE Transactions on Robotics.\nSimin Liu\n1,2,âˆ—\n, Tong Zhao\n2,âˆ—\n, Bernhard Paus Graesdal\n3\n, Peter Werner\n3\n, Jiuguang Wang\n2\n, John Dolan\n1\n, Changliu Liu\n1\n, Tao Pang\n2\n1\nRobotics Institute, Carnegie Mellon University\n2\nRobotics and AI Institute\n3\nCSAIL, Massachusetts Institute of Technology\nAbstract\nIf we consider human manipulation, it is clear that contact-rich manipulation (CRM)-the ability to use any surface of the manipulator to make contact with objects-can be far more efficient and natural than relying solely on end-effectors (i.e., fingertips). However, state-of-the-art model-based planners for CRM are still focused on feasibility rather than optimality, limiting their ability to fu",
    "is_relevant": true,
    "relevance_score": 4.0,
    "extracted_keywords": [
        "locomotion",
        "whole body control"
    ],
    "one_line_summary": "è¯¥è®ºæ–‡æå‡ºäº†ä¸€ç§åŸºäºå¯è¾¾é›†å›¾çš„è¿‘ä¼¼æœ€ä¼˜å…¨å±€è§„åˆ’æ–¹æ³•ï¼Œç”¨äºæ¥è§¦ä¸°å¯Œçš„SE(2)æ“ä½œä»»åŠ¡ï¼Œå¼ºè°ƒå…¨èº«æ§åˆ¶å’Œè¿åŠ¨ä¼˜åŒ–ã€‚",
    "detailed_summary": "",
    "qa_pairs": [],
    "is_hidden": false,
    "is_starred": false,
    "flag": true,
    "published_date": "2026-01-15T20:00:30Z",
    "created_at": "2026-01-20T17:49:57.644598",
    "updated_at": "2026-01-20T17:49:57.644607"
}