{
    "id": "2512.01668v1",
    "title": "Dynamic Log-Gaussian Process Control Barrier Function for Safe Robotic Navigation in Dynamic Environments",
    "authors": [
        "Xin Yin",
        "Chenyang Liang",
        "Yanning Guo",
        "Jie Mei"
    ],
    "abstract": "æ§åˆ¶å±éšœå‡½æ•°ï¼ˆCBFï¼‰å·²æˆä¸ºè§£å†³æœºå™¨äººå®‰å…¨å¯¼èˆªé—®é¢˜çš„æœ‰æ•ˆå·¥å…·ã€‚ç„¶è€Œï¼Œåœ¨æœªçŸ¥ä¸”åŠ¨æ€çš„ç¯å¢ƒä¸­ï¼Œåˆ©ç”¨å®æ—¶ä¼ æ„Ÿå™¨æ•°æ®åœ¨çº¿åˆæˆå…·æœ‰ä¿¡æ¯æ€§å¹¶èƒ½æ„ŸçŸ¥éšœç¢ç‰©è¿åŠ¨çš„CBFä»é¢ä¸´æŒ‘æˆ˜ã€‚é’ˆå¯¹è¿™ä¸€éš¾é¢˜ï¼Œæœ¬æ–‡æå‡ºä¸€ç§åŸºäºé«˜æ–¯è¿‡ç¨‹çš„æ–°å‹CBFæ¡†æ¶â€”â€”åŠ¨æ€å¯¹æ•°é«˜æ–¯è¿‡ç¨‹æ§åˆ¶å±éšœå‡½æ•°ï¼ˆDLGP-CBFï¼‰ï¼Œä»¥å®ç°å…¼å…·ç©ºé—´ä¿¡æ¯ä¸°å¯Œæ€§å’ŒåŠ¨æ€éšœç¢ç‰©è¿åŠ¨å“åº”èƒ½åŠ›çš„CBFå®æ—¶æ„å»ºã€‚é¦–å…ˆï¼ŒDLGP-CBFé‡‡ç”¨å¯¹æ•°å˜æ¢çš„é«˜æ–¯è¿‡ç¨‹å›å½’æ–¹æ³•ï¼Œå³ä½¿åœ¨æ•°æ®ç¨€ç–åŒºåŸŸä¹Ÿèƒ½ç”Ÿæˆå¹³æ»‘ä¸”å…·ä¿¡æ¯æ€§çš„å±éšœå€¼åŠå…¶æ¢¯åº¦ï¼›å…¶æ¬¡ï¼Œé€šè¿‡å°†DLGP-CBFæ˜¾å¼å»ºæ¨¡ä¸ºéšœç¢ç‰©ä½ç½®çš„å‡½æ•°ï¼Œæ‰€å¯¼å‡ºçš„å®‰å…¨çº¦æŸæ¡ä»¶èåˆäº†å¯¹éšœç¢ç‰©é€Ÿåº¦çš„é¢„æµ‹ï¼Œä½¿æ§åˆ¶å™¨èƒ½å¤Ÿä¸»åŠ¨å“åº”åŠ¨æ€éšœç¢ç‰©çš„è¿åŠ¨ã€‚ä»¿çœŸç»“æœè¡¨æ˜ï¼Œä¸åŸºå‡†æ–¹æ³•ç›¸æ¯”ï¼Œè¯¥æ–¹æ³•åœ¨é¿éšœæ€§èƒ½ä¸Šæ˜¾è‘—æå‡ï¼Œè¡¨ç°å‡ºæ›´å¤§çš„å®‰å…¨è£•åº¦ã€æ›´å¹³æ»‘çš„è½¨è¿¹ä»¥åŠæ›´å¼ºçš„åŠ¨æ€å“åº”èƒ½åŠ›ã€‚",
    "url": "https://arxiv.org/abs/2512.01668v1",
    "html_url": "https://arxiv.org/html/2512.01668v1",
    "html_content": "Dynamic Log-Gaussian Process Control Barrier Function for Safe Robotic Navigation in Dynamic Environments\nXin Yin, Chenyang Liang, Yanning Guo and Jie Mei\nXin Yin and Chenyang Liang contributed equally to this work.Xin Yin, Chenyang Liang and Jie Mei are with the School of Intelligence Science and Engineering, Harbin Institute of Technology, Shenzhen, Guangdong 518055, China.Yanning Guo is with the Department of Control Science and Engineering, Harbin Institute of Technology, Heilongjiang 150001, China.This work was supported in part by the Shenzhen Fundamental Research Program under Grant JCYJ20241202124010014, in part by the Guangdong Basic and Applied Basic Research Foundation under Grant 2023B1515120018 and Grant 2024B1515040008, and in part by the National Natural Science Foundation of China under Grant 62525304 and Grant U23B2036. (Corresponding author: Jie Mei, jmei@hit.edu.cn.)\nAbstract\nControl Barrier Functions (CBFs) have emerged as efficient tools to address the safe navigation problem for robot applications.\nHowever, synthesizing informative and obstacle motion-aware CBFs online using real-time sensor data remains challenging, particularly in unknown and dynamic scenarios.\nMotived by this challenge, this paper aims to propose a novel Gaussian Process-based formulation of CBF, termed the Dynamic Log Gaussian Process Control Barrier Function (DLGP-CBF),\nto enable real-time construction of CBF which are both spatially informative and responsive to obstacle motion.\nFirstly, the DLGP-CBF leverages a logarithmic transformation of GP regression to generate smooth and informative barrier values and gradients, even in sparse-data regions.\nSecondly, by explicitly modeling the DLGP-CBF as a function of obstacle positions, the derived safety constraint integrates predicted obstacle velocities, allowing the controller to proactively respond to dynamic obstaclesâ€™ motion.\nSimulation results demonstrate significant improvements in obstacle avoidance performance, including increased safety margins, smoother trajectories, and enhanced responsiveness compared to baseline methods.\nI\nIntroduction\nEnsuring obstacle avoidance in unknown and dynamic environments containing both static and dynamic obstacles with unknown positions and velocities is essential for real-world robotic applications.\nRecently, Control Barrier Functions (CBFs) have emerged as an effective and powerful framework for enforcing safety constraints in robotic navigation tasks due to their simplicity and computational efficiency\n[\names2019control\n]\n.\nA CBF defines a safe set as the super-zero-level set of a scalar function, whose non-negativity guarantees that the system state remains within the safe region.\nBy integrating the safety constraint derived from the CBF into optimization-based controllers, such as Quadratic Programming (QP)\n[\nwang2017safety\n]\n, Model Predictive Control (MPC)\n[\njian2023dynamic\n]\n,\nrobotic systems can achieve collision-free navigation while pursuing task objectives.\nWhile the CBF-based safety constraint can be directly incorporated into these optimization problems once a valid CBF is available,\nthe primary challenge lies in synthesizing CBFs that are both informative and reliable.\nTypically, synthesizing CBFs requires accurate geometric information of obstacles, such as their explicit locations and shapes\n[\nwang2017safety\n,\nautenrieb2023safe\n,\nlie2023formation\n]\n.\nHowever, such prior knowledge is usually unavailable in unknown scenarios.\nConsequently, real-time online synthesis of CBFs directly from onboard sensor data has become a necessity in practical tasks.\nExisting online sensor-based CBF synthesis methods can be broadly categorized into two main classes: explicit geometric-based methods and implicit data-driven methods.\nExplicit geometric-based methods reconstruct obstacle shapes from sensor data using simplified geometric primitives.\nFor instance, studies\n[\njian2023dynamic\n,\nzhang2025robust\n]\nutilize Minimum Bounding Ellipses (MBEs) to approximate LiDAR-observed obstacles, subsequently constructing multiple CBF constraints for each obstacle.\nHowever, such geometric approximations typically yield overly conservative safe sets, as obstacles are enclosed by coarse bounding shapes.\nMoreover, multiple safety constraints lead to increased computational complexity and poor scalability in environments with dense obstacles\n[\nzhang2024online\n]\n.\nIn contrast, implicit data-driven methods\n[\ndawson2022learning\n,\nsrinivasan2020synthesis\n,\n9981177\n,\n9888130\n,\nkeyumarsi2023lidar\n,\n10160805\n]\nsynthesize CBFs by implicitly learning obstacle geometry from sensor data through supervised machine learning techniques.\nThese methods usually model the environment with a single unified barrier function, thus significantly reducing the computational burden associated with multiple constraints.\nAuthors in\n[\nsrinivasan2020synthesis\n]\nemploy a support vector machine (SVM) classifier to categorize sampled states as safe or unsafe, from which the CBF is synthesized.\nSimilarly, the authors in\n[\n9981177\n]\nutilize a deep neural network to directly update the CBF from instantaneous LiDAR measurements.\nHowever, these approaches\n[\nsrinivasan2020synthesis\n,\n9981177\n]\ntypically demand extensive labeled data and significant computational resources for online training, restricting their practical real-time applicability.\nRecently, Gaussian Process (GP)-based methods\n[\n9888130\n,\nkeyumarsi2023lidar\n]\nhave demonstrated significant potential for online CBF synthesis, owing to their ability to perform regression without requiring large-scale labeled datasets, as well as their low training cost and inference efficiency.\nUnlike other parameterized learning methods such as SVM\n[\nsrinivasan2020synthesis\n]\nand neural network\n[\n9981177\n]\n, GP regression is a non-parametric model that relies on the correlation between training points and query inputs to produce predictions\n[\nlyu\n]\n, making it particularly suitable for scenarios with sparse and noisy sensor data.\nIn\n[\nkeyumarsi2023lidar\n]\n, the constant-mean GP regression is employed to synthesize the CBF as a function of the robotâ€™s position.\nThe training dataset is constructed using the positions of the obstacle boundary points extracted from instantaneous LiDAR data.\nHowever, existing GP-based approaches\n[\n9888130\n,\nkeyumarsi2023lidar\n]\nexhibit two critical limitations when applied to safe robot navigation tasks.\nFirst, these methods are inherently reactive, as they treat the obstacle configuration as static within each control cycle.\nThe GP-based CBF is updated solely on instantaneous LiDAR observations without accounting for obstacle motion or future positions.\nThis limitation makes the resulting CBFs less effective for anticipating potential collisions, especially when obstacles are moving rapidly or unpredictably.\nSecond, the standard constant-mean GP regression adopted in these approaches\n[\n9888130\n,\nkeyumarsi2023lidar\n]\ntends to return to its prior mean value in regions far from observed data.\nThis behavior leads to the saturation of predicted CBF values and vanishing gradients when the robot is not in close proximity to any obstacle.\nAs a result, the CBF tends to provide insufficient safety information in such regions, potentially causing delayed avoidance responses.\nMotivated by the above discussions, this paper proposes a novel GP-based CBF formulation, termed the\nDynamic Log Gaussian Process Control Barrier Function (DLGP-CBF)\n, to enhance safe robot navigation in unknown and dynamic environments.\nThe main contributions are summarized as follows.\nâ€¢\nWe introduce a logarithmic GP-based CBF formulation that ensures informative and non-vanishing barrier values and gradients, even in regions distant from observed obstacles.\nâ€¢\nWe explicitly incorporate predicted obstacle velocities into the CBF formulation by modeling the CBF as a function of obstacle positions, enabling proactive and motion-aware collision avoidance.\nâ€¢\nWe validate the proposed method through simulation experiments in dynamic environments, demonstrating superior safety margins, responsiveness, and trajectory smoothness compared to existing baselines.\nThe remainder of this paper is organized as follows.\nSection\nII\nintroduces preliminaries and the problem description.\nSection\nIII\ndetails the proposed DLGP-CBF synthesis and the associated control framework.\nSimulation results validating the effectiveness of the proposed approach are presented in Section\nIV\n.\nII\nPreliminaries and Problem Description\nII-A\nPreliminaries\nII-A1\nDynamic Control Barrier Function\nConsider a general control-affine system with dynamics\nx\nË™\n\\displaystyle\\dot{x}\n=\nf\nâ€‹\n(\nx\n)\n+\ng\nâ€‹\n(\nx\n)\nâ€‹\nu\n,\n\\displaystyle=f(x)+g(x)u,\n(1)\nwhere\nx\nâˆˆ\nğ’³\nâŠ‚\nâ„\nn\nx\\in\\mathcal{X}\\subset\\mathbb{R}^{n}\nis the state,\nu\nâˆˆ\nâ„\nm\nu\\in\\mathbb{R}^{m}\nis the control input,\nf\n:\nâ„\nn\nâ†’\nâ„\nn\nf:\\mathbb{R}^{n}\\to\\mathbb{R}^{n}\nand\ng\n:\nâ„\nn\nâ†’\nâ„\nn\nÃ—\nm\ng:\\mathbb{R}^{n}\\to\\mathbb{R}^{n\\times m}\nare locally Lipschitz continuous functions.\nFor safety-critical control, we define a dynamic safe set\nğ’\nâ€‹\n(\nt\n)\n\\mathcal{C}(t)\nas the zero super-level set of a continuously differentiable function\nh\n:\nğ’³\nÃ—\nâ„\n+\nâ†’\nâ„\nh:\\mathcal{X}\\times\\mathbb{R}^{+}\\to\\mathbb{R}\n, i.e.,\nğ’\nâ€‹\n(\nt\n)\n\\displaystyle\\mathcal{C}(t)\n=\n{\nx\nâˆˆ\nğ’³\nâˆ£\nh\nâ€‹\n(\nx\n,\nt\n)\nâ‰¥\n0\n}\n.\n\\displaystyle=\\{x\\in\\mathcal{X}\\mid h(x,t)\\geq 0\\}.\nThe system (\n1\n) is defined to be\nsafe\nif the state\nx\nâ€‹\n(\nt\n)\nx(t)\nremains within the safe set\nğ’\nâ€‹\n(\nt\n)\n\\mathcal{C}(t)\nfor all time\nt\nâ‰¥\n0\nt\\geq 0\n.\nWe introduce the dynamic control barrier function (D-CBF)\nh\nâ€‹\n(\nx\n,\nt\n)\nh(x,t)\nas follows.\nDefinition 1\n(\n[\njian2023dynamic\n]\n)\nA continuously differentiable function\nh\n:\nğ’³\nÃ—\nâ„\n+\nâ†’\nâ„\nh:\\mathcal{X}\\times\\mathbb{R}^{+}\\to\\mathbb{R}\nis a D-CBF for the system (\n1\n) if there exists an extended class\nğ’¦\nâˆ\n\\mathcal{K}_{\\infty}\nfunction\nÎ±\nâ€‹\n(\nâ‹…\n)\n\\alpha(\\cdot)\nsuch that the following inequality holds for all\n(\nx\n,\nt\n)\nâˆˆ\nğ’³\nÃ—\nâ„\n+\n(x,t)\\in\\mathcal{X}\\times\\mathbb{R}^{+}\n:\nsup\nu\nâˆˆ\nâ„\nm\n[\nâ„’\nf\nâ€‹\nh\nâ€‹\n(\nx\n,\nt\n)\n+\nâ„’\ng\nâ€‹\nh\nâ€‹\n(\nx\n,\nt\n)\nâ€‹\nu\n+\nâˆ‚\nh\nâ€‹\n(\nx\n,\nt\n)\nâˆ‚\nt\n+\nÎ±\nâ€‹\n(\nh\nâ€‹\n(\nx\n,\nt\n)\n)\n]\nâ‰¥\n0\n,\n\\displaystyle\\sup_{u\\in\\mathbb{R}^{m}}[\\mathcal{L}_{f}h(x,t)+\\mathcal{L}_{g}h(x,t)u+\\frac{\\partial h(x,t)}{\\partial t}+\\alpha(h(x,t))]\\geq 0,\n(2)\nwhere\nâ„’\nf\nâ€‹\nh\n\\mathcal{L}_{f}h\nand\nâ„’\ng\nâ€‹\nh\n\\mathcal{L}_{g}h\nare the Lie derivatives of\nh\nâ€‹\n(\nx\n,\nt\n)\nh(x,t)\nwith respect to\nf\nâ€‹\n(\nx\n)\nf(x)\nand\ng\nâ€‹\n(\nx\n)\ng(x)\n, respectively.\nLet\nK\nc\nâ€‹\nb\nâ€‹\nf\nâ€‹\n(\nx\n,\nt\n)\n{K}_{cbf}(x,t)\ndenote the set of control inputs that satisfy the D-CBF condition (\n2\n), i.e.,\nK\nc\nâ€‹\nb\nâ€‹\nf\n(\nx\n,\nt\n)\n=\n{\nu\nâˆˆ\nâ„\nm\nâˆ£\nâ„’\nf\nh\n(\nx\n,\nt\n)\n+\nâ„’\ng\nh\n(\nx\n,\nt\n)\nu\n\\displaystyle{K}_{cbf}(x,t)=\\{u\\in\\mathbb{R}^{m}\\mid\\mathcal{L}_{f}h(x,t)+\\mathcal{L}_{g}h(x,t)u\n+\nâˆ‚\nh\nâ€‹\n(\nx\n,\nt\n)\nâˆ‚\nt\n+\nÎ±\n(\nh\n(\nx\n,\nt\n)\n)\nâ‰¥\n0\n}\n\\displaystyle+\\frac{\\partial h(x,t)}{\\partial t}+\\alpha(h(x,t))\\geq 0\\}\n,\nthen the controller\nu\nâ€‹\n(\nx\n,\nt\n)\nâˆˆ\nK\nc\nâ€‹\nb\nâ€‹\nf\nâ€‹\n(\nx\n,\nt\n)\nu(x,t)\\in{K}_{cbf}(x,t)\nguarantees the safety of the system (\n1\n).\nII-A2\nGaussian Process Regression\nGaussian Process (GP) regression\n[\nseeger2004gaussian\n]\nis a non-parametric Bayesian method widely employed for nonlinear regression tasks. Unlike parametric approaches, GP regression models the unknown target function as a probability distribution over functions, enabling predictions based on correlations among observed data points, rather than requiring parameter updates using large-scale datasets. This property makes GP regression particularly suitable for sparse and noisy datasets.\nMathematically, a GP can be fully characterized by its mean and kernel functions. For simplicity, we adopt a zero-mean Gaussian process expressed as\nf\nâˆ¼\nğ’¢\nâ€‹\nğ’«\nâ€‹\n(\n0\n,\nk\nâ€‹\n(\nx\n,\nx\nâ€²\n)\n)\n,\nf\\sim\\mathcal{GP}\\left(0,k({x},{x}^{\\prime})\\right),\nwhere the kernel function\nk\nâ€‹\n(\nx\n,\nx\nâ€²\n)\n:\nğ’³\nÃ—\nğ’³\nâ†’\nâ„\nk({x},{x}^{\\prime}):\\mathcal{X}\\times\\mathcal{X}\\to\\mathbb{R}\nquantifies the similarity or correlation between two arbitrary input points, and\nğ’³\nâˆˆ\nâ„\nr\n\\mathcal{X}\\in\\mathbb{R}^{r}\nrepresents the input space.\nConsider a training dataset consisting of\nN\nN\ninput-output pairs, denoted as\n{\nx\ni\n,\ny\ni\n}\ni\n=\n1\nN\n\\{{x}_{i},y_{i}\\}_{i=1}^{N}\n, where each input\nx\ni\nâˆˆ\nğ’³\nx_{i}\\in\\mathcal{X}\nis associated with a label\ny\ni\nâˆˆ\nâ„\ny_{i}\\in\\mathbb{R}\n.\nThe input and label datasets are defined as\nX\n=\n[\nx\n1\n,\nâ€¦\n,\nx\nN\n]\nğ–³\n{X}=[{x}_{1},\\ldots,{x}_{N}]^{\\mathsf{T}}\nand\nY\n=\n[\ny\n1\n,\nâ€¦\n,\ny\nN\n]\nğ–³\n{Y}=[y_{1},\\ldots,y_{N}]^{\\mathsf{T}}\n, respectively.\nFor an arbitrary query point\nx\nâˆ—\nâˆˆ\nğ’³\n{x}^{*}\\in\\mathcal{X}\n, the predicted output\ny\nâˆ—\n{y}^{*}\nfollows a Gaussian distribution given by\ny\nâˆ—\nâˆ¼\nğ’©\nâ€‹\n(\nÎ¼\nâ€‹\n(\nx\nâˆ—\n)\n,\nÏƒ\n2\nâ€‹\n(\ny\nâˆ—\n)\n)\n,\n{y}^{*}\\sim\\mathcal{N}(\\mu({x}^{*}),\\sigma^{2}({y}^{*})),\n(3)\nwhere the predictive mean and variance are computed by\nÎ¼\nâ€‹\n(\nx\nâˆ—\n)\n\\displaystyle\\mu({x}^{*})\n=\nk\nğ–³\nâ€‹\n(\nx\nâˆ—\n)\nâ€‹\nK\nâˆ’\n1\nâ€‹\nY\n,\n\\displaystyle={k}^{\\mathsf{T}}({x}^{*})K^{-1}{Y},\n(4a)\nÏƒ\n2\nâ€‹\n(\ny\nâˆ—\n)\n\\displaystyle\\sigma^{2}({y}^{*})\n=\nk\nâ€‹\n(\nx\nâˆ—\n,\nx\nâˆ—\n)\nâˆ’\nk\nğ–³\nâ€‹\n(\nx\nâˆ—\n)\nâ€‹\nK\nâˆ’\n1\nâ€‹\nk\nâ€‹\n(\nx\nâˆ—\n)\n,\n\\displaystyle=k({x}^{*},{x}^{*})-{k}^{\\mathsf{T}}({x}^{*})K^{-1}{k}({x}^{*}),\n(4b)\nwhere\nK\nâˆˆ\nâ„\nN\nÃ—\nN\nK\\in\\mathbb{R}^{N\\times N}\nis the covariance matrix with elements\n[\nK\n]\ni\nâ€‹\nj\n=\nk\nâ€‹\n(\nx\ni\n,\nx\nj\n)\n,\ni\n,\nj\nâˆˆ\n{\n1\n,\nâ€¦\n,\nN\n}\n[K]_{ij}=k({x}_{i},{x}_{j}),\\,i,j\\in\\{1,\\ldots,N\\}\n,\nand\nk\nâ€‹\n(\nx\nâˆ—\n)\n=\n[\nk\nâ€‹\n(\nx\nâˆ—\n,\nx\n1\n)\n,\nâ€¦\n,\nk\nâ€‹\n(\nx\nâˆ—\n,\nx\nN\n)\n]\nğ–³\nâˆˆ\nâ„\nN\n{k}({x}^{*})=[k({x}^{*},{x}_{1}),\\ldots,k({x}^{*},{x}_{N})]^{\\mathsf{T}}\\in\\mathbb{R}^{N}\nrepresents the covariance vector between the query point\nx\nâˆ—\n{x}^{*}\nand the input dataset.\nII-B\nProblem Description\nWe consider a wheeled differential-drive robot with state\nx\n=\n[\np\nx\n,\np\ny\n,\nÎ¸\n]\nğ–³\nâˆˆ\nğ’³\nâŠ†\nâ„\n2\nÃ—\n[\nâˆ’\nÏ€\n,\nÏ€\n)\nx=[p_{x},p_{y},\\theta]^{\\mathsf{T}}\\in\\mathcal{X}\\subseteq\\mathbb{R}^{2}\\times[-\\pi,\\pi)\nand control input\nu\n=\n[\nv\n,\nÏ‰\n]\nğ–³\nâˆˆ\nâ„\n2\nu=[v,\\omega]^{\\mathsf{T}}\\in\\mathbb{R}^{2}\n.\nThe robot dynamics is described by\n[\np\nË™\nx\np\nË™\ny\nÎ¸\nË™\n]\n=\n[\ncos\nâ¡\n(\nÎ¸\n)\n0\nsin\nâ¡\n(\nÎ¸\n)\n0\n0\n1\n]\nâ€‹\n[\nv\nÏ‰\n]\n.\n\\begin{aligned} \\begin{bmatrix}\\dot{p}_{x}\\\\\n\\dot{p}_{y}\\\\\n\\dot{\\theta}\\end{bmatrix}&=\\begin{bmatrix}\\cos(\\theta)&0\\\\\n\\sin(\\theta)&0\\\\\n0&1\\end{bmatrix}\\begin{bmatrix}v\\\\\n\\omega\\end{bmatrix}\\end{aligned}.\n(5)\nLet\nÏ•\n:\nğ’³\nâ†’\nâ„\n2\n\\phi:\\mathcal{X}\\to\\mathbb{R}^{2}\nbe the map from the robot state\nx\nx\nto its position\nÏ•\nâ€‹\n(\nx\n)\n=\n[\np\nx\n,\np\ny\n]\nğ–³\n\\phi(x)=[p_{x},p_{y}]^{\\mathsf{T}}\n.\nProblem Statement:\nConsider a mobile robot with dynamics (\n5\n) navigating in an unknown dynamic environment toward a predefined goal. The robot is equipped with a LiDAR sensor that provides measurements of obstacles.\nThe objective is to:\n1.\nSynthesize a dynamic control barrier function\nh\nâ€‹\n(\nx\n,\nt\n)\nh(x,t)\nonline using LiDAR data, ensuring real-time adaptation to environmental changes.\n2.\nDesign a controller\nu\nâ€‹\n(\nt\n)\nu(t)\nthat guarantees safe navigation toward the goal while avoiding obstacles.\nIII\nMethodology\nIII-A\nLocal Perception\nThe local perception module estimates obstacle positions and velocities in real-time using LiDAR sensor data, which are essential for synthesizing our proposed DLGP-CBF.\nSpecifically, we construct a local obstacle grid map\nâ„³\no\n,\nt\nâˆˆ\n{\n0\n,\n1\n}\nW\nÃ—\nH\n\\mathcal{M}_{o,t}\\in\\{0,1\\}^{W\\times H}\n, with width\nW\nW\nand height\nH\nH\n, centered on the robotâ€™s current position in the global coordinate frame.\nEach grid cell of the obstacle grid map\nâ„³\no\n,\nt\nâ€‹\n(\na\n,\nb\n)\n\\mathcal{M}_{o,t}(a,b)\nencodes the occupancy status of the corresponding spatial location and is updated at each time step\nt\nt\nas\nâ„³\no\n,\nt\nâ€‹\n(\na\n,\nb\n)\n=\n{\n1\n,\nif a LiDAR ray endpoint at time step\nâ€‹\nt\nfalls within cell\nâ€‹\n(\na\n,\nb\n)\n,\n0\n,\notherwise\n.\n\\small\\mathcal{M}_{o,t}(a,b)=\\begin{cases}1,&\\text{if a LiDAR ray endpoint at time step }t\\\\\n&\\text{ falls within cell }(a,b),\\\\\n0,&\\text{otherwise}.\\end{cases}\nSince our DLGP-CBF explicitly incorporates obstacle velocity information, a local velocity grid map\nâ„³\nv\n,\nt\nâˆˆ\nâ„\nW\nÃ—\nH\nÃ—\n2\n\\mathcal{M}_{v,t}\\in\\mathbb{R}^{W\\times H\\times 2}\nis also constructed.\nEach grid cell\nâ„³\nv\n,\nt\nâ€‹\n(\na\n,\nb\n)\nâˆˆ\nâ„\n2\n\\mathcal{M}_{v,t}(a,b)\\in\\mathbb{R}^{2}\nstores the predicted velocity vector of the obstacle at the corresponding spatial location.\nTo obtain velocity estimates, occupied grid cells in the obstacle grid map\nâ„³\no\n,\nt\n\\mathcal{M}_{o,t}\nare transformed into spatial points in the global frame, forming an array\nğ’Ÿ\nt\n=\n[\nd\n1\n,\nx\n,\nt\n,\nd\n1\n,\ny\n,\nt\n,\nâ€¦\n,\nd\nN\n,\nx\n,\nt\n,\nd\nN\n,\ny\n,\nt\n]\nğ–³\nâˆˆ\nâ„\n2\nâ€‹\nN\n\\mathcal{D}_{t}=[d_{1,x,t},d_{1,y,t},\\ldots,d_{N,x,t},d_{N,y,t}]^{\\mathsf{T}}\\in\\mathbb{R}^{2N}\n, where\nN\nN\ndenotes the number of occupied cells.\nWe use the DBSCAN algorithm\n[\nester1996density\n]\nto segment the points\nğ’Ÿ\nt\n\\mathcal{D}_{t}\ninto\nN\no\nâ€‹\nb\nâ€‹\ns\nN_{obs}\nclusters, denoted as\nğ’Ÿ\nt\n=\n{\nğ’Ÿ\n1\n,\nt\n,\nğ’Ÿ\n2\n,\nt\n,\nâ€¦\n,\nğ’Ÿ\nN\no\nâ€‹\nb\nâ€‹\ns\n,\nt\n}\n\\mathcal{D}_{t}=\\{\\mathcal{D}_{1,t},\\mathcal{D}_{2,t},\\ldots,\\mathcal{D}_{N_{obs},t}\\}\n.\nFollowing the clustering process, the minimum bounding ellipse (MBE) algorithm\n[\nwelzl2005smallest\n]\nis used to fit each cluster with a MBE.\nThe set of MBEs is denoted as\nâ„°\nt\n=\n{\nâ„°\n1\n,\nt\n,\nâ„°\n2\n,\nt\n,\nâ€¦\n,\nâ„°\nN\no\nâ€‹\nb\nâ€‹\ns\n,\nt\n}\n\\mathcal{E}_{t}=\\{\\mathcal{E}_{1,t},\\mathcal{E}_{2,t},\\ldots,\\mathcal{E}_{N_{obs},t}\\}\n, where each ellipse\nâ„°\ni\n,\nt\n=\n[\nc\ni\n,\nx\n,\nt\n,\nc\ni\n,\ny\n,\nt\n,\na\ni\n,\nt\n,\nb\ni\n,\nt\n,\nÎ¸\ni\n,\nt\n]\nğ–³\n\\mathcal{E}_{i,t}=[c_{i,x,t},c_{i,y,t},a_{i,t},b_{i,t},\\theta_{i,t}]^{\\mathsf{T}}\nis parameterized by its center coordinates\n[\nc\ni\n,\nx\n,\nt\n,\nc\ni\n,\ny\n,\nt\n]\nğ–³\n[c_{i,x,t},c_{i,y,t}]^{\\mathsf{T}}\n, semi-major axis\na\ni\n,\nt\na_{i,t}\n, semi-minor axis\nb\ni\n,\nt\nb_{i,t}\n, and orientation\nÎ¸\ni\n,\nt\n\\theta_{i,t}\n.\nTo establish temporal correspondences between ellipses at consecutive time steps, we compare the MBEs from the previous frame with those at the current frame.\nFor this purpose, we define an affinity matrix\nğ’œ\nâˆˆ\nâ„\nN\no\nâ€‹\nb\nâ€‹\ns\n,\nt\nâˆ’\n1\nÃ—\nN\no\nâ€‹\nb\nâ€‹\ns\n,\nt\n\\mathcal{A}\\in\\mathbb{R}^{N_{obs,t-1}\\times N_{obs,t}}\n, where each element\nğ’œ\ni\n,\nj\n\\mathcal{A}_{i,j}\nrepresents the distance between the\ni\ni\n-th ellipse at\nt\nâˆ’\n1\nt-1\nand the\nj\nj\n-th ellipse at\nt\nt\n.\nThe Kuhn-Munkres algorithm\n[\nkuhn1955hungarian\n]\nis applied to compute the optimal association between ellipses across frames. Matches with a distance exceeding a predefined threshold\nd\nm\nâ€‹\na\nâ€‹\nx\nd_{max}\nare classified as new obstacles, and newly detected ellipses are assigned fresh labels.\nFor MBEs successfully matched across time steps, we employ Kalman filtering\n[\nwelch1995introduction\n]\nto estimate their velocities.\nThe state variable of each tracked MBE is defined as\nâ„°\n^\nl\n=\n[\nc\nl\n,\nx\n,\nc\nl\n,\ny\n,\nc\nË™\nl\n,\nx\n,\nc\nË™\nl\n,\ny\n,\nc\nÂ¨\nl\n,\nx\n,\nc\nÂ¨\nl\n,\ny\n,\na\nl\n,\nb\nl\n,\nÎ¸\nl\n]\nğ–³\n\\hat{\\mathcal{E}}_{l}=[c_{l,x},c_{l,y},\\dot{c}_{l,x},\\dot{c}_{l,y},\\ddot{c}_{l,x},\\ddot{c}_{l,y},a_{l},b_{l},\\theta_{l}]^{\\mathsf{T}}\n, where\nc\nË™\nl\n,\nx\n\\dot{c}_{l,x}\nand\nc\nË™\nl\n,\ny\n\\dot{c}_{l,y}\ndenote the velocity, and\nc\nÂ¨\nl\n,\nx\n\\ddot{c}_{l,x}\nand\nc\nÂ¨\nl\n,\ny\n\\ddot{c}_{l,y}\ndenote the acceleration of the ellipse.\nThrough iterative prediction and measurement updates, we obtain the estimated velocity\nv\nl\n=\n[\nc\nË™\nl\n,\nx\n,\nc\nË™\nl\n,\ny\n]\nğ–³\nv_{l}=[\\dot{c}_{l,x},\\dot{c}_{l,y}]^{\\mathsf{T}}\nof each ellipse\nâ„°\n^\nl\n\\hat{\\mathcal{E}}_{l}\n.\nThe computed velocity\nv\nl\nv_{l}\nis then assigned to the corresponding point cluster and subsequently mapped to the appropriate grid cell in the velocity grid map\nâ„³\nv\n,\nt\n\\mathcal{M}_{v,t}\n,\nthereby explicitly encoding obstacle velocity information for subsequent DLGP-CBF synthesis.\nIII-B\nDynamic Log-GP CBF Synthesis\nWe employ GP regression to construct the Dynamic Log Gaussian Process Control Barrier Function (DLGP-CBF), which quantifies the robotâ€™s safety level based on its state and obstacle information from LiDAR measurements.\nSpecifically, the DLGP-CBF, denoted as\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nh(x,\\mathcal{D})\n, is defined as\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\n=\nâˆ’\nc\ns\nâ€‹\nlog\nâ¡\n(\nÎ¼\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nğ’Ÿ\n)\n)\nâˆ’\nd\nshift\n,\nh(x,\\mathcal{D})=-c_{s}\\log(\\mu(\\phi(x),\\mathcal{D}))-d_{\\text{shift}},\n(6)\nwhere\nÎ¼\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nğ’Ÿ\n)\n\\mu(\\phi(x),\\mathcal{D})\ndenotes the predictive mean from the GP regression evaluated at the query position\nÏ•\nâ€‹\n(\nx\n)\n\\phi(x)\nwith respect to the training dataset\nğ’Ÿ\n\\mathcal{D}\n,\nand the user-defined parameters\nc\ns\nâˆˆ\nâ„\n+\nc_{s}\\in\\mathbb{R}^{+}\nand\nd\nshift\nâˆˆ\nâ„\n+\nd_{\\text{shift}}\\in\\mathbb{R}^{+}\nrepresent the scaling factor and the safety margin adjustment, respectively.\nTo form the training dataset for GP regression, positional information of the detected obstacles is extracted from the local obstacle grid map\nâ„³\no\n\\mathcal{M}_{o}\n.\nSpecifically, occupied grid cells in\nâ„³\no\n\\mathcal{M}_{o}\nare transformed into spatial points within the global coordinate frame, forming the input dataset as\nğ’Ÿ\n=\n[\nd\n1\nğ–³\n,\nâ€¦\n,\nd\nN\nğ–³\n]\nğ–³\nâˆˆ\nâ„\n2\nâ€‹\nN\n,\n\\mathcal{D}=\\left[d_{1}^{\\mathsf{T}},\\ldots,d_{N}^{\\mathsf{T}}\\right]^{\\mathsf{T}}\\in\\mathbb{R}^{2N},\n(7)\nwhere\nd\ni\n=\n[\nd\ni\n,\nx\n,\nd\ni\n,\ny\n]\nğ–³\nd_{i}=\\left[d_{i,x},d_{i,y}\\right]^{\\mathsf{T}}\ndenotes the global coordinates of the\ni\ni\n-th occupied grid cell, and\nN\nN\nrepresents the total number of occupied cells.\nSimilarly, the velocity information for obstacles is extracted from the velocity grid map\nâ„³\nv\n\\mathcal{M}_{v}\ninto the velocity array:\nğ’±\n=\n[\nv\n1\nğ–³\n,\nâ€¦\n,\nv\nN\nğ–³\n]\nğ–³\nâˆˆ\nâ„\n2\nâ€‹\nN\n,\n\\mathcal{V}=\\left[v_{1}^{\\mathsf{T}},\\ldots,v_{N}^{\\mathsf{T}}\\right]^{\\mathsf{T}}\\in\\mathbb{R}^{2N},\n(8)\nwhere\nv\ni\n=\n[\nv\ni\n,\nx\n,\nv\ni\n,\ny\n]\nğ–³\nv_{i}=\\left[v_{i,x},v_{i,y}\\right]^{\\mathsf{T}}\ndenotes the velocity vector of the\ni\ni\n-th occupied grid cell.\nEach input data point in\nğ’Ÿ\n\\mathcal{D}\nis assigned the label\ny\ni\n=\n1\ny_{i}=1\n, forming the corresponding label dataset\nY\n=\n[\ny\n1\n,\nâ€¦\n,\ny\nN\n]\nğ–³\nâˆˆ\nâ„\nN\nY=[y_{1},\\ldots,y_{N}]^{\\mathsf{T}}\\in\\mathbb{R}^{N}\n.\nWe use the zero-mean GP regression model with the squared exponential (SE) kernel function\nk\nâ€‹\n(\np\n,\np\nâ€²\n)\n=\ne\nâˆ’\nâ€–\np\nâˆ’\np\nâ€²\nâ€–\n2\n2\nâ€‹\nl\n2\nk\\left(p,p^{\\prime}\\right)={e^{-\\frac{||p-p^{\\prime}||^{2}}{2l^{2}}}}\nto construct the DLGP-CBF, where\nl\nl\ndenote the length scale of the SE kernel.\nThe predictive mean\nÎ¼\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nğ’Ÿ\n)\n\\mu(\\phi(x),\\mathcal{D})\nis computed by\nÎ¼\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nğ’Ÿ\n)\n=\nk\n~\nğ–³\nâ€‹\nK\nâˆ’\n1\nâ€‹\nY\n,\n\\mu(\\phi(x),\\mathcal{D})={\\tilde{k}}^{\\mathsf{T}}K^{-1}{Y},\n(9)\nwhere\nk\n~\n=\n[\nk\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nd\n1\n)\n,\nâ€¦\n,\nk\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nd\nN\n)\n]\nğ–³\nâˆˆ\nâ„\nN\n{\\tilde{k}}=[k(\\phi(x),{d}_{1}),\\ldots,k(\\phi(x),{d}_{N})]^{\\mathsf{T}}\\in\\mathbb{R}^{N}\ndenotes the covariance vector between the query point\nÏ•\nâ€‹\n(\nx\n)\n\\phi(x)\nand the input dataset\nğ’Ÿ\n\\mathcal{D}\n,\nand\nK\nâˆˆ\nâ„\nN\nÃ—\nN\nK\\in\\mathbb{R}^{N\\times N}\nis the covariance matrix with elements\n[\nK\n]\ni\nâ€‹\nj\n=\nk\nâ€‹\n(\nd\ni\n,\nd\nj\n)\n,\ni\n,\nj\nâˆˆ\n{\n1\n,\nâ€¦\n,\nN\n}\n[K]_{ij}=k({d}_{i},{d}_{j}),\\,i,j\\in\\{1,\\ldots,N\\}\n.\nThe SE kernel ensures smoothness and continuity in the resulting DLGP-CBF, and the covariance matrix\nK\nK\nis positive definite due to the properties of the kernel.\nThe following theorem characterizes the properties of the DLGP-CBF\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nh(x,\\mathcal{D})\n.\nTheorem 1\nConsider the input dataset\nğ’Ÿ\n\\mathcal{D}\ndefined in (\n7\n) consisting of obstacle positions, and the corresponding label dataset\nY\n=\nğŸ\nN\nY=\\mathbf{1}_{N}\n, where\nğŸ\nN\n\\mathbf{1}_{N}\nis the vector of ones.\nThe DLGP-CBF\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nh(x,\\mathcal{D})\ndefined in (\n6\n) maps the robotâ€™s state to the range\n[\nâˆ’\nd\nshift\n,\n+\nâˆ\n)\n[-d_{\\text{shift}},+\\infty)\nbased on its distance from obstacles.\nLet\nd\nmin\n=\nmin\nd\nâˆˆ\nğ’Ÿ\nâ€‹\nâ€–\nÏ•\nâ€‹\n(\nx\n)\nâˆ’\nd\nâ€–\nd_{\\text{min}}=\\min_{d\\in\\mathcal{D}}||\\phi(x)-d||\ndenote the minimum distance between the robot and the obstacle positions within the input dataset\nğ’Ÿ\n\\mathcal{D}\n.\nThen, the DLGP-CBF\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nh(x,\\mathcal{D})\nsatisfies:\nâ€¢\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\n=\nâˆ’\nd\nshift\nh(x,\\mathcal{D})=-d_{\\text{shift}}\n, when\nd\nmin\n=\n0\nd_{\\text{min}}=0\n;\nâ€¢\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nâ†’\n+\nâˆ\nh(x,\\mathcal{D})\\to+\\infty\n, as\nd\nmin\nâ†’\n+\nâˆ\nd_{\\text{min}}\\to+\\infty\n;\nâ€¢\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nh(x,\\mathcal{D})\nis a strictly decreasing function of\nd\nmin\nd_{\\text{min}}\n.\nProof:\nWhen\nd\nmin\n=\n0\nd_{\\text{min}}=0\n, i.e.,\nÏ•\nâ€‹\n(\nx\n)\n=\nd\nj\n\\phi(x)=d_{j}\nfor some\nj\nâˆˆ\n{\n1\n,\nâ€¦\n,\nN\n}\nj\\in\\{1,\\ldots,N\\}\n, the predictive mean\nÎ¼\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nğ’Ÿ\n)\n\\mu(\\phi(x),\\mathcal{D})\ncan be expressed as\nÎ¼\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nğ’Ÿ\n)\n=\n[\nK\n]\n:\n,\nj\nğ–³\nâ€‹\nK\nâˆ’\n1\nâ€‹\nğŸ\nN\n=\ne\nj\nğ–³\nâ€‹\nğŸ\nN\n=\n1\n,\n\\small\\mu(\\phi(x),\\mathcal{D})=[K]_{:,j}^{\\mathsf{T}}K^{-1}{\\mathbf{1}_{N}}=e_{j}^{\\mathsf{T}}{\\mathbf{1}_{N}}=1,\nwhere\n[\nK\n]\n:\n,\nj\n[K]_{:,j}\ndenotes the\nj\nj\n-th column of matrix\nK\nK\nand\ne\nj\ne_{j}\ndenotes the\nj\nj\n-th standard basis vector.\nThus,\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\n=\nâˆ’\nc\ns\nâ€‹\nlog\nâ¡\n(\n1\n)\nâˆ’\nd\nshift\n=\nâˆ’\nd\nshift\nh(x,\\mathcal{D})=-c_{s}\\log(1)-d_{\\text{shift}}=-d_{\\text{shift}}\n.\nAs\nd\nmin\nâ†’\n+\nâˆ\nd_{\\text{min}}\\to+\\infty\n, the covariance vector\nk\n~\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n)\n\\tilde{k}(\\phi(x))\napproaches to the zero vector, i.e.,\nlim\nd\nmin\nâ†’\n+\nâˆ\nk\n~\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n)\n=\nğŸ\nN\n\\lim_{d_{\\text{min}}\\to+\\infty}\\tilde{k}(\\phi(x))=\\mathbf{0}_{N}\n, leading to\nÎ¼\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nğ’Ÿ\n)\nâ†’\n0\n\\mu(\\phi(x),\\mathcal{D})\\to 0\n, and hence\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nâ†’\n+\nâˆ\nh(x,\\mathcal{D})\\to+\\infty\n.\nAdditionally, the SE kernel satisfies\nâˆ‚\nk\nâˆ‚\nâ€–\np\nâˆ’\np\nâ€²\nâ€–\n<\n0\n\\frac{\\partial k}{\\partial||p-p^{\\prime}||}<0\n, which implies that as\nd\nmin\nd_{\\text{min}}\nincreases, each entry in\nk\n~\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n)\n\\tilde{k}(\\phi(x))\ndecreases or remains the same.\nSince the predictive mean\nÎ¼\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nğ’Ÿ\n)\n\\mu(\\phi(x),\\mathcal{D})\nis a positive linear combination of the entries in\nk\n~\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n)\n\\tilde{k}(\\phi(x))\n, it is strictly decreasing with respect to\nd\nmin\nd_{\\text{min}}\n.\nAfter applying the logarithmic transformation, the DLGP-CBF is strictly increasing with respect to\nd\nmin\nd_{\\text{min}}\n, proving the stated properties.\nâˆ\nRemark 1\nThe parameter\nd\nshift\nd_{\\text{shift}}\nin the DLGP-CBF formulation (\n6\n) is specially designed to adjust the size of the safe set around obstacles.\nA large\nd\nshift\nd_{\\text{shift}}\nvalue results in a larger zero-level set, thereby inducing a more conservative obstacle avoidance behavior.\nConversely, choosing a smaller\nd\nshift\nd_{\\text{shift}}\nvalue may allow the robot to approach obstacles more closely, leading to a more aggressive navigation strategy.\nRemark 2\nThe proposed DLGP-CBF, defined in (\n6\n), introduces two distinct innovations compared to conventional GP-based methods.\nFirst, through the logarithmic transformation, the DLGP-CBF ensures that the barrier function values and gradients remain informative and non-vanishing at locations distant from the training data (see Fig.\n1\n), thus significantly enhancing the continuity and reliability of barrier information.\nSecond, the DLGP-CBF explicitly depends on obstacle positional data encoded within the training dataset, enabling the model to dynamically reflect obstacle positions and motions. These properties collectively improve the robotâ€™s capability to perform accurate, timely, and efficient obstacle avoidance behavior, consequently enhancing safety in dynamic environments.\nFigure 1:\nVisualization of the DLGP-CBF function with\nc\ns\n=\n1\nc_{s}=1\n,\nd\nshift\n=\n0.1\nd_{\\text{shift}}=0.1\n, and the SE kernel length scale\nl\n=\n0.9\nl=0.9\n.\nIII-C\nSafe Control via DLGP-CBF\nAt each control step\nt\nt\n, the latest updated obstacle grid map\nâ„³\no\n,\nt\n\\mathcal{M}_{o,t}\nand the velocity grid map\nâ„³\nv\n,\nt\n\\mathcal{M}_{v,t}\nare utilized to construct the input dataset\nğ’Ÿ\nt\n\\mathcal{D}_{t}\nand the velocity dataset\nğ’±\nt\n\\mathcal{V}_{t}\nas defined in (\n7\n) and (\n8\n), respectively.\nThe DLGP-CBF is then updated using these newly constructed datasets.\nFor notational simplicity, we omit the time dependence of\nğ’Ÿ\nt\n\\mathcal{D}_{t}\nand\nğ’±\nt\n\\mathcal{V}_{t}\nin the subsequent discussion.\nGiven the dynamics (\n5\n), we derive the safe control input by solving\nthe following quadratic programming (QP) problem:\nmin\nu\nâˆˆ\nâ„\n2\n\\displaystyle\\min_{u\\in\\mathbb{R}^{2}}\nâ€–\nu\nâˆ’\nu\nnom\nâ€‹\n(\nt\n)\nâ€–\n2\n,\n\\displaystyle\\quad||u-u_{\\text{nom}}(t)||^{2},\n(10)\ns.t.\nâ„’\nf\nâ€‹\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\n+\nâ„’\ng\nâ€‹\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nâ€‹\nu\n\\displaystyle\\quad\\mathcal{L}_{f}h(x,\\mathcal{D})+\\mathcal{L}_{g}h(x,\\mathcal{D})u\n+\nâˆ‚\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nâˆ‚\nt\n+\nÎ±\nâ€‹\n(\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\n)\nâ‰¥\n0\n,\n\\displaystyle\\quad+\\frac{\\partial h(x,\\mathcal{D})}{\\partial t}+\\alpha(h(x,\\mathcal{D}))\\geq 0,\nwhere\nu\nnom\nâ€‹\n(\nt\n)\nu_{\\text{nom}}(t)\nis the nominal control input that may not inherently guarantee safety.\nTo construct the CBF constraint explicitly, we need to compute both the spatial gradient\nâˆ‚\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nâˆ‚\nx\n\\frac{\\partial h(x,\\mathcal{D})}{\\partial x}\n, reflecting the influence of the robotâ€™s state on the barrier function, and the time derivative\nâˆ‚\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nâˆ‚\nt\n\\frac{\\partial h(x,\\mathcal{D})}{\\partial t}\n, capturing the effect of moving obstacles on the barrier function.\nThe partial derivative of\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nh(x,\\mathcal{D})\nwith respect to the robot state\nx\nx\nis calculated as\nâˆ‚\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nâˆ‚\nx\n=\nâˆ’\nc\ns\nâ€‹\n[\nY\nğ–³\nâ€‹\nK\nâˆ’\n1\nâ€‹\nâˆ‚\nk\n~\nâˆ‚\nÏ•\nâ€‹\n(\nx\n)\n,\n0\n]\nğ–³\nÎ¼\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nğ’Ÿ\n)\n,\n\\displaystyle\\frac{\\partial h(x,\\mathcal{D})}{\\partial x}=-c_{s}\\frac{\\left[Y^{\\mathsf{T}}K^{-1}\\frac{\\partial\\tilde{k}}{\\partial\\phi(x)},0\\right]^{\\mathsf{T}}}{\\mu(\\phi(x),\\mathcal{D})},\n(11)\nwhere\nâˆ‚\nk\n~\nâˆ‚\nÏ•\nâ€‹\n(\nx\n)\nâˆˆ\nâ„\nN\nÃ—\n2\n\\frac{\\partial\\tilde{k}}{\\partial\\phi(x)}\\in\\mathbb{R}^{N\\times 2}\nis the derivative of the covariance vector with respect to the robotâ€™s position\nÏ•\nâ€‹\n(\nx\n)\n\\phi(x)\n.\nThe derivative\nâˆ‚\nk\n~\nâˆ‚\nÏ•\nâ€‹\n(\nx\n)\n\\frac{\\partial\\tilde{k}}{\\partial\\phi(x)}\nis given by\nâˆ‚\nk\n~\nâˆ‚\nÏ•\nâ€‹\n(\nx\n)\n=\n[\nâˆ’\n1\nl\n2\nâ€‹\nk\nse\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nd\n1\n)\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\nâˆ’\nd\n1\n)\nğ–³\nâ‹®\nâˆ’\n1\nl\n2\nâ€‹\nk\nse\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nd\nN\n)\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\nâˆ’\nd\nN\n)\nğ–³\n]\n,\n\\frac{\\partial\\tilde{k}}{\\partial\\phi(x)}=\\begin{bmatrix}-\\frac{1}{l^{2}}k_{\\text{se}}(\\phi(x),d_{1})(\\phi(x)-d_{1})^{\\mathsf{T}}\\\\\n\\vdots\\\\\n-\\frac{1}{l^{2}}k_{\\text{se}}(\\phi(x),d_{N})(\\phi(x)-d_{N})^{\\mathsf{T}}\\end{bmatrix},\n(12)\nwhere\nd\ni\nd_{i}\nis the global coordinates of the\ni\ni\n-th training point in the input dataset\nğ’Ÿ\n\\mathcal{D}\n.\nAdditionally, as\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nh(x,\\mathcal{D})\nexplicitly depends on obstacle positions encoded within the input dataset\nğ’Ÿ\n\\mathcal{D}\n,\nchanges in obstacle positions directly influence the barrier function through the time derivative, calculated by\nâˆ‚\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nâˆ‚\nt\n=\n\\displaystyle\\frac{\\partial h(x,\\mathcal{D})}{\\partial t}=\nâˆ‘\nr\n=\n1\nN\nâˆ‚\nh\nâ€‹\n(\nx\n,\nd\n1\n,\nâ€¦\n,\nd\nN\n)\nâˆ‚\nd\nr\nâ€‹\nâˆ‚\nd\nr\nâˆ‚\nt\n\\displaystyle\\sum_{r=1}^{N}\\frac{\\partial h(x,d_{1},\\ldots,d_{N})}{\\partial d_{r}}\\frac{\\partial d_{r}}{\\partial t}\n(13)\n=\n\\displaystyle=\nc\ns\nâ€‹\nY\nğ–³\nâ€‹\nK\nâˆ’\n1\nâŠ—\nk\n~\nğ–³\nâ€‹\nK\nâˆ’\n1\nÎ¼\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nğ’Ÿ\n)\nâ€‹\nâˆ‘\nr\n=\n1\nN\nâˆ‚\nK\nâˆ‚\nd\nr\nâ€‹\nv\nr\n\\displaystyle\\frac{c_{s}Y^{\\mathsf{T}}K^{-1}\\otimes\\tilde{k}^{\\mathsf{T}}K^{-1}}{\\mu(\\phi(x),\\mathcal{D})}\\sum_{r=1}^{N}\\frac{\\partial K}{\\partial d_{r}}v_{r}\nâˆ’\nc\ns\nâ€‹\nY\nğ–³\nâ€‹\nK\nâˆ’\n1\nÎ¼\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nğ’Ÿ\n)\nâ€‹\nâˆ‘\nr\n=\n1\nN\nâˆ‚\nk\n~\nâˆ‚\nd\nr\nâ€‹\nv\nr\n,\n\\displaystyle-\\frac{c_{s}Y^{\\mathsf{T}}K^{-1}}{\\mu(\\phi(x),\\mathcal{D})}\\sum_{r=1}^{N}\\frac{\\partial\\tilde{k}}{\\partial d_{r}}v_{r},\nwhere\nâŠ—\n\\otimes\ndenotes the Kronecker product,\nv\nr\nv_{r}\ndenotes the velocity of the\nr\nr\n-th training point\nd\nr\nd_{r}\n,\nand the term\nâˆ‚\nK\nâˆ‚\nd\nr\nâˆˆ\nâ„\nN\n2\nÃ—\n2\n\\frac{\\partial K}{\\partial d_{r}}\\in\\mathbb{R}^{N^{2}\\times 2}\nand\nâˆ‚\nk\n~\nâˆ‚\nd\nr\nâˆˆ\nâ„\nN\nÃ—\n2\n\\frac{\\partial\\tilde{k}}{\\partial d_{r}}\\in\\mathbb{R}^{N\\times 2}\ndenote the partial derivatives of the covariance matrix\nK\nK\nand the covariance vector\nk\n~\n\\tilde{k}\nwith respect to the\nr\nr\n-th training point\nd\nr\nd_{r}\n, respectively.\nSpecifically, the derivative\nâˆ‚\nK\nâˆ‚\nd\nr\n\\frac{\\partial K}{\\partial d_{r}}\nis given by\nâˆ‚\nK\nâˆ‚\nd\nr\n=\nâˆ‚\nvec\nâ€‹\n(\nK\n)\nâˆ‚\nd\nr\n=\n[\nâˆ‚\nK\ni\nâ€‹\nj\nâˆ‚\nd\nr\n]\n\\displaystyle\\frac{\\partial K}{\\partial d_{r}}=\\frac{\\partial\\mathrm{vec}(K)}{\\partial d_{r}}=\\left[\\frac{\\partial K_{ij}}{\\partial d_{r}}\\right]\n(14)\n=\n\\displaystyle=\n[\nâˆ’\n1\nl\n2\nâ€‹\nK\ni\nâ€‹\nj\nâ€‹\n(\nÎ´\nr\nâ€‹\ni\nâ€‹\n(\nd\ni\nâˆ’\nd\nj\n)\nğ–³\n+\nÎ´\nr\nâ€‹\nj\nâ€‹\n(\nd\nj\nâˆ’\nd\ni\n)\nğ–³\n)\n]\ni\n,\nj\n=\n1\nN\n,\n\\displaystyle\\left[-\\frac{1}{l^{2}}K_{ij}\\left(\\ \\delta_{ri}(d_{i}-d_{j})^{\\mathsf{T}}+\\delta_{rj}(d_{j}-d_{i})^{\\mathsf{T}}\\right)\\right]_{i,j=1}^{N},\nwhere\nvec\nâ€‹\n(\nK\n)\n\\mathrm{vec}(K)\ndenotes the vectorization operation which stacks the columns of the matrix\nK\nK\ninto a single column vector.\nThe derivative\nâˆ‚\nk\n~\nâˆ‚\nd\nr\n\\frac{\\partial\\tilde{k}}{\\partial d_{r}}\nis expressed as\nâˆ‚\nk\n~\nâˆ‚\nd\nr\n=\n[\n1\nl\n2\nâ€‹\nk\nse\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nd\n1\n)\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\nâˆ’\nd\n1\n)\nğ–³\nâ€‹\nÎ´\nr\nâ€‹\n1\nâ‹®\n1\nl\n2\nâ€‹\nk\nse\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\n,\nd\nN\n)\nâ€‹\n(\nÏ•\nâ€‹\n(\nx\n)\nâˆ’\nd\nN\n)\nğ–³\nâ€‹\nÎ´\nr\nâ€‹\nN\n]\n.\n\\frac{\\partial\\tilde{k}}{\\partial d_{r}}=\\begin{bmatrix}\\frac{1}{l^{2}}k_{\\text{se}}(\\phi(x),d_{1})(\\phi(x)-d_{1})^{\\mathsf{T}}\\delta_{r1}\\\\\n\\vdots\\\\\n\\frac{1}{l^{2}}k_{\\text{se}}(\\phi(x),d_{N})(\\phi(x)-d_{N})^{\\mathsf{T}}\\delta_{rN}\\end{bmatrix}.\n(15)\nFinally, once the terms\nâˆ‚\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nâˆ‚\nx\n\\frac{\\partial h(x,\\mathcal{D})}{\\partial x}\nand\nâˆ‚\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nâˆ‚\nt\n\\frac{\\partial h(x,\\mathcal{D})}{\\partial t}\nare computed, the safe control input\nu\nâ€‹\n(\nt\n)\nu(t)\ncan be obtained by solving the QP problem (\n10\n), thereby ensuring the robotâ€™s safety in dynamic environments.\nIV\nSimulations\nIV-A\nExperiment Setup\nTo evaluate the performance of the proposed method, simulations were conducted using the TurtleBot3 robot in the Gazebo simulator. The robot operates in an unknown dynamic environment and is equipped with a Velodyne VLP-16 LiDAR sensor to perceive its surroundings.\nThe robot starts at the initial position\n[\nâˆ’\n8\n,\n3\n]\nğ–³\n[-8,3]^{\\mathsf{T}}\nand is tasked with reaching a predefined goal position\np\ngoal\n=\n[\n10\n,\nâˆ’\n2\n]\nğ–³\np_{\\text{goal}}=[10,-2]^{\\mathsf{T}}\nwhile avoiding both static and dynamic obstacles.\nThe nominal controller\nu\nnom\nâ€‹\n(\nt\n)\nu_{\\text{nom}}(t)\nis designed as a go-to-goal controller that steers the robot towards a predefined goal position, and is defined as\nu\nnom\nâ€‹\n(\nt\n)\n=\nu\nmax\nâ€‹\np\ngoal\nâˆ’\nÏ•\nâ€‹\n(\nx\n)\nâ€–\np\ngoal\nâˆ’\nÏ•\nâ€‹\n(\nx\n)\nâ€–\nu_{\\text{nom}}(t)=u_{\\text{max}}\\frac{p_{\\text{goal}}-\\phi(x)}{\\|p_{\\text{goal}}-\\phi(x)\\|}\n, where\nu\nmax\nâˆˆ\nâ„\n+\nu_{\\text{max}}\\in\\mathbb{R}^{+}\nis the maximum control input magnitude.\nSince the relative degree of the DLGP-CBF (\n6\n) with respect to the angular velocity\nÏ‰\n\\omega\nis\n2\n2\n, (i.e., the CBF must be differentiated twice to expose\nÏ‰\n\\omega\nexplicitly), a virtual leading point is introduced to simplify the control design.\nFor more details, we refer the reader to\n[\ncortes2017coordinated\n]\n.\nSpecifically, the virtual leading point is defined at a distance\nl\nâˆˆ\nâ„\n+\nl\\in\\mathbb{R}^{+}\nahead of the robot along its heading direction as\np\nlead\n=\nÏ•\nâ€‹\n(\nx\n)\n+\nl\nâ€‹\n[\ncos\nâ¡\n(\nÎ¸\n)\n,\nsin\nâ¡\n(\nÎ¸\n)\n]\nğ–³\np_{\\text{lead}}=\\phi(x)+l[\\cos(\\theta),\\sin(\\theta)]^{\\mathsf{T}}\n, and it follows a single-integrator dynamics\np\nË™\nlead\n=\nu\nlead\n\\dot{p}_{\\text{lead}}=u_{\\text{lead}}\n.\nThe safe control input\nu\nlead\nâ€‹\n(\nt\n)\nu_{\\text{lead}}(t)\nis computed by solving the QP problemÂ (\n10\n). The corresponding control input\n[\nv\nâ€‹\n(\nt\n)\n,\nÏ‰\nâ€‹\n(\nt\n)\n]\nğ–³\n[v(t),\\omega(t)]^{\\mathsf{T}}\nfor the differential-drive robot, governed byÂ (\n5\n), is then recovered via a near-identity diffeomorphism:\n[\nv\nâ€‹\n(\nt\n)\nw\nâ€‹\n(\nt\n)\n]\n=\n[\ncos\nâ¡\n(\nÎ¸\nâ€‹\n(\nt\n)\n)\nsin\nâ¡\n(\nÎ¸\nâ€‹\n(\nt\n)\n)\nâˆ’\n1\nl\nâ€‹\nsin\nâ¡\n(\nÎ¸\nâ€‹\n(\nt\n)\n)\n1\nl\nâ€‹\ncos\nâ¡\n(\nÎ¸\nâ€‹\n(\nt\n)\n)\n]\nâ€‹\nu\nlead\nâ€‹\n(\nt\n)\n.\n\\begin{bmatrix}v(t)\\\\\nw(t)\\end{bmatrix}=\\begin{bmatrix}\\cos(\\theta(t))&\\sin(\\theta(t))\\\\\n-\\frac{1}{l}\\sin(\\theta(t))&\\frac{1}{l}\\cos(\\theta(t))\\end{bmatrix}u_{\\text{lead}}(t).\n(16)\nThe hyperparameter for SE kernel is set as\nl\n=\n0.9\nl=0.9\n.\nFor the DLGP-CBF defined in (\n6\n), the user-defined parameters are chosen as\nc\ns\n=\n1\nc_{s}=1\nand\nd\nshift\n=\n0.1\nd_{\\text{shift}}=0.1\n.\nAdditionally, the extended class\nğ’¦\nâˆ\n\\mathcal{K}_{\\infty}\nfunction used in the CBF constraint (\n10\n) is selected as\nÎ±\nâ€‹\n(\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\n)\n=\n0.2\nâ€‹\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\n\\alpha(h(x,\\mathcal{D}))=0.2h(x,\\mathcal{D})\n.\nIV-B\nSimulations\nWe evaluate the performance of the proposed DLGP-CBF method in a dynamic environment and compare it with two baseline approaches: GP-CBF\n[\nkeyumarsi2023lidar\n]\nand MPC-DCBF\n[\njian2023dynamic\n]\n.\nIV-B1\nPerformance of DLGP-CBF\nFigure 2:\nTrajectory generated by the DLGP-CBF method.\nDynamic and static obstacles are shown as colored and black circles, respectively.\nDotted rectangles indicate the positions of the robot and dynamic obstacles at selected timestamps.\nFigure 3:\nEvolution of the minimum distance to obstacles and the time derivative\nâˆ‚\nh\nâˆ‚\nt\n\\frac{\\partial h}{\\partial t}\nover time.\nGreen vertical lines correspond to the snapshot timestamps in Fig.\n2\n.\nFig.\n2\nshows the trajectory generated by DLGP-CBF. The robot successfully reaches the goal while avoiding both static and dynamic obstacles. The snapshots at different timestamps illustrate the robotâ€™s timely and proactive responses to approaching dynamic obstacles.\nTo further analyze this behavior, Fig.\n3\npresents the evolution of the minimum distance to obstacles and the time derivative\nâˆ‚\nh\nâ€‹\n(\nx\n,\nğ’Ÿ\n)\nâˆ‚\nt\n\\frac{\\partial h(x,\\mathcal{D})}{\\partial t}\n.\nAt critical moments corresponding to the snapshots in Fig.\n2\n, the time derivative becomes negative as obstacles move toward the robot, indicating a decreasing barrier value.\nThis triggers early avoidance maneuvers, yielding smoother and safer trajectories.\nIt is worth noting that the update time of the DLGP-CBF depends on the training dataset size.\nHowever, GP regression inherently leverages correlations between data points, allowing it to perform effectively with sparse training datasets\n[\nlyu\n]\n.\nTherefore, overly dense training data may introduce redundant information and increase computational complexity unnecessarily. In practice, the dataset can be downsampled to balance computational efficiency and control performance.\nIn our simulations, the average training dataset size is 30, resulting in an average inference time of approximately 21 ms, satisfying real-time control requirements.\nIV-B2\nComparison with Baseline Methods\nWe compare DLGP-CBF with GP-CBF and MPC-DCBF under the same experimental setup. The resulting trajectories are shown in Fig.\n4\n, and the quantitative results are summarized in Table I, using four metrics: minimum distance to obstacles during the whole navigating process, arrival time, and the variances of linear and angular velocities.\nAs observed, all methods achieve collision-free navigation. However, DLGP-CBF consistently maintains a larger minimum distance, achieves a shorter arrival time, and exhibits lower angular velocity variance, indicating enhanced safety, efficiency, and control smoothness.\nWhile MPC-DCBF also accounts for obstacle dynamics, its reliance on per-obstacle geometric fitting increases complexity and may degrade control consistency.\nIn contrast, DLGP-CBF constructs a single unified barrier function directly from LiDAR data, enabling more stable and scalable control performance, as shown in Table I.\nFigure 4:\nComparison of trajectories generated by different methods.\nThe colored circles represent dynamic obstacles with different velocities and the black circles represent static obstacles.\nTABLE I:\nPerformance comparison with baseline methods.\nAlgorithms\nMin.\nDist. (m)\nArrival\nTime (s)\nSpeed Variance\nLinear\nAngular\nMPC-DCBF\n0.129\n33.867\n0.110\n0.702\nGP-CBF\n0.161\n33.766\n0.143\n0.575\nOurs\n0.346\n30.533\n0.112\n0.339\nV\nConclusion\nIn this paper, we have proposed the DLGP-CBF to address the safety-critical navigation problem for robots operating in unknown and dynamic environments. The DLGP-CBF explicitly incorporates dynamic obstacle velocity information, enabling proactive and timely responses to moving obstacles. Additionally, through a logarithmic Gaussian Process formulation, the proposed method provides more accurate and informative barrier function values and gradients, even in regions distant from observed obstacles.\nSimulation results have validated the effectiveness of our method.",
    "preview_text": "Control Barrier Functions (CBFs) have emerged as efficient tools to address the safe navigation problem for robot applications. However, synthesizing informative and obstacle motion-aware CBFs online using real-time sensor data remains challenging, particularly in unknown and dynamic scenarios. Motived by this challenge, this paper aims to propose a novel Gaussian Process-based formulation of CBF, termed the Dynamic Log Gaussian Process Control Barrier Function (DLGP-CBF), to enable real-time construction of CBF which are both spatially informative and responsive to obstacle motion. Firstly, the DLGP-CBF leverages a logarithmic transformation of GP regression to generate smooth and informative barrier values and gradients, even in sparse-data regions. Secondly, by explicitly modeling the DLGP-CBF as a function of obstacle positions, the derived safety constraint integrates predicted obstacle velocities, allowing the controller to proactively respond to dynamic obstacles' motion. Simulation results demonstrate significant improvements in obstacle avoidance performance, including increased safety margins, smoother trajectories, and enhanced responsiveness compared to baseline methods.\n\nDynamic Log-Gaussian Process Control Barrier Function for Safe Robotic Navigation in Dynamic Environments\nXin Yin, Chenyang Liang, Yanning Guo and Jie Mei\nXin Yin and Chenyang Liang contributed equally to this work.Xin Yin, Chenyang Liang and Jie Mei are with the School of Intelligence Science and Engineering, Harbin Institute of Technology, Shenzhen, Guangdong 518055, China.Yanning Guo is with the Department of Control Science and Engineering, Harbin Institute of Technology, Heilongjiang 150001, China.This work was supported in part by the Shenzhen Fundamental Research Program under Grant JCYJ20241202124010014, in part by the Guangdong Basic and Applied Basic Research Foundation under Grant 2023B1515120018 and Grant 2024B1515040008, and in part by the National Natural Science Foundatio",
    "is_relevant": null,
    "relevance_score": 0.0,
    "extracted_keywords": [],
    "one_line_summary": "",
    "detailed_summary": "",
    "qa_pairs": [],
    "is_hidden": false,
    "is_starred": false,
    "published_date": "2025-12-01T13:38:43Z",
    "created_at": "2026-01-08T10:08:09.648048",
    "updated_at": "2026-01-08T10:08:09.648058",
    "flag": true
}