{
    "id": "2601.15006v1",
    "title": "DWPP: Dynamic Window Pure Pursuit Considering Velocity and Acceleration Constraints",
    "authors": [
        "Fumiya Ohnishi",
        "Masaki Takahashi"
    ],
    "abstract": "çº¯è¿½è¸ªåŠå…¶å˜ä½“å› å…¶ç®€å•æ€§å’Œè®¡ç®—æ•ˆç‡è€Œè¢«å¹¿æ³›åº”ç”¨äºç§»åŠ¨æœºå™¨äººè·¯å¾„è·Ÿè¸ªã€‚ç„¶è€Œï¼Œè®¸å¤šä¼ ç»Ÿæ–¹æ³•æœªæ˜ç¡®è€ƒè™‘é€Ÿåº¦ä¸åŠ é€Ÿåº¦çº¦æŸï¼Œå¯¼è‡´æŒ‡ä»¤é€Ÿåº¦ä¸å®é™…é€Ÿåº¦å­˜åœ¨åå·®ï¼Œè¿›è€Œå¼•å‘è¶…è°ƒåŠè·Ÿè¸ªæ€§èƒ½ä¸‹é™ã€‚ä¸ºè§£å†³è¿™ä¸€é—®é¢˜ï¼Œæœ¬æ–‡æå‡ºåŠ¨æ€çª—å£çº¯è¿½è¸ªæ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä»æ ¹æœ¬ä¸Šé‡æ„äº†æŒ‡ä»¤é€Ÿåº¦çš„è®¡ç®—è¿‡ç¨‹ï¼Œæ˜¾å¼èå…¥äº†é€Ÿåº¦ä¸åŠ é€Ÿåº¦çº¦æŸã€‚å…·ä½“è€Œè¨€ï¼ŒDWPPåœ¨é€Ÿåº¦ç©ºé—´ï¼ˆ$v$-$Ï‰$å¹³é¢ï¼‰ä¸­æ„å»ºæŒ‡ä»¤é€Ÿåº¦è®¡ç®—æ¨¡å‹ï¼Œå¹¶åœ¨åŠ¨æ€çª—å£å†…é€‰æ‹©æœ€æ¥è¿‘ç›´çº¿$Ï‰= Îºv$çš„ç‚¹ä½œä¸ºæŒ‡ä»¤é€Ÿåº¦ã€‚å®éªŒç»“æœè¡¨æ˜ï¼Œç›¸è¾ƒäºä¼ ç»Ÿçº¯è¿½è¸ªæ–¹æ³•ï¼ŒDWPPèƒ½å¤Ÿé¿å…äº§ç”Ÿè¿åçº¦æŸçš„æŒ‡ä»¤ï¼Œå¹¶å®ç°æ›´ä¼˜çš„è·¯å¾„è·Ÿè¸ªç²¾åº¦ã€‚è¯¥æ–¹æ³•å·²é›†æˆè‡³å®˜æ–¹Nav2ä»£ç åº“å¹¶å¼€æºå‘å¸ƒï¼ˆhttps://github.com/ros-navigation/navigation2ï¼‰ã€‚",
    "url": "https://arxiv.org/abs/2601.15006v1",
    "html_url": "https://arxiv.org/html/2601.15006v1",
    "html_content": "DWPP: Dynamic Window Pure Pursuit Considering Velocity and Acceleration Constraints\nFumiya Ohnishi\nfumiya-onishi@keio.jp\nMasaki Takahashi\ntakahashi@sd.keio.ac.jp\nAbstract\nPure pursuit and its variants are widely used for mobile robot path tracking owing to their simplicity and computational efficiency. However, many conventional approaches do not explicitly account for velocity and acceleration constraints, resulting in discrepancies between commanded and actual velocities that result in overshoot and degraded tracking performance. To address this problem, this paper proposes dynamic window pure pursuit (DWPP), which fundamentally reformulates the command velocity computation process to explicitly incorporate velocity and acceleration constraints. Specifically, DWPP formulates command velocity computation in the velocity space (the\nv\nv\nâ€“\nÏ‰\n\\omega\nplane) and selects the command velocity as the point within the dynamic window that is closest to the line\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\n. Experimental results demonstrate that DWPP avoids constraint-violating commands and achieves superior path-tracking accuracy compared with conventional pure pursuit methods. The proposed method has been integrated into the official Nav2 repository and is publicly available (\nhttps://github.com/ros-navigation/navigation2\n).\nkeywords:\nPure pursuit , Path planning , Motion planning , Mobile robot\nâ€ \nâ€ \njournal:\nRobotics and Autonomous Systems\n\\affiliation\n[1]organization=School of Science for Open and Environmental Systems, Graduate School of Science and Technology, Keio University,\naddressline=3-14-1 Hiyoshi,\ncity=Kohoku-ku,\nstate=Yokohama,\ncountry=Japan\n\\affiliation\n[2]organization=Department of System Design Engineering, Keio University,\naddressline=3-14-1 Hiyoshi,\ncity=Kohoku-ku,\nstate=Yokohama,\ncountry=Japan\n{graphicalabstract}\n{highlights}\nA novel pure pursuit variant that fundamentally reformulates command velocity computation by explicitly incorporating velocity and acceleration constraints.\nThe core concept of DWPP is to formulate command velocity computation in the velocity space (\nv\nv\nâ€“\nÏ‰\n\\omega\nplane) and to select the command velocity as the point within the dynamic window closest to the line\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\n.\nThe performance of DWPP is evaluated through real-robot experiments compared with conventional approaches, demonstrating compliance with velocity and acceleration constraints as well as reduced path-tracking error.\nThe proposed method is integrated into the official Nav2 repository and is publicly available:\nhttps://github.com/ros-navigation/navigation2\n.\n1\nIntroduction\nRecently, the demand for automated guided vehicles (AGVs) in environments such as factories and hospitals has been increasing\n[\n2\n]\n. Navigation for these robots typically starts with a global planner, which computes a path on a map to reach the goal. Subsequently, a local planner generates local paths and computes command velocities to track the global path while accounting for the robotâ€™s current state and real-time sensor data.\nRepresentative local planners include the dynamic window approach (DWA)\n[\n5\n]\n, model predictive control (MPC)\n[\n14\n]\n, and pure pursuit (PP)\n[\n4\n]\n. Among these planners, DWA and MPC address multi-objective problems such as simultaneous path tracking and obstacle avoidance, whereas PP focuses on a single objective, namely path tracking. Nevertheless, PP remains widely used owing to its simplicity and computational efficiency, and numerous improvements have continued to be proposed\n[\n1\n,\n7\n,\n10\n,\n6\n]\n.\nOne of these improved methods, regulated pure pursuit (RPP)\n[\n10\n]\n, is the standard implementation in Nav2\n[\n9\n]\n, an autonomous navigation framework for the open-source robotics middleware Robot Operating SystemÂ 2 (ROSÂ 2)\n[\n11\n]\n. However, a common limitation of existing PPâ€“based methods, including RPP, is that they cannot explicitly account for a robotâ€™s velocity and acceleration constraints during command velocity computation. Consequently, in conventional PP variants, either an additional layer is introduced to clip the command velocity according to velocity and acceleration limits or the raw command is sent directly to the robot and the realized velocity is clipped by the robotâ€™s hardware constraints. In such cases, a discrepancy occurs between the motion planned by PP and the actual motion executed by the robot, which not only complicates the discussion of controller stability but also can result in overshoot from the reference path owing to the inability to fully realize the planned velocity.\nTo address these problems, this paper proposes dynamic window pure pursuit (DWPP), which fundamentally reformulates command velocity computation by explicitly embedding velocity and acceleration constraints.\nThe core concept of DWPP is to formulate command velocity computation in the velocity space, namely the\nv\nv\nâ€“\nÏ‰\n\\omega\nplane, where\nv\nv\nand\nÏ‰\n\\omega\ndenote the linear and angular velocities, respectively.\nSpecifically, DWPP selects the command velocity as the point within the dynamic windowâ€”representing velocity and acceleration constraints in the\nv\nv\nâ€“\nÏ‰\n\\omega\nplaneâ€”that is closest to the line\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\n, which corresponds to the velocity condition derived from PP.\nThis strategy enables the computation of velocity commands that achieve the highest possible path tracking accuracy under velocity and acceleration constraints.\nRobot experiments demonstrated that DWPP consistently respects velocity and acceleration limits while achieving superior path-following performance compared with existing PP variants implemented in Nav2.\nFurthermore, as a practical contribution, the DWPP implementation has been integrated into the Nav2 framework and is publicly available.\n1\n1\n1\nhttps://github.com/ros-navigation/navigation2\nThe remainder of this paper is organized as follows. Section\n2\nreviews conventional PP variants and summarizes their processing flow and limitations. Section 3 describes the proposed DWPP methodology in detail. Section 4 presents experimental results evaluating the performance of DWPP in comparison with existing methods. Section 5 provides a discussion, and Section 6 concludes the paper and outlines directions for future work.\n2\nRelated work\nFigure\n1\nillustrates the processing flow of major existing PP methods and the proposed DWPP. This section explains the conventional PP methods and their limitations.\nFigure 1\n:\nProcessing flow of conventional pure pursuit methods and the proposed method.\n2.1\nPure Pursuit (PP)\nConsider a path\nP\n=\n{\nğ’‘\n0\n,\nğ’‘\n1\n,\nâ€¦\n,\nğ’‘\nn\n}\nP=\\{\\boldsymbol{p}_{0},\\boldsymbol{p}_{1},\\ldots,\\boldsymbol{p}_{n}\\}\n, where each waypoint\nğ’‘\ni\n=\n(\nx\ni\n,\ny\ni\n)\nâˆˆ\nâ„\n2\n\\boldsymbol{p}_{i}=(x_{i},y_{i})\\in\\mathbb{R}^{2}\nis defined in the map coordinate system. Let\nğ±\nt\n=\n[\nx\nt\n,\ny\nt\n,\nÎ¸\nt\n,\nv\nt\n,\nÏ‰\nt\n]\nâŠ¤\n\\mathbf{x}_{t}=[x_{t},y_{t},\\theta_{t},v_{t},\\omega_{t}]^{\\top}\ndenote the robotâ€™s state at time\nt\nt\n, consisting of its position\n(\nx\nt\n,\ny\nt\n)\n(x_{t},y_{t})\n, orientation\nÎ¸\nt\n\\theta_{t}\n, and current linear and angular velocities\n(\nv\nt\n,\nÏ‰\nt\n)\n(v_{t},\\omega_{t})\n. The PP algorithm is defined as a function\nf\nf\nthat computes the command linear velocity\nv\ncmd\nv_{\\mathrm{cmd}}\nand angular velocity\nÏ‰\ncmd\n\\omega_{\\mathrm{cmd}}\nto track the path\nP\nP\n:\n(\nv\ncmd\n,\nÏ‰\ncmd\n)\n=\nf\nâ€‹\n(\nP\n,\nğ±\nt\n)\n(v_{\\mathrm{cmd}},\\omega_{\\mathrm{cmd}})=f(P,\\mathbf{x}_{t})\n(1)\nFirst, the algorithm computes the lookahead point\nğ’‘\nL\n\\boldsymbol{p}_{L}\non the path, which\nserves as the reference position for path tracking.\nFigure\n2\nshows the geometric relationship among the robotâ€™s position, path,\nand lookahead point\nğ’‘\nL\n\\boldsymbol{p}_{L}\n.\nLet\nL\nL\nbe the lookahead distance.\nLet\nğ’‘\nr\n=\n(\nx\nr\n,\ny\nr\n)\nâˆˆ\nP\n\\boldsymbol{p}_{r}=(x_{r},y_{r})\\in P\ndenote the point on the path nearest to the current robot\nposition.\nThen,\nğ’‘\nL\n\\boldsymbol{p}_{L}\nis determined as follows:\ndist\nâ€‹\n(\nğ’‘\ni\n)\n=\n(\nx\nr\nâˆ’\nx\ni\n)\n2\n+\n(\ny\nr\nâˆ’\ny\ni\n)\n2\n\\mathrm{dist}(\\boldsymbol{p}_{i})=\\sqrt{(x_{r}-x_{i})^{2}+(y_{r}-y_{i})^{2}}\n(2)\nğ’‘\nL\n=\nğ’‘\ni\nâˆˆ\nP\n,\n{\ndist\nâ€‹\n(\nğ’‘\ni\nâˆ’\n1\n)\n<\nL\ndist\nâ€‹\n(\nğ’‘\ni\n)\nâ‰¥\nL\n\\boldsymbol{p}_{L}=\\boldsymbol{p}_{i}\\in P,\\begin{cases}\\mathrm{dist}(\\boldsymbol{p}_{i-1})<L\\\\\n\\mathrm{dist}(\\boldsymbol{p}_{i})\\geq L\\end{cases}\n(3)\nNext, the curvature\nÎº\n\\kappa\nof the arc that connects the current heading\ndirection to the lookahead point is computed.\nLet\nÏ†\n\\varphi\nbe the heading angle from the robotâ€™s forward direction to\nğ’‘\nL\n\\boldsymbol{p}_{L}\n.\nLet\nl\nl\nbe the distance between the robotâ€™s position and\nğ’‘\nL\n\\boldsymbol{p}_{L}\n.\nFrom the geometric relationships shown in Fig.\n2\n, the radius\nR\nR\nof the circular\npath from the robot to\nğ’‘\nL\n\\boldsymbol{p}_{L}\ncan be computed by\nR\n=\nl\n2\nâ€‹\nsin\nâ¡\nÏ†\nR=\\frac{l}{2\\sin\\varphi}\n(4)\nHence, the curvature\nÎº\n\\kappa\ncan be derived by\nÎº\n=\n1\nR\n=\n2\nâ€‹\nsin\nâ¡\nÏ†\nl\n\\kappa=\\frac{1}{R}=\\frac{2\\sin\\varphi}{l}\n(5)\nFigure 2\n:\nGeometric relationships between robot position, path, and lookahead position.\nNext, the command linear velocity\nv\ncmd\nv_{\\mathrm{cmd}}\nis determined.\nIn conventional PP formulations,\nv\ncmd\nv_{\\mathrm{cmd}}\nis typically set to a constant value, namely, the robotâ€™s maximum linear velocity\nv\nmax\nv_{\\max}\n, as follows\n[\n13\n]\n:\nv\ncmd\n=\nv\nmax\n.\nv_{\\mathrm{cmd}}=v_{\\max}.\n(6)\nFinally, the command angular velocity\nÏ‰\ncmd\n\\omega_{\\mathrm{cmd}}\nis computed as follows.\nIf the robot moves along a path of curvature\nÎº\n\\kappa\nat\nv\ncmd\nv_{\\mathrm{cmd}}\n, then\nÏ‰\ncmd\n=\nÎº\nâ€‹\nv\ncmd\n\\omega_{\\mathrm{cmd}}=\\kappa\\,v_{\\mathrm{cmd}}\n(7)\nPP has the following three limitations:\n1.\nDifficulty in tuning the lookahead distance\nL\nL\n:\nEven if\nL\nL\nis tuned carefully, excessively sharp curves may result in overshooting behavior\n[\n4\n]\n. A short\nL\nL\nenables the robot to easily converge to the path but can introduce oscillations around the path center. A large\nL\nL\ncan reduce oscillations but slow convergence, resulting in a trade-off.\n2.\nConstant command linear velocity\nv\ncmd\nv_{\\mathrm{cmd}}\n:\nIt does not adapt to the scenario. For example, even if a curve is extremely tight or if an obstacle is too close to the robot, the velocity will not automatically be reduced.\n3.\nVelocity and acceleration constraints are not considered:\nThe command linear velocity is determined without accounting for acceleration constraints, whereas the command angular velocity is computed directly from the path curvature.\nConsequently, command velocities that explicitly satisfy both velocity and acceleration constraints are difficult to generate.\n2.2\nAdaptive Pure Pursuit (APP)\nAdaptive pure pursuit (APP)\n[\n3\n]\naddresses the first limitation.\nIt extends the lookahead distance in proportion to the robotâ€™s linear\nvelocity.\nSpecifically, APP sets the lookahead distance\nL\nL\nas follows\n[\n12\n]\n:\nL\n=\nclamp\nâ€‹\n(\nv\nt\nâ€‹\nl\nt\n,\nL\nmin\n,\nL\nmax\n)\nL=\\mathrm{clamp}\\!\\left(v_{t}l_{t},\\,L_{\\min},\\,L_{\\max}\\right)\n(8)\nwhere\nl\nt\nl_{t}\nis a gain that indicates how many seconds ahead to project the\nvelocity, and\nL\nmin\nL_{\\min}\nand\nL\nmax\nL_{\\max}\nare the minimum and maximum allowable\nlookahead distances, respectively.\nThe function\nclamp\nâ€‹\n(\nvalue\n,\nlow\n,\nhigh\n)\n\\mathrm{clamp}(\\text{value},\\text{low},\\text{high})\nreturns\nvalues in\n[\nlow\n,\nhigh\n]\n[\\text{low},\\text{high}]\n; if the value is below low, it is set to\nlow, and if the value is above high, it is set to high.\nBy adaptively adjusting the lookahead distance based on speed, APP reduces\novershoot and oscillations at high speeds and enhances path convergence at low\nspeeds, resulting in more stable and accurate path tracking.\nHowever, APP still leaves the second and third limitations unresolved.\n2.3\nRegulated Pure Pursuit (RPP)\nThe RPP controller extends the conventional PP method by introducing several heuristics that regulate the command linear velocity according to the path geometry and the surrounding environment. In RPP, the linear velocity is adjusted using three heuristics: curvature, proximity to obstacles, and distance to the goal.\nCurvature Heuristic\nThe curvature heuristic reduces the linear velocity when the robot follows a path with a small curvature radius, thereby mitigating overshoot on sharp turns. The regulated velocity\nv\nreg\ncurv\nv^{\\mathrm{curv}}_{\\mathrm{reg}}\nis defined based on the curvature radius\nR\nR\nof the circular path from the robot to\nğ’‘\nL\n\\boldsymbol{p}_{L}\nas\nv\nreg\ncurv\n=\n{\nv\nif\nâ€‹\nR\n>\nR\nmin\n,\nv\nâ€‹\nR\nR\nmin\nif\nâ€‹\nR\nâ‰¤\nR\nmin\n,\nv^{\\mathrm{curv}}_{\\mathrm{reg}}=\\begin{cases}v&\\text{if }R>R_{\\min},\\\\\nv\\dfrac{R}{R_{\\min}}&\\text{if }R\\leq R_{\\min},\\end{cases}\n(9)\nwhere\nR\nmin\nR_{\\min}\ndenotes the threshold radius below which velocity scaling is applied.\nProximity Heuristic\nThe proximity heuristic decreases the velocity when the robot is close to obstacles to enhance safety. Let\nd\nO\nd_{O}\nbe the minimum distance to surrounding obstacles. The regulated velocity\nv\nreg\nprox\nv^{\\mathrm{prox}}_{\\mathrm{reg}}\nis given by\nv\nreg\nprox\n=\n{\nv\nif\nâ€‹\nd\nO\n>\nd\nprox\n,\nv\nâ€‹\ng\nd\nâ€‹\nd\nO\nd\nprox\nif\nâ€‹\nd\nO\nâ‰¤\nd\nprox\n,\nv^{\\mathrm{prox}}_{\\mathrm{reg}}=\\begin{cases}v&\\text{if }d_{O}>d_{\\mathrm{prox}},\\\\\nvg_{d}\\dfrac{d_{O}}{d_{\\mathrm{prox}}}&\\text{if }d_{O}\\leq d_{\\mathrm{prox}},\\end{cases}\n(10)\nwhere\nd\nprox\nd_{\\mathrm{prox}}\nis the proximity threshold, and\ng\nd\nâˆˆ\n(\n0\n,\n1\n]\ng_{d}\\in(0,1]\nis a gain parameter that controls the aggressiveness of the deceleration.\nGoal Heuristic\nThe goal heuristic gradually reduces the velocity as the robot approaches the goal to ensure a smooth and accurate stop. Let\nd\nG\nd_{G}\ndenote the remaining distance to the goal along the path, and\nd\ngoal\nd_{\\mathrm{goal}}\nbe the distance threshold at which deceleration begins. The regulated velocity is computed as\nv\nreg\ngoal\n=\n{\nv\nif\nâ€‹\nd\nG\n>\nd\ngoal\n,\nv\nâ€‹\nd\nG\nd\ngoal\nif\nâ€‹\nd\nG\nâ‰¤\nd\ngoal\n.\nv^{\\mathrm{goal}}_{\\mathrm{reg}}=\\begin{cases}v&\\text{if }d_{G}>d_{\\mathrm{goal}},\\\\\nv\\dfrac{d_{G}}{d_{\\mathrm{goal}}}&\\text{if }d_{G}\\leq d_{\\mathrm{goal}}.\\end{cases}\n(11)\nIn the Nav2 implementation, the curvature and proximity heuristics are first applied to the command linear velocity\nv\ncmd\nv_{\\mathrm{cmd}}\n. The intermediate regulated velocity is computed as\nv\nreg\ncurv\n,\nprox\n=\nmin\nâ¡\n(\nv\nreg\ncurv\n,\nv\nreg\nprox\n,\nv\nreg\nmin\n)\n,\nv^{\\mathrm{curv,prox}}_{\\mathrm{reg}}=\\min\\left(v^{\\mathrm{curv}}_{\\mathrm{reg}},v^{\\mathrm{prox}}_{\\mathrm{reg}},v^{\\mathrm{min}}_{\\mathrm{reg}}\\right),\n(12)\nwhere\nv\nreg\nmin\nv^{\\mathrm{min}}_{\\mathrm{reg}}\nis a parameter that specifies the minimum allowable regulated velocity.\nSubsequently, the goal heuristic is applied to\nv\nreg\ncurv\n,\nprox\nv^{\\mathrm{curv,prox}}_{\\mathrm{reg}}\n, and the final regulated velocity\nis computed as\nv\nreg\n=\nmin\nâ¡\n(\nv\nreg\ngoal\n,\nv\ngoal\nmin\n)\n,\nv_{\\mathrm{reg}}=\\min\\left(v^{\\mathrm{goal}}_{\\mathrm{reg}},v^{\\mathrm{min}}_{\\mathrm{goal}}\\right),\n(13)\nwhere\nv\ngoal\nmin\nv^{\\mathrm{min}}_{\\mathrm{goal}}\ndenotes the minimum linear velocity\nallowed when approaching the goal.\nIf the final regulated velocity\nv\nreg\nv_{\\mathrm{reg}}\nis smaller than the originally computed command velocity\nv\ncmd\nv_{\\mathrm{cmd}}\n, the command velocity is replaced by\nv\nreg\nv_{\\mathrm{reg}}\n, thereby limiting the translational motion.\nThis regulation strategy effectively reduces overshoot on sharp curves and improves safety in the vicinity of obstacles or people. However, RPP does not explicitly consider velocity and acceleration constraints during the command velocity computation, leaving this limitation unresolved.\n3\nDynamic Window Pure Pursuit (DWPP)\nThe proposed DWPP fundamentally reformulates the command velocity computation process to address the third problem, namely, the lack of explicit consideration of velocity and acceleration constraints in conventional command computation and regulation.\nAs illustrated in Fig.\n1\n, DWPP differs from RPP through the following\nthree processes.\nFirst, the dynamic window, defined as the feasible velocity region for the next\ncontrol step under the robotâ€™s velocity and acceleration constraints, is\ncomputed.\nSecond, this dynamic window is regulated using the regulated linear velocity\nv\nreg\nv_{\\mathrm{reg}}\n.\nThird, from the resulting region, the velocity point closest to the line\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\n(Eq.Â (\n7\n)) is selected as the command velocity.\nThrough these steps, DWPP explicitly accounts for velocity and acceleration\nconstraints when computing the path-tracking command velocity.\nThis section describes the three processes in detail and presents the stability analysis of DWPP.\nThe implementation is publicly available.\n2\n2\n2\nhttps://github.com/ros-navigation/navigation2/blob/main/nav2_regulated_pure_pursuit_controller/include/nav2_regulated_pure_pursuit_controller/dynamic_window_pure_pursuit_functions.hpp\nThe overall procedure corresponds to the implementation in the\ncomputeDynamicWindowVelocities\nfunction.\n3.1\nCompute the dynamic window\nFirst, the maximum and minimum feasible linear and angular velocities at the next calculation step, denoted by\nv\nmax\ndw\n,\nv\nmin\ndw\n,\nÏ‰\nmax\ndw\nv^{\\mathrm{dw}}_{\\max},v^{\\mathrm{dw}}_{\\min},\\omega^{\\mathrm{dw}}_{\\max}\n, and\nÏ‰\nmin\ndw\n\\omega^{\\mathrm{dw}}_{\\min}\nare computed using the following equations:\nv\nmax\ndw\n\\displaystyle v^{\\mathrm{dw}}_{\\max}\n=\nmin\nâ¡\n(\nv\nmax\n,\nv\nt\n+\na\nmax\nacc\nâ€‹\nÎ”\nâ€‹\nt\n)\n\\displaystyle=\\min(v_{\\max},v_{t}+a^{\\mathrm{acc}}_{\\max}\\Delta t)\n(14)\nv\nmin\ndw\n\\displaystyle v^{\\mathrm{dw}}_{\\min}\n=\nmax\nâ¡\n(\nv\nmin\n,\nv\nt\nâˆ’\na\nmax\ndcc\nâ€‹\nÎ”\nâ€‹\nt\n)\n\\displaystyle=\\max(v_{\\min},v_{t}-a^{\\mathrm{dcc}}_{\\max}\\Delta t)\n(15)\nÏ‰\nmax\ndw\n\\displaystyle\\omega^{\\mathrm{dw}}_{\\max}\n=\nmin\nâ¡\n(\nÏ‰\nmax\n,\nÏ‰\nt\n+\nÎ±\nmax\nacc\nâ€‹\nÎ”\nâ€‹\nt\n)\n\\displaystyle=\\min(\\omega_{\\max},\\omega_{t}+\\alpha^{\\mathrm{acc}}_{\\max}\\Delta t)\n(16)\nÏ‰\nmin\ndw\n\\displaystyle\\omega^{\\mathrm{dw}}_{\\min}\n=\nmax\nâ¡\n(\nÏ‰\nmin\n,\nÏ‰\nt\nâˆ’\nÎ±\nmax\ndcc\nâ€‹\nÎ”\nâ€‹\nt\n)\n\\displaystyle=\\max(\\omega_{\\min},\\omega_{t}-\\alpha^{\\mathrm{dcc}}_{\\max}\\Delta t)\n(17)\nwhere\nv\nmax\nv_{\\max}\n,\nv\nmin\nv_{\\min}\n,\nÏ‰\nmax\n\\omega_{\\max}\n, and\nÏ‰\nmin\n\\omega_{\\min}\nrepresent\nthe maximum and minimum linear and angular velocities.\nThe parameters\na\nmax\nacc\na^{\\mathrm{acc}}_{\\max}\nand\nÎ±\nmax\nacc\n\\alpha^{\\mathrm{acc}}_{\\max}\nare\nthe maximum linear and angular accelerations, whereas\na\nmax\ndec\na^{\\mathrm{dec}}_{\\max}\nand\nÎ±\nmax\ndec\n\\alpha^{\\mathrm{dec}}_{\\max}\nare the maximum\nlinear and angular decelerations.\nÎ”\nâ€‹\nt\n\\Delta t\ndenotes the control period.\nThis procedure corresponds to the implementation in the\ncomputeDynamicWindow\nfunction.\n3.2\nApply regulation to the dynamic window\nNext, the values\nv\nmax\ndw\nv^{\\mathrm{dw}}_{\\max}\nand\nv\nmin\ndw\nv^{\\mathrm{dw}}_{\\min}\nare\nconstrained by the regulated command linear velocity\nv\nreg\nv_{\\mathrm{reg}}\ncomputed by RPP.\nSpecifically, because the admissible range of the robotâ€™s linear velocity is\nlimited to\n[\n0\n,\nv\nreg\n]\n[0,\\,v_{\\mathrm{reg}}]\n, the dynamic window is restricted by taking\nthe intersection between the original dynamic window and this velocity range.\nThis procedure corresponds to the implementation in the\napply-\nRegulationToDynamicWindow\nfunction.\n(a)\nProposed DWPP\n(b)\nConventional pure pursuit\nFigure 3\n:\nComparison of command velocity computations in the\nv\nv\nâ€“\nÏ‰\n\\omega\nspace.\n(a) DWPP selects an executable velocity within the dynamic window closest to the line\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\n,\nwhereas (b) conventional PP may select a velocity outside the dynamic window, which is subsequently clipped by constraints.\n3.3\nCompute Optimal Velocity within the Dynamic Window\nThird, the optimal velocity command is selected from the dynamic window to best satisfy the path-following condition defined in Eq.Â (\n7\n).\nFigure\n3(a)\nillustrates an overview of the velocity selection process in the\nv\nv\nâ€“\nÏ‰\n\\omega\nspace.\nNoting that Eq.Â (\n7\n) represents a straight line passing through the origin in the\nv\nv\nâ€“\nÏ‰\n\\omega\nspace, the command velocity is determined by selecting the point within the dynamic window that is closest to the line.\nIf multiple candidate points achieve the same minimum distance to this line, the one with the largest linear velocity is selected to reduce the time required to reach the goal.\nThis strategy yields a velocity command that is both feasible and most closely aligned with the ideal path-following velocity.\nThe specific implementation is conducted as follows.\nNote that the following procedure corresponds to the implementation of the\ncomputeOptimalVelocityWithinDynamicWindow\nfunction.\nFirst, consider the case where\nÎº\n=\n0\n\\kappa=0\n.\nThe linear velocity is set to\nv\nmax\ndw\nv^{\\mathrm{dw}}_{\\max}\n.\nFor the angular velocity, if the line\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\nintersects the dynamic\nwindow, the intersection point is selected, which yields\nÏ‰\n=\n0\n\\omega=0\n.\nIf no intersection exists, either\nÏ‰\nmax\ndw\n\\omega^{\\mathrm{dw}}_{\\max}\nor\nÏ‰\nmin\ndw\n\\omega^{\\mathrm{dw}}_{\\min}\nis selected, whichever is closer to zero.\nNext, consider the case where\nÎº\nâ‰ \n0\n\\kappa\\neq 0\nand the line\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\nintersects the dynamic window.\nThe intersections between the line\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\nand the four extended\nedges of the dynamic window are given by\nğ©\n1\n\\displaystyle\\mathbf{p}_{1}\n=\n(\nv\nmin\n,\nÎº\nâ€‹\nv\nmin\n)\n,\n\\displaystyle=\\left(v_{\\min},\\ \\kappa\\,v_{\\min}\\right),\n(18)\nğ©\n2\n\\displaystyle\\mathbf{p}_{2}\n=\n(\nv\nmax\n,\nÎº\nâ€‹\nv\nmax\n)\n,\n\\displaystyle=\\left(v_{\\max},\\ \\kappa\\,v_{\\max}\\right),\nğ©\n3\n\\displaystyle\\mathbf{p}_{3}\n=\n(\nÏ‰\nmin\nÎº\n,\nÏ‰\nmin\n)\n,\n\\displaystyle=\\left(\\frac{\\omega_{\\min}}{\\kappa},\\ \\omega_{\\min}\\right),\nğ©\n4\n\\displaystyle\\mathbf{p}_{4}\n=\n(\nÏ‰\nmax\nÎº\n,\nÏ‰\nmax\n)\n.\n\\displaystyle=\\left(\\frac{\\omega_{\\max}}{\\kappa},\\ \\omega_{\\max}\\right).\nAmong these points, the one that lies inside the dynamic window and has the\nlargest linear velocity is selected.\nIf none of these intersection points lies inside the dynamic window, then the\nline\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\ndoes not intersect the dynamic window.\nFinally, consider the case where\nÎº\nâ‰ \n0\n\\kappa\\neq 0\nand no intersection exists.\nFrom convex geometry, we know that when a convex set and line do not\nintersect, the point on the convex hull that minimizes the distance to the line\nmust lie at a vertex of the hull or on an edge parallel to the line.\nTherefore, evaluating the four vertices of the dynamic window is sufficient.\nSpecifically, the distances between the line\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\nand the\nfollowing four points are computed, and the point with the shortest distance and\nthe largest linear velocity is selected:\nğœ\n1\n\\displaystyle\\mathbf{c}_{1}\n=\n(\nv\nmin\n,\nÏ‰\nmin\n)\n,\n\\displaystyle=\\left(v_{\\min},\\ \\omega_{\\min}\\right),\n(19)\nğœ\n2\n\\displaystyle\\mathbf{c}_{2}\n=\n(\nv\nmin\n,\nÏ‰\nmax\n)\n,\n\\displaystyle=\\left(v_{\\min},\\ \\omega_{\\max}\\right),\nğœ\n3\n\\displaystyle\\mathbf{c}_{3}\n=\n(\nv\nmax\n,\nÏ‰\nmin\n)\n,\n\\displaystyle=\\left(v_{\\max},\\ \\omega_{\\min}\\right),\nğœ\n4\n\\displaystyle\\mathbf{c}_{4}\n=\n(\nv\nmax\n,\nÏ‰\nmax\n)\n.\n\\displaystyle=\\left(v_{\\max},\\ \\omega_{\\max}\\right).\nThat is, the computational complexity of the DWPP algorithm is\nO\nâ€‹\n(\n1\n)\nO(1)\n, the same as that of conventional PP variants.\nFigure\n3\nillustrates the command velocity computation in the\nv\nv\nâ€“\nÏ‰\n\\omega\nspace.\nAs shown in Fig.\n3(b)\n, RPP first computes a command velocity (green dot) that best follows the path without explicitly considering velocity and acceleration constraints.\nThe actual velocity executed by the robot (blue dot) is then obtained by clipping this command according to the constraints.\nIn contrast, as shown in Fig.\n3(a)\n, DWPP selects a command velocity (red dot) that is closest to\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\nwithin the dynamic window, and this velocity is directly executed.\nIn other words, DWPP computes the command velocity that best follows the path while explicitly respecting velocity and acceleration constraints.\nThis enables DWPP to adjust the command velocity to track the path as accurately as possible; for example, it reduces the linear velocity when tracking a path with large curvature, whereas conventional PP methods tend to increase it, as illustrated in Fig.\n3\n.\n3.4\nStability Analysis\nThe stability of the proposed DWPP can be evaluated by leveraging the stability analysis for the PP algorithm established by Ollero et al.\n[\n13\n]\n. This approach is justified by the fact that the fundamental control structure of DWPP is equivalent to that of the conventional PP framework. Specifically, as illustrated in Fig.\n1\n, DWPP performs local path planning and computes velocity commands to track a local path with a specific curvature\nÎº\n\\kappa\n, which is analogous to traditional PP algorithms.\nHowever, note that the analysis provided by Ollero et al. assumes a constant linear velocity. Therefore, the stability discussion in this section is conducted under the regime where the control period\nÎ”\nâ€‹\nt\n\\Delta t\nis sufficiently small and the velocity and acceleration limits (\nv\nmin\nv_{\\min}\n,\nv\nmax\nv_{\\max}\n,\nÏ‰\nmin\n\\omega_{\\min}\n,\nÏ‰\nmax\n\\omega_{\\max}\n,\na\nmax\nacc\na^{\\mathrm{acc}}_{\\max}\n,\na\nmax\ndcc\na^{\\mathrm{dcc}}_{\\max}\n,\nÎ±\nmax\nacc\n\\alpha^{\\mathrm{acc}}_{\\max}\n,\nÎ±\nmax\ndcc\n\\alpha^{\\mathrm{dcc}}_{\\max}\n) are bounded such that the velocity fluctuation within a single control period can be considered negligible. Under these quasi-static velocity conditions, the convergence properties of DWPP are expected to align with the analytical results established by Ollero et al.\nThe influence of the specific velocity selection strategy employed in DWPP on system stability is examined below.\nOllero et al. introduced a nondimensional lookahead distance defined as\nL\nâ€²\n=\nL\nV\nâ€‹\nT\nL^{\\prime}=\\frac{L}{VT}\n(20)\nwhere\nV\nV\nis the linear velocity, and\nT\nT\nis the steering time constant.\nTheir analysis showed that the nondimensional lookahead distance must exceed a minimum threshold, denoted by\nL\nmin\nâ€²\nL^{\\prime}_{\\min}\n, to guarantee stability.\nAccordingly, the stability condition for the lookahead distance\nL\nL\ncan be expressed as\nL\nâ‰¥\nV\nâ€‹\nT\nâ€‹\nL\nmin\nâ€²\nL\\geq VTL^{\\prime}_{\\min}\n(21)\nThis condition indicates that the minimum lookahead distance required for stability is proportional to the linear velocity\nV\nV\n.\nAs described in Section\n3.3\n, a key characteristic of DWPP is its ability to reduce the command linear velocity when tracking paths with large curvature while explicitly respecting velocity and acceleration constraints.\nIn such scenarios, the required minimum lookahead distance for stability becomes smaller owing to the reduction in\nV\nV\n.\nConsequently, DWPP exhibits an increased stability margin compared with conventional PP, indicating improved stability properties under sharp-curvature conditions.\nFigure 4\n:\nRobot used in the experiment.\nFigure 5\n:\nExperimental environment.\n(a)\nPath A (\nÎ¸\npath\n=\n45\nâ€‹\ndeg\n\\theta_{\\mathrm{path}}=45\\deg\n)\n(b)\nPath B (\nÎ¸\npath\n=\n90\nâ€‹\ndeg\n\\theta_{\\mathrm{path}}=90\\deg\n)\n(c)\nPath C (\nÎ¸\npath\n=\n135\nâ€‹\ndeg\n\\theta_{\\mathrm{path}}=135\\deg\n)\nFigure 6\n:\nReference paths used in the experiment.\n4\nExperiment\n4.1\nPath Tracking Experiment\n4.1.1\nSetting\nA real-robot experiment was conducted to verify the effectiveness of the proposed DWPP.\nFor navigation during the evaluation, the Nav2 framework was employed, and the performance of DWPP implemented in Nav2 was compared with that of PP, APP, and RPP.\nThe robot used in the experiment was a WHILL Model CR, shown in Fig.\n4\n.\nThe robot measured 0.985Â m in length and 0.55Â m in width.\nThe experiments were conducted in an obstacle-free room, as illustrated in the Fig.\n5\n.\nA 2D map for localization was created using the SLAM Toolbox\n[\n8\n]\n, and self-localization was performed using AMCL in Nav2.\nThe changed conditions in this experiment were the global path and local planner.\nThree paths (Paths A, B, and C) were defined as global paths, that is, reference paths, as shown in Fig.\n6\n.\nAll paths shared the same segment length of 3.0 m, whereas the corner angle\nÎ¸\npath\n\\theta_{\\mathrm{path}}\nwas set to\n45\nâˆ˜\n45^{\\circ}\n,\n90\nâˆ˜\n90^{\\circ}\n, and\n135\nâˆ˜\n135^{\\circ}\nfor Paths A, B, and C, respectively.\nTo ensure that the robotâ€™s initial pose at the start of tracking exactly matched the reference path, we generated the reference path for each trial based on the robotâ€™s initial pose.\nAs local planners, four methods were evaluated: PP, APP, RPP, and the proposed DWPP.\nIn the implementation, the\nRegulatedPurePursuitController\nplugin was used in the Nav2\ncontroller_server\n, and the controller type was switched among PP, APP, RPP, and DWPP via parameter settings.\nTo ensure statistical robustness, we conducted five trials for each combination of the four controllers and three paths, resulting in a total of 60 experimental runs.\nThe performance was evaluated using the following four metrics:\n1.\nConstraint violation ratio [%]\n: The percentage of control steps in which the computed command velocities\n(\nv\ncmd\n,\nÏ‰\ncmd\n)\n(v_{\\mathrm{cmd}},\\omega_{\\mathrm{cmd}})\nviolated the prescribed velocity or acceleration constraints.\n2.\nMean path tracking error [m]\n: The average lateral deviation between the actual robot and reference paths, representing the overall tracking accuracy.\n3.\nMaximum path tracking error [m]\n: The peak lateral deviation from the reference path, which characterizes the magnitude of overshoot.\n4.\nTravel time [s]\n: The total duration required for the robot to reach the goal.\nTable 1\n:\nParameters used in the experiment\nParameter\nValue\nv\nmax\n,\nv\nmin\nv_{\\max},v_{\\min}\n0.5, 0.0 [m/s]\na\nmax\nacc\n,\na\nmax\ndcc\na^{\\mathrm{acc}}_{\\max},a^{\\mathrm{dcc}}_{\\max}\n0.5, 0.5 [m/s\n2\n]\nÏ‰\nmax\n,\nÏ‰\nmin\n\\omega_{\\max},\\omega_{\\min}\n1.0,\nâˆ’\n1.0\n-1.0\n[rad/s]\nÎ±\nmax\nacc\n,\nÎ±\nmax\ndcc\n\\alpha^{\\mathrm{acc}}_{\\max},\\alpha^{\\mathrm{dcc}}_{\\max}\n1.0, 1.0 [rad/s\n2\n]\nÎ”\nâ€‹\nt\n\\Delta t\n0.033 [s]\nL\nL\n0.6 [m]\nL\nmin\n,\nL\nmax\nL_{\\min},L_{\\max}\n0.3, 0.7 [m]\nl\nt\nl_{t}\n1.4\nR\nmin\nR_{\\min}\n0.9 [m]\nv\nreg\nmin\nv^{\\mathrm{min}}_{\\mathrm{reg}}\n0.25 [m/s]\nThe parameters used in the experiment are summarized in Table\n1\n. The velocity and acceleration constraints were determined experimentally. The constant lookahead distance\nL\nL\nfor the PP controller was set slightly larger than the stability limit, considering the maximum linear velocity. For the other controllers (APP, RPP, and DWPP), the lookahead distance limits (\nL\nmin\n,\nL\nmax\nL_{\\min},L_{\\max}\n) were configured such that the distance at maximum velocity exceeded the constant value used in PP while maintaining tracking accuracy at lower speeds through a smaller\nL\nmin\nL_{\\min}\n. Parameters specific to RPP (\nR\nmin\nR_{\\min}\n,\nv\nreg\nmin\nv^{\\mathrm{min}}_{\\mathrm{reg}}\n) were set to their default Nav2 values. For simplicity, the proximity heuristic of RPP was disabled as no obstacles were present in the experimental environment. Additionally, the Nav2 parameter\nuse_rotate_to_heading\nwas set to\nfalse\nto prevent the robot from stopping at cusp points and ensure continuous path tracking.\nuse_collision_detection\nwas also set to\nfalse\nto avoid unintended deceleration caused by sensor noise. All other parameters were maintained at their default values provided by the Nav2 framework. Experimental data were recorded at a frequency of 30Â Hz.\nThe software was implemented on Ubuntu 24.04 using ROSÂ 2 Jazzy.\nAll computations were executed on a Minisforum UM890 Pro mini-PC equipped with an AMD RyzenÂ 9Â 8945HS CPU and 96Â GB of RAM.\n4.1.2\nResults\nTable 2\n:\nConstraint violation ratio [%] (Mean\nÂ±\n\\pm\nSD)\nPath\nPP\nAPP\nRPP\nDWPP\nPath A\n3.3\nÂ±\n1.4\n3.3\\pm 1.4\n2.0\nÂ±\n1.1\n2.0\\pm 1.1\n1.4\nÂ±\n0.5\n1.4\\pm 0.5\n0.0\nÂ±\n0.0\n0.0\\pm 0.0\nPath B\n22.4\nÂ±\n2.7\n22.4\\pm 2.7\n13.9\nÂ±\n1.7\n13.9\\pm 1.7\n10.1\nÂ±\n0.8\n10.1\\pm 0.8\n0.0\nÂ±\n0.0\n0.0\\pm 0.0\nPath C\n55.0\nÂ±\n2.8\n55.0\\pm 2.8\n34.6\nÂ±\n0.6\n34.6\\pm 0.6\n32.1\nÂ±\n2.1\n32.1\\pm 2.1\n0.0\nÂ±\n0.0\n0.0\\pm 0.0\nTable 3\n:\nMean cross track error [m] (Mean\nÂ±\n\\pm\nSD)\nPath\nPP\nAPP\nRPP\nDWPP\nPath A\n0.03\nÂ±\n0.01\n0.03\\pm 0.01\n0.03\nÂ±\n0.01\n0.03\\pm 0.01\n0.03\nÂ±\n0.00\n0.03\\pm 0.00\n0.03\nÂ±\n0.01\n0.03\\pm 0.01\nPath B\n0.05\nÂ±\n0.01\n0.05\\pm 0.01\n0.06\nÂ±\n0.01\n0.06\\pm 0.01\n0.04\nÂ±\n0.02\n0.04\\pm 0.02\n0.03\nÂ±\n0.01\n0.03\\pm 0.01\nPath C\n0.20\nÂ±\n0.12\n0.20\\pm 0.12\n0.14\nÂ±\n0.02\n0.14\\pm 0.02\n0.05\nÂ±\n0.03\n0.05\\pm 0.03\n0.03\nÂ±\n0.02\n0.03\\pm 0.02\nTable 4\n:\nMax cross track error [m] (Mean\nÂ±\n\\pm\nSD)\nPath\nPP\nAPP\nRPP\nDWPP\nPath A\n0.11\nÂ±\n0.01\n0.11\\pm 0.01\n0.11\nÂ±\n0.01\n0.11\\pm 0.01\n0.10\nÂ±\n0.00\n0.10\\pm 0.00\n0.10\nÂ±\n0.01\n0.10\\pm 0.01\nPath B\n0.24\nÂ±\n0.01\n0.24\\pm 0.01\n0.19\nÂ±\n0.01\n0.19\\pm 0.01\n0.15\nÂ±\n0.02\n0.15\\pm 0.02\n0.12\nÂ±\n0.01\n0.12\\pm 0.01\nPath C\n0.74\nÂ±\n0.12\n0.74\\pm 0.12\n0.60\nÂ±\n0.02\n0.60\\pm 0.02\n0.23\nÂ±\n0.03\n0.23\\pm 0.03\n0.13\nÂ±\n0.02\n0.13\\pm 0.02\nTable 5\n:\nTravel time [s] (Mean\nÂ±\n\\pm\nSD)\nPath\nPP\nAPP\nRPP\nDWPP\nPath A\n19.6\nÂ±\n0.3\n19.6\\pm 0.3\n19.2\nÂ±\n0.2\n19.2\\pm 0.2\n19.4\nÂ±\n0.3\n19.4\\pm 0.3\n19.4\nÂ±\n0.2\n19.4\\pm 0.2\nPath B\n19.6\nÂ±\n0.1\n19.6\\pm 0.1\n19.2\nÂ±\n0.1\n19.2\\pm 0.1\n21.1\nÂ±\n0.2\n21.1\\pm 0.2\n22.8\nÂ±\n0.9\n22.8\\pm 0.9\nPath C\n24.0\nÂ±\n0.9\n24.0\\pm 0.9\n21.3\nÂ±\n0.1\n21.3\\pm 0.1\n23.8\nÂ±\n0.7\n23.8\\pm 0.7\n26.1\nÂ±\n0.9\n26.1\\pm 0.9\n(a)\nPath comparison\n(b)\nPP\n(c)\nAPP\n(d)\nRPP\n(e)\nDWPP (Proposed)\nFigure 7\n:\nExperimental results in Path A: (a) Path comparison, and (b)â€“(e) velocity profiles of each controller.\n(a)\nPath comparison\n(b)\nPP\n(c)\nAPP\n(d)\nRPP\n(e)\nDWPP (Proposed)\nFigure 8\n:\nExperimental results in Path B: (a) Path comparison, and (b)â€“(e) velocity profiles of each controller.\n(a)\nPath comparison\n(b)\nPP\n(c)\nAPP\n(d)\nRPP\n(e)\nDWPP (Proposed)\nFigure 9\n:\nExperimental results in Path C: (a) Path comparison, and (b)â€“(e) velocity profiles of each controller.\nTables\n5\nâ€“\n5\nsummarize the quantitative results for each method; the reported values represent the means and standard deviations computed over five runs. Specifically, Table\n5\nlists the percentage of velocity and acceleration constraint violations, whereas Tables\n5\nand\n5\npresent the means and maximum cross-track errors, respectively. The travel times required to reach the goal are listed in Table\n5\n. Furthermore, Figs.\n7\nâ€“\n9\nillustrate the path tracking performance and velocity profiles obtained with each controller. The paths are plotted for all trials, whereas the velocity profiles show a representative trial for each controller.\nThe experimental behavior is demonstrated in the supplementary video.\n3\n3\n3\nhttps://youtu.be/H6r3x1AhsjM\nAs shown in Table\n5\n, conventional methods resulted in non-zero velocity and acceleration constraint violations; in contrast, DWPP produced no constraint violations for any path.\nTables\n5\nand\n5\nindicate that DWPP achieved the smallest mean and maximum errors among all evaluated methods, with the errors decreasing in the order of PP, APP, RPP, and DWPP for all paths. These results indicated that DWPP yielded smaller overall path-tracking errors and reduced overshoot compared with the other methods. In addition, the difference in tracking error between DWPP and the conventional methods became more pronounced as the path corner angle\nÎ¸\npath\n\\theta_{\\mathrm{path}}\nincreased.\nTable\n5\nshows that DWPP required a longer travel time than the conventional methods for all paths.\nFigures\n7(a)\nâ€“\n9(a)\nshow that the differences among controllers became more pronounced as the path corner angle\nÎ¸\npath\n\\theta_{\\mathrm{path}}\nincreased, and the path tracking error decreased accordingly. In particular, for PathÂ C with\nÎ¸\npath\n=\n135\nâˆ˜\n\\theta_{\\mathrm{path}}=135^{\\circ}\n, DWPP exhibited the smallest overshoot, as shown in Fig.\n9(a)\n. These observations were consistent with the quantitative results reported in Tables\n5\nand\n5\n.\nFigures\n7(b)\nâ€“\n9(e)\nshow that PP, APP, and RPP generated velocity commands that were not always feasible, resulting in discrepancies between the commanded and executed velocities. In contrast, DWPP produced feasible velocity commands, and the commanded and executed velocities closely matched. This observation was consistent with the results shown in Table\n5\n.\nIn addition, the velocity commands of PP and APP remained constant at the maximum velocity, whereas RPP and DWPP reduced the velocity at corners. Among these methods, DWPP exhibited a greater decrease in velocity. This behavior corresponded to the longer travel times observed for DWPP in Table\n5\n. We hypothesized that this increase in travel time could be mitigated by using a longer lookahead distance, as a longer lookahead distance leads to a smaller curvature of the circular arc toward the lookahead point and thus makes velocity reduction less likely. However, using a longer lookahead distance is also expected to degrade the path-tracking accuracy. Therefore, the next subsection describes the effect of the lookahead distance on the path-tracking error and travel time of DWPP.\n4.2\nEffect of Lookahead Distance\n4.2.1\nSetting\nTo investigate the effect of the lookahead distance on the path-tracking error and the travel time in DWPP, we conducted a set of simulations. The simulations were performed using Gazebo with a TurtleBot3 Waffle Pi, and navigation was executed using DWPP on Nav2. The global path was set to Path C (Fig.\n6(c)\n) because this path exhibited the largest variation in performance among the controller settings. The simulations were conducted in an obstacle-free environment. The robot trajectory was recorded using the ground-truth pose provided by Gazebo to eliminate the influence of localization errors.\nTable 6\n:\nParameters used in the simulation\nParameter\nValue\nv\nmax\n,\nv\nmin\nv_{\\max},v_{\\min}\n0.26, 0.0 [m/s]\na\nmax\nacc\n,\na\nmax\ndcc\na^{\\mathrm{acc}}_{\\max},a^{\\mathrm{dcc}}_{\\max}\n0.26, 0.26 [m/s\n2\n]\nÏ‰\nmax\n,\nÏ‰\nmin\n\\omega_{\\max},\\omega_{\\min}\n0.50,\nâˆ’\n0.50\n-0.50\n[rad/s]\nÎ±\nmax\nacc\n,\nÎ±\nmax\ndcc\n\\alpha^{\\mathrm{acc}}_{\\max},\\alpha^{\\mathrm{dcc}}_{\\max}\n0.50,\nâˆ’\n0.50\n-0.50\n[rad/s\n2\n]\nÎ”\nâ€‹\nt\n\\Delta t\n0.033 [s]\nThe parameters used in the simulation are summarized in Table\n6\n. The velocity and acceleration constraints were determined according to the robot specifications. In this simulation, the functions of APP and RPP were disabled by setting the Nav2 parameters\nuse_velocity_scaled_lookahead_\ndist\n,\nuse_regulated_linear_velocity_scaling\n, and\nuse_cost_\nregulated_linear_velocity_scaling\nto\nfalse\nto isolate and evaluate only the effect of DWPP. All other parameters were set to the same values as those used in the experiment described in Section\n4.1.1\n.\nThe only condition varied in this simulation was the lookahead distance. The lookahead distance was set to 0.26, 0.39, 0.52, 0.65, 0.78, 0.91, and 1.04Â m. These values corresponded to 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, and 4.0 times the maximum linear velocity, respectively.\nThe simulations were conducted on Ubuntu 24.04 with ROSÂ 2 Rolling. The computational experiments were executed on a workstation equipped with an Intel(R) Core(TM) i9-12900K CPU (3.19Â GHz), 64Â GB of RAM, and an NVIDIA GeForce RTX 3090 GPU (24Â GB VRAM). Experimental data were recorded at a frequency of 30Â Hz. For reproducibility, the Docker environment used for these simulations is publicly available\n4\n4\n4\nhttps://github.com/Decwest/dwpp_test_environment/tree/feature/nav2_integration\n.\n4.2.2\nResults\nFigures\n10\nand\n11\ndepict the simulation results. Figure\n10\nillustrates the trade-off between the mean tracking error and travel time for different lookahead distances, whereas Fig.\n11\nshows the tracked paths and actual linear velocity profiles for each lookahead distance. The simulation behavior is also demonstrated in the supplementary video.\n5\n5\n5\nhttps://youtu.be/sK0IsN1SC6g\nAs shown in Fig.\n10\n, a clear trade-off existed between the lookahead distance, mean tracking error, and travel time. When the lookahead distance was small, the mean tracking error decreased, whereas the travel time increased. Conversely, as the lookahead distance increased, the mean tracking error increased, whereas the travel time decreased.\nFigure\n11(a)\nshows that a larger lookahead distance led to more pronounced corner cutting and overshoot at turns, which was consistent with the increase in the mean tracking error. Furthermore, Fig.\n11(b)\nindicates that, with a larger lookahead distance, the robot did not sufficiently decelerate at corners. This behavior contributed to the decrease in the travel time.\nThese results indicated that, in DWPP, the lookahead distance introduces a trade-off between path-tracking accuracy and traversal efficiency. Therefore, when using DWPP, the lookahead distance should be appropriately tuned by considering this trade-off to achieve better overall navigation performance.\nFigure 10\n:\nPerformance trade-off between mean tracking error and travel time for different lookahead distances.\n(a)\nTracked paths.\n(b)\nActual linear velocity profiles.\nFigure 11\n:\nDetailed behavior analysis for each lookahead distance\nL\nL\n.\n5\nDiscussion\n5.1\nWhy DWPP Outperforms RPP\n(a)\nCommand velocity profile of RPP and DWPP during tracking Path C\nt\n=\n7.033\nt=7.033\nt\n=\n7.067\nt=7.067\nt\n=\n7.100\nt=7.100\nt\n=\n7.133\nt=7.133\nt\n=\n7.166\nt=7.166\n(b)\nTransition of the dynamic window in RPP.\nt\n=\n7.033\nt=7.033\nt\n=\n7.067\nt=7.067\nt\n=\n7.100\nt=7.100\nt\n=\n7.133\nt=7.133\nt\n=\n7.166\nt=7.166\n(c)\nTransition of the dynamic window in the proposed DWPP.\nFigure 12\n:\nAnalysis of command velocity computation. (a) Command velocity profile; (b) and (c) dynamic window transitions at the specific time frames indicated above each plot.\nFigure\n12(a)\nshows the velocity command profiles of DWPP and RPP during the first corner of Path C (\nt\n=\n5.0\nt=5.0\ns to\nt\n=\n8.0\nt=8.0\ns), where a performance gap between the two methods becomes evident. To further analyze the underlying cause, Figs.\n12(b)\nand\n12(c)\nillustrate the transitions of velocity command calculation in the\nv\nv\n-\nÏ‰\n\\omega\nspace for the interval from\nt\n=\n7.033\nt=7.033\ns to\nt\n=\n7.166\nt=7.166\ns. During this period, DWPP underwent deceleration, whereas RPP maintained a constant linear velocity.\nThese results provide the following insights. In RPP, the linear velocity is fixed at\nv\nreg\nmin\nv^{\\min}_{\\mathrm{reg}}\n, and the angular velocity is determined based on Eq. (\n7\n) without considering velocity and acceleration constraints. Consequently, the velocity commands are clipped by these constraints during execution. Consequently, although the left vertex of the dynamic window is the optimal feasible point for path tracking, the actual realized velocity corresponds to the right vertex.\nIn contrast, DWPP selects the point within the dynamic window that is closest to the line defined by Eq. (\n7\n) (i.e.,\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\n). This approach ensures that the calculated velocity commands are directly executable without being saturated. Moreover, DWPP effectively manages deceleration from\nt\n=\n7.033\nt=7.033\nto\n7.100\n7.100\nto maintain tracking and accelerates from\nt\n=\n7.133\nt=7.133\nto\n7.166\n7.166\n. This demonstrates that DWPP can calculate velocity commands that maximize path-tracking performance while strictly adhering to velocity and acceleration constraints. These observations confirm that by explicitly incorporating these constraints into the calculation phase, DWPP achieves a more ideal and superior path-tracking performance compared with RPP.\n5.2\nKey Advantages of DWPP over Conventional Pure Pursuit Variants\nThe primary advantages of DWPP are summarized into the following three points:\n1.\nDirect compliance with velocity and acceleration constraints:\nDWPP generates velocity commands that inherently satisfy velocity and acceleration constraints. This eliminates the need for external clipping mechanisms or post-processing layers, such as the\nvelocity_smoother\nin Nav2, which were previously required to ensure feasibility before command execution.\n2.\nOptimal tracking within velocity and acceleration constraints:\nBy incorporating velocity and acceleration constraints directly into the command velocity calculation phase, DWPP can determine the optimal velocity commands to maximize path-tracking performanceâ€”for instance, by automatically decelerating at sharp corners. Consequently, DWPP can track challenging paths with discontinuous or high curvature (e.g., Path C) with significantly reduced overshoot compared with conventional methods.\n3.\nParameter-free optimal deceleration:\nDWPP achieves optimal deceleration by fully leveraging the constraints without the need for manual parameter tuning. While RPP can also decelerate at high-curvature sections using its curvature heuristic, it requires the manual design of parameters such as\nR\nmin\nR_{\\min}\nand\nv\nreg\nmin\nv^{\\mathrm{min}}_{\\mathrm{reg}}\n. In contrast, DWPP automatically calculates the best possible deceleration based solely on the provided velocity and acceleration limits. Furthermore, DWPP remains compatible with manually designed heuristics, enabling it to inherit their benefits if additional specific tuning is desired.\n5.3\nKey Advantages of DWPP over Dynamic Window Approach\nDWA\n[\n5\n]\nis another prominent local planner that utilizes the dynamic window. In this section, we discuss the comparative advantages of DWPP over DWA, specifically when DWA is employed solely for the purpose of path tracking. These advantages are primarily categorized into the following two aspects:\n1.\nAnalytical optimality in a continuous solution space:\nIn DWA, candidate velocity commands are obtained through discrete sampling within the dynamic window. This results in a set of discrete solutions, which may result in velocity commands that slightly deviate from the true optimum. In contrast, DWPP analytically computes the command velocity within a continuous solution space by directly exploiting the geometric relationship between the line\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\nand the dynamic window in the\nv\nv\n-\nÏ‰\n\\omega\nspace. This ensures that the optimal velocity command is always obtained within the feasible constraints.\n2.\nComputational efficiency:\nThe computational complexity of DWA is typically\nO\nâ€‹\n(\nN\nâ€‹\nM\n)\nO(NM)\n, where\nN\nN\ndenotes the number of velocity samples and\nM\nM\nrepresents the number of simulated time steps in the prediction horizon. On the other hand, as described in Section\n3.3\n, the computational cost of DWPP is\nO\nâ€‹\n(\n1\n)\nO(1)\nbecause it derives the velocity commands through a closed-form analytical solution.\nConsequently, when the primary objective of the local planner is pure path tracking without obstacle avoidance, DWPP can calculate more optimal velocity commands with significantly lower computational overhead compared with DWA.\n6\nConclusion\nThis paper presents dynamic window pure pursuit (DWPP), a novel pure pursuit method designed to explicitly incorporate velocity and acceleration constraints into the velocity command computation process. By selecting the optimal point within the dynamic window closest to the line\nÏ‰\n=\nÎº\nâ€‹\nv\n\\omega=\\kappa v\n, the proposed method analytically derives commands that maximize path-tracking performance while ensuring strict adherence to these constraints. Real-robot experiments integrated with the Nav2 framework demonstrated that DWPP outperforms conventional pure pursuit variants. Specifically, the method ensures that generated commands remain within specified velocity and acceleration limits, resulting in a reduction in path-tracking errors compared with traditional approaches. The DWPP implementation has been integrated into the Nav2 framework and is publicly available\n6\n6\n6\nhttps://github.com/ros-navigation/navigation2\n, enabling engineers to readily evaluate and adopt the proposed method.\nFuture research will focus on the autonomous determination of the lookahead distance to eliminate the need for manual parameter tuning and to further enhance navigation performance.\nAcknowledgment\nThe authors would like to express their sincere gratitude to Steve Macenski and Maurice Alexander Purnawan (Open Navigation LLC) for their thorough and insightful code reviews during the integration of this work into the Nav2 framework.\nDeclaration of competing interest\nThe authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.\nReferences\n[1]\nJ. Ahn, S. Shin, M. Kim, and J. Park\n(2021)\nAccurate path tracking by adjusting look-ahead point in pure pursuit method\n.\nInternational journal of automotive technology\n22\n(\n1\n),\npp.Â 119â€“129\n.\nCited by:\nÂ§1\n.\n[2]\nM. Aizat, A. Azmin, and W. Rahiman\n(2023)\nA survey on navigation approaches for automated guided vehicle robots in dynamic surrounding\n.\nIEEE Access\n11\n(\n),\npp.Â 33934â€“33955\n.\nCited by:\nÂ§1\n.\n[3]\nS. F. Campbell\n(2007)\nSteering control of an autonomous ground vehicle with application to the darpa urban challenge\n.\nPh.D. Thesis\n,\nMassachusetts Institute of Technology\n.\nCited by:\nÂ§2.2\n.\n[4]\nR. C. Coulter\n(1992)\nImplementation of the pure pursuit path tracking algorithm\n.\nTechnical report\nCited by:\nÂ§1\n,\nitemÂ 1\n.\n[5]\nD. Fox, W. Burgard, and S. Thrun\n(2002)\nThe dynamic window approach to collision avoidance\n.\nIEEE robotics & automation magazine\n4\n(\n1\n),\npp.Â 23â€“33\n.\nCited by:\nÂ§1\n,\nÂ§5.3\n.\n[6]\nZ. Han, P. Chen, B. Zhou, and G. Yu\n(2025)\nHybrid path tracking control for autonomous trucks: integrating pure pursuit and deep reinforcement learning with adaptive look-ahead mechanism\n.\nIEEE Transactions on Intelligent Transportation Systems\n.\nCited by:\nÂ§1\n.\n[7]\nB. Li, Y. Wang, S. Ma, X. Bian, H. Li, T. Zhang, X. Li, and Y. Zhang\n(2023)\nAdaptive pure pursuit: a real-time path planner using tracking controllers to plan safe and kinematically feasible paths\n.\nIEEE Transactions on Intelligent Vehicles\n8\n(\n9\n),\npp.Â 4155â€“4168\n.\nCited by:\nÂ§1\n.\n[8]\nS. Macenski and I. Jambrecic\n(2021)\nSLAM toolbox: slam for the dynamic world\n.\nJournal of Open Source Software\n6\n(\n61\n),\npp.Â 2783\n.\nCited by:\nÂ§4.1.1\n.\n[9]\nS. Macenski, F. MartÃ­n, R. White, and J. G. Clavero\n(2020)\nThe marathon 2: a navigation system\n.\nIn\n2020 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)\n,\npp.Â 2718â€“2725\n.\nCited by:\nÂ§1\n.\n[10]\nS. Macenski, S. Singh, F. MartÃ­n, and J. GinÃ©s\n(2023)\nRegulated pure pursuit for robot path tracking\n.\nAutonomous Robots\n47\n(\n6\n),\npp.Â 685â€“694\n.\nCited by:\nÂ§1\n,\nÂ§1\n.\n[11]\nS. Macenski, T. Foote, B. Gerkey, C. Lalancette, and W. Woodall\n(2022)\nRobot operating system 2: design, architecture, and uses in the wild\n.\nScience robotics\n7\n(\n66\n),\npp.Â eabm6074\n.\nCited by:\nÂ§1\n.\n[12]\nH. Ohta, N. Akai, E. Takeuchi, S. Kato, and M. Edahiro\n(2016)\nPure pursuit revisited: field testing of autonomous vehicles in urban areas\n.\nIn\n2016 IEEE 4th International Conference on Cyber-Physical Systems, Networks, and Applications (CPSNA)\n,\npp.Â 7â€“12\n.\nCited by:\nÂ§2.2\n.\n[13]\nA. Ollero and G. Heredia\n(1995)\nStability analysis of mobile robot path tracking\n.\nIn\nProceedings 1995 IEEE/RSJ International Conference on Intelligent Robots and Systems. Human Robot Interaction and Cooperative Robots\n,\nVol.\n3\n,\npp.Â 461â€“466 vol.3\n.\nCited by:\nÂ§2.1\n,\nÂ§3.4\n.\n[14]\nC. RÃ¶smann, F. Hoffmann, and T. Bertram\n(2015)\nTimed-elastic-bands for time-optimal point-to-point nonlinear model predictive control\n.\nIn\n2015 european control conference (ECC)\n,\npp.Â 3352â€“3357\n.\nCited by:\nÂ§1\n.",
    "preview_text": "Pure pursuit and its variants are widely used for mobile robot path tracking owing to their simplicity and computational efficiency. However, many conventional approaches do not explicitly account for velocity and acceleration constraints, resulting in discrepancies between commanded and actual velocities that result in overshoot and degraded tracking performance. To address this problem, this paper proposes dynamic window pure pursuit (DWPP), which fundamentally reformulates the command velocity computation process to explicitly incorporate velocity and acceleration constraints. Specifically, DWPP formulates command velocity computation in the velocity space (the $v$-$Ï‰$ plane) and selects the command velocity as the point within the dynamic window that is closest to the line $Ï‰= Îºv$. Experimental results demonstrate that DWPP avoids constraint-violating commands and achieves superior path-tracking accuracy compared with conventional pure pursuit methods. The proposed method has been integrated into the official Nav2 repository and is publicly available (https://github.com/ros-navigation/navigation2).\n\nDWPP: Dynamic Window Pure Pursuit Considering Velocity and Acceleration Constraints\nFumiya Ohnishi\nfumiya-onishi@keio.jp\nMasaki Takahashi\ntakahashi@sd.keio.ac.jp\nAbstract\nPure pursuit and its variants are widely used for mobile robot path tracking owing to their simplicity and computational efficiency. However, many conventional approaches do not explicitly account for velocity and acceleration constraints, resulting in discrepancies between commanded and actual velocities that result in overshoot and degraded tracking performance. To address this problem, this paper proposes dynamic window pure pursuit (DWPP), which fundamentally reformulates the command velocity computation process to explicitly incorporate velocity and acceleration constraints. Specifically, DWPP formulates command velocity computation in the velocity space (the\nv\nv\nâ€“\nÏ‰\n\\omega\nplane) and selects t",
    "is_relevant": false,
    "relevance_score": 0.0,
    "extracted_keywords": [
        "Pure Pursuit",
        "path tracking",
        "mobile robot",
        "velocity constraints",
        "acceleration constraints",
        "dynamic window"
    ],
    "one_line_summary": "è¿™ç¯‡è®ºæ–‡æå‡ºäº†ä¸€ç§è€ƒè™‘é€Ÿåº¦å’ŒåŠ é€Ÿåº¦çº¦æŸçš„åŠ¨æ€çª—å£çº¯è¿½è¸ªæ–¹æ³•ï¼Œç”¨äºæé«˜ç§»åŠ¨æœºå™¨äººçš„è·¯å¾„è·Ÿè¸ªæ€§èƒ½ã€‚",
    "detailed_summary": "",
    "qa_pairs": [],
    "is_hidden": false,
    "is_starred": false,
    "flag": true,
    "published_date": "2026-01-21T14:05:42Z",
    "created_at": "2026-01-27T15:53:21.407488",
    "updated_at": "2026-01-27T15:53:21.407496",
    "recommend": 0
}