{
    "id": "2601.08514v1",
    "title": "Simplifying ROS2 controllers with a modular architecture for robot-agnostic reference generation",
    "authors": [
        "Davide Risi",
        "Vincenzo Petrone",
        "Antonio Langella",
        "Lorenzo Pagliara",
        "Enrico Ferrentino",
        "Pasquale Chiacchio"
    ],
    "abstract": "æœ¬æ–‡æå‡ºäº†ä¸€ç§æ–°é¢–çš„ROS2æ¨¡å—åŒ–æ¶æ„ï¼Œè¯¥æ¶æ„å°†è·å–ã€éªŒè¯å’Œæ’å€¼å‚è€ƒä¿¡å·æ‰€éœ€çš„é€»è¾‘ä¸è·Ÿè¸ªè¿™äº›å‚è€ƒä¿¡å·çš„æ§åˆ¶å¾‹è§£è€¦ã€‚è¯¥è®¾è®¡åŒ…å«ä¸€ä¸ªåä¸º\"å‚è€ƒç”Ÿæˆå™¨\"çš„ä¸“ç”¨ç»„ä»¶ï¼Œå®ƒæ¥æ”¶æ¥è‡ªå¤–éƒ¨èŠ‚ç‚¹ï¼ˆå¦‚è§„åˆ’å™¨ï¼‰ä»¥å•ç‚¹æˆ–è½¨è¿¹å½¢å¼æä¾›çš„å‚è€ƒä¿¡å·ï¼Œå¹¶é€šè¿‡ç°æœ‰çš„ros2_controlé“¾å¼æœºåˆ¶ï¼Œä»¥æ§åˆ¶å™¨é‡‡æ ·å‘¨æœŸå‘ä¸‹æ¸¸æ§åˆ¶å™¨å†™å…¥å•ç‚¹å‚è€ƒä¿¡å·ã€‚è¿™ç§åˆ†ç¦»æ¶ˆé™¤äº†æ§åˆ¶å™¨ä¸­é‡å¤çš„å‚è€ƒä¿¡å·å¤„ç†ä»£ç ï¼Œæé«˜äº†è·¨æœºå™¨äººå¹³å°çš„å¯é‡ç”¨æ€§ã€‚æˆ‘ä»¬å®ç°äº†ä¸¤ç§å‚è€ƒç”Ÿæˆå™¨ï¼šä¸€ç§ç”¨äºå¤„ç†å…³èŠ‚ç©ºé—´å‚è€ƒä¿¡å·ï¼Œå¦ä¸€ç§ç”¨äºç¬›å¡å°”ç©ºé—´å‚è€ƒä¿¡å·ï¼ŒåŒæ—¶å¼€å‘äº†ä¸€å¥—æ–°æ§åˆ¶å™¨ï¼ˆå¸¦é‡åŠ›è¡¥å¿çš„PDæ§åˆ¶å™¨ã€ç¬›å¡å°”ä½å§¿æ§åˆ¶å™¨å’Œå¯¼çº³æ§åˆ¶å™¨ï¼‰ï¼Œå¹¶åœ¨ä»¿çœŸåŠçœŸå®çš„Universal Robotsä¸Franka Emikaæœºæ¢°è‡‚ä¸ŠéªŒè¯äº†è¯¥æ–¹æ³•ã€‚ç»“æœè¡¨æ˜ï¼šï¼ˆ1ï¼‰åœ¨æ‰€æœ‰æµ‹è¯•åœºæ™¯ä¸­å‚è€ƒä¿¡å·å‡èƒ½è¢«å¯é è·Ÿè¸ªï¼›ï¼ˆ2ï¼‰å‚è€ƒç”Ÿæˆå™¨å‡å°‘äº†é“¾å¼æ§åˆ¶å™¨é—´é‡å¤çš„å‚è€ƒä¿¡å·å¤„ç†ä»£ç ï¼Œæœ‰åˆ©äºå¤æ‚æ§åˆ¶å™¨ç®¡é“çš„æ„å»ºä¸å¤ç”¨ï¼›ï¼ˆ3ï¼‰æ§åˆ¶å™¨å®ç°ä»…éœ€ä¸“æ³¨äºæ§åˆ¶å¾‹æœ¬èº«ã€‚",
    "url": "https://arxiv.org/abs/2601.08514v1",
    "html_url": "https://arxiv.org/html/2601.08514v1",
    "html_content": "Simplifying ROS2 controllers with a modular architecture for robot-agnostic reference generation\nDavide Risi,\nVincenzo Petrone,Â \nAntonio Langella,\nLorenzo Pagliara,Â \nEnrico Ferrentino,Â \nPasquale Chiacchio\nAuthors are with the Department of Information Engineering, Electrical Engineering and Applied Mathematics (DIEM), University of Salerno, 84084 Fisciano, Italy (email: {drisi, vipetrone, alangella, lpagliara, eferrentino, pchiacchio}@unisa.it).\nAbstract\nThis paper introduces a novel modular architecture for ROS2 that decouples the logic required to acquire, validate, and interpolate references from the control laws that track them.\nThe design includes a dedicated component, named\nReference Generator\n, that receives references, in the form of either single points or trajectories, from external nodes (e.g., planners), and writes single-point references at the controllerâ€™s sampling period via the existing\nros2_control\nchaining mechanism to downstream controllers.\nThis separation removes duplicated reference-handling code from controllers and improves reusability across robot platforms.\nWe implement two reference generators: one for handling joint-space references and one for Cartesian references, along with a set of new controllers (PD with gravity compensation, Cartesian pose, and admittance controllers) and validate the approach on simulated and real Universal Robots and Franka Emika manipulators.\nResults show that (i) references are tracked reliably in all tested scenarios, (ii) reference generators reduce duplicated reference-handling code across chained controllers to favor the construction and reuse of complex controller pipelines, and (iii) controller implementations remain focused only on control laws.\nâ€ \nâ€ \npublicationid:\npubid: 0000â€“0000/00$00.00Â Â©Â 2021 IEEE\nI\nIntroduction\nMotivated by the ROS2 central goal of supporting an ecosystem where researchers and industries can rapidly set up robotic systems by reusing and composing open-source community-developed components\n[\n1\n]\n, the\nros2_control\nframework is built on a set of design principles (such as hardware-interface abstraction and modular design) that aim to make controllers reusable across robots and applications\n[\n2\n,\n3\n]\n.\nNotably, the controller chaining mechanism has been introduced to enable users to build complex behaviors from reusable components\n[\n4\n]\n.\nThanks to its modular design, the framework enables inter-operability of control modules developed by different actors and greatly simplifies the development of new controllers by moving resource and controller lifecycle management out of them.\nWhile this design successfully decouples controllers from hardware, it is less successful in decoupling control logic from input processing.\nIn contrast to the Single Responsibility Principle\n[\n5\n]\n, standard controllers like the\nAdmittanceController\nand\nJointTrajectoryController\n[\n6\n]\nact as monolithic entities that handle both reference processing and loop closure.\nThis leads to code duplication and undermines reusability, which in turn increases development time and maintenance costs, with a steeper learning curve for new developers.\nPotentially, this could hinder the adoption of\nros2_control\nin educational and research contexts, e.g., when interested practitioners are specialized in control theory, but not in software engineering.\nI-A\nContributions\nTo address the monolithic nature of current controllers, we analyze the common responsibilities that are frequently duplicated across implementations:\nâ€¢\nReference acquisition and validation.\nControllers often accept references via ROS2 topics\n[\n7\n]\nand actions\n[\n8\n]\nand verify that they are dimensionally consistent, numerically valid, and within expected limits.\nâ€¢\nReal-time-safe handling.\nMany controllers receive external references asynchronously but must compute a reference at the controller loop rate.\nThis requires handling the communication between non-real-time and real-time contexts.\nâ€¢\nInterpolation.\nPlanners typically produce waypoints at rates differing from the low-level controller frequency, necessitating internal interpolation logic.\nDecoupling those from control law calculation is possible and would make new controllers easier to implement and more reusable across different applications.\nTo reach this goal, we propose a\nros2_control\nsoftware module called\nReference Generator\nthat encapsulates all of the responsibilities cited above.\nReference generators handle reference acquisition via standard ROS2 communication primitives and produce single-point references at the controllerâ€™s sampling period.\nA key design choice is to exclusively use the controller chaining mechanism as the communication interface between reference generators and downstream controllers\n[\n4\n]\n.\nBy leveraging ROS2 interfaces, this mechanism promotes cross-compatibility among modules developed by different organizations while keeping the design extensible for future needs.\nConsequently, new controllers developed within this framework are agnostic to how references are acquired, making the implementation of the control law their sole responsibility.\nThis design also makes reference generators backward-compatible with any ROS2 controller that supports chaining.\nSpecifically, this paper makes the following contributions:\n1.\nWe design a novel architecture that separates reference processing (acquisition, validation, and interpolation) from the control law algorithm within the\nros2_control\necosystem.\n2.\nWe provide two implementations for\nReference Generator\n: a\nJoint-Space Reference Generator\n(JRG) and a\nTask-Space Reference Generator\n(TRG) for handling joint-space and Cartesian references, respectively.\n3.\nAdditionally, we deliver a set of new controllers, to further demonstrate how our reference generators favor the creation of control chains: (i) PD with gravity compensation, (ii) Cartesian pose\n[\n9\n]\n, and (iii) admittance controllers. The latter is tailored to work with Cartesian references instead of joint-space ones, differently from the original\nAdmittanceController\nproposed in\nros2_controllers\n[\n6\n]\n.\nThe proposed\nReference Generator\nand the new controllers are successfully demonstrated in various pipeline configurations on simulated and real Universal Robots\n[\n10\n]\nUR10 and Franka Emika Robot\n[\n11\n,\n12\n]\n(FER) manipulators.\nI-B\nControl laws\nConsider the robot dynamics\n[\n13\n]\n:\nğ‘©\nâ€‹\n(\nğ’’\n)\nâ€‹\nğ’’\nÂ¨\n+\nğ‘ª\nâ€‹\n(\nğ’’\n,\nğ’’\nË™\n)\nâ€‹\nğ’’\nË™\n+\nğ’‡\nâ€‹\n(\nğ’’\nË™\n)\n+\nğ’ˆ\nâ€‹\n(\nğ’’\n)\n=\nğ‰\n,\n\\bm{B}(\\bm{q})\\,\\ddot{\\bm{q}}+\\bm{C}(\\bm{q},\\dot{\\bm{q}})\\,\\dot{\\bm{q}}+\\bm{f}(\\dot{\\bm{q}})+\\bm{g}(\\bm{q})=\\bm{\\tau},\n(1)\nwhere\nğ‘©\n\\bm{B}\nis the inertia matrix,\nğ‘ª\n\\bm{C}\ncollects Coriolis and centrifugal terms,\nğ’‡\n\\bm{f}\nmodels friction,\nğ’ˆ\n\\bm{g}\nthe gravitational effects, and\nğ‰\n\\bm{\\tau}\nare the actuation torques.\nVectors\nğ’’\n,\nğ’’\nË™\n,\nğ’’\nÂ¨\n\\bm{q},\\dot{\\bm{q}},\\ddot{\\bm{q}}\ndenote joint positions, velocities, and accelerations.\nThe end-effector pose, twist and accelerations are denoted with\nğ’™\n,\nğ’—\n,\nğ’—\nË™\n\\bm{x},\\bm{v},\\dot{\\bm{v}}\n, respectively.\nHere we recall the control laws used in the pipelines of Section\nIII\n.\nâ€¢\nPD control with gravity compensation (PDGC):\nğ‰\n=\nğ‘²\nP\nâ€‹\n(\nğ’’\nd\nâˆ’\nğ’’\n)\nâˆ’\nğ‘²\nD\nâ€‹\nğ’’\nË™\n+\nğ’ˆ\nâ€‹\n(\nğ’’\n)\n,\n\\bm{\\tau}=\\bm{K}_{P}(\\bm{q}_{d}-\\bm{q})-\\bm{K}_{D}\\,\\dot{\\bm{q}}+\\bm{g}(\\bm{q}),\n(2)\nwhere\nğ‘²\nP\n,\nğ‘²\nD\nâ‰»\n0\n\\bm{K}_{P},\\bm{K}_{D}\\succ 0\nare symmetric positive-definite gain matrices, and\nğ’’\nd\n\\bm{q}_{d}\nis the desired joint position profile\n[\n14\n]\n.\nâ€¢\nPID control:\nğ‰\n=\nğ‘²\nP\nâ€‹\n(\nğ’’\nd\nâˆ’\nğ’’\n)\n+\nğ‘²\nD\nâ€‹\n(\nğ’’\nË™\nd\nâˆ’\nğ’’\nË™\n)\n+\nğ‘²\nI\nâ€‹\nâˆ«\nt\n0\nt\n(\nğ’’\nd\nâˆ’\nğ’’\n)\nâ€‹\nd\nt\n,\n\\bm{\\tau}=\\bm{K}_{P}(\\bm{q}_{d}-\\bm{q})+\\bm{K}_{D}(\\dot{\\bm{q}}_{d}-\\dot{\\bm{q}})+\\bm{K}_{I}\\int_{t_{0}}^{t}(\\bm{q}_{d}-\\bm{q})\\,\\mathrm{d}t,\n(3)\nwith integral gain matrix\nğ‘²\nI\nâ‰»\n0\n\\bm{K}_{I}\\succ 0\nand desired joint velocities\nğ’’\nË™\nd\n\\dot{\\bm{q}}_{d}\n[\n15\n]\n.\nâ€¢\nAdmittance control (AC):\nThe desired relationship between the commanded and measured wrenches is defined in task space as a mass-spring-damper system acting on the task error\nğ’™\n~\n=\nğ’™\nd\nâˆ’\nğ’™\nc\n\\tilde{\\bm{x}}=\\bm{x}_{d}-\\bm{x}_{c}\n, with\nğ’™\nd\n\\bm{x}_{d}\nand\nğ’™\nc\n\\bm{x}_{c}\ndenoting the desired and commanded end-effector poses, respectively:\nğ‘´\nd\nâ€‹\nğ’™\n~\nÂ¨\n+\nğ‘²\nD\nâ€‹\nğ’™\n~\nË™\n+\nğ‘²\nP\nâ€‹\nğ’™\n~\n=\nğ’‰\nd\nâˆ’\nğ’‰\ne\n,\n\\bm{M}_{d}\\,\\ddot{\\tilde{\\bm{x}}}+\\bm{K}_{D}\\,\\dot{\\tilde{\\bm{x}}}+\\bm{K}_{P}\\,\\tilde{\\bm{x}}=\\bm{h}_{d}-\\bm{h}_{e},\n(4)\nwhere\nğ‘´\nd\n,\nğ‘²\nD\n,\nğ‘²\nP\nâ‰»\n0\n\\bm{M}_{d},\\bm{K}_{D},\\bm{K}_{P}\\succ 0\nare diagonal positive-definite matrices specifying the desired dynamics,\nğ’‰\ne\n\\bm{h}_{e}\nis the measured external wrench, and\nğ’‰\nd\n\\bm{h}_{d}\nis the commanded feedforward wrench.\nThe vectors\nğ’™\n~\nË™\n\\dot{\\tilde{\\bm{x}}}\nand\nğ’™\n~\nÂ¨\n\\ddot{\\tilde{\\bm{x}}}\ndenote the first and second time derivatives of\nğ’™\n~\n\\tilde{\\bm{x}}\n.\nThe resulting control law providing the commanded task motion is\nğ’™\n~\nÂ¨\n=\nğ‘´\nd\nâˆ’\n1\nâ€‹\n(\nğ’‰\nd\nâˆ’\nğ’‰\ne\nâˆ’\nğ‘²\nD\nâ€‹\nğ’™\n~\nË™\nâˆ’\nğ‘²\nP\nâ€‹\nğ’™\n~\n)\n,\n\\ddot{\\tilde{\\bm{x}}}=\\bm{M}_{d}^{-1}\\big(\\bm{h}_{d}-\\bm{h}_{e}-\\bm{K}_{D}\\,\\dot{\\tilde{\\bm{x}}}-\\bm{K}_{P}\\,\\tilde{\\bm{x}}\\big),\n(5)\nwhose integration yields the commanded pose\nğ’™\nc\n=\nğ’™\nd\nâˆ’\nğ’™\n~\n\\bm{x}_{c}=\\bm{x}_{d}-\\tilde{\\bm{x}}\ntracked by the downstream controller\n[\n16\n,\n17\n]\n.\nâ€¢\nCartesian pose control (CPC):\nğ’’\nË™\nc\n=\nğ‘±\nâ€ \nâ€‹\n(\nğ’’\n)\nâ€‹\n(\nğ‘²\nP\nâ€‹\n(\nğ’™\nd\nâˆ’\nğ’™\n)\n+\nğ’—\nd\n)\n,\n\\dot{\\bm{q}}_{c}=\\bm{J}^{\\dagger}(\\bm{q})\\big(\\bm{K}_{P}(\\bm{x}_{d}-\\bm{x})+\\bm{v}_{d}\\big),\n(6)\nwhere\nğ‘±\nâ€ \n\\bm{J}^{\\dagger}\ndenotes a damped least-squares pseudoinverse of the geometric Jacobian\nğ‘±\n\\bm{J}\n, and\nğ’’\nË™\nc\n\\dot{\\bm{q}}_{c}\nis the resulting joint-space command\n[\n9\n]\n. When only a position controller is available,\nğ’’\nË™\nc\n\\dot{\\bm{q}}_{c}\nis integrated to obtain target joint positions.\nFigure 1:\nComponent diagram. The\nReference Generator\nvalidates and interpolates incoming references, producing single, chainable references for the downstream controller.\nII\nDesign\nThis section describes the proposed architecture and its behavior.\nAn implementation is available in our repository\n1\n1\n1\nhttps://github.com/unisa-acg/reference-generators-demo/tree/rap\n.\nFig.\n1\nshows the main components and their interfaces.\nIn particular, we distinguish between two main components with complementary functionalities: the\nReference Generator\nand the\nController\n.\nThe former:\nâ€¢\nreceives single-point references or trajectories from external nodes;\nâ€¢\nvalidates incoming references to ensure dimensional consistency, numerical correctness, and compliance with expected limits, and rejects invalid external references with appropriate error codes;\nâ€¢\nperforms interpolation of references to match the controller frequency;\nâ€¢\nwrites a single-point reference to the downstream controller via\nros2_control\nâ€™s chaining mechanisms.\nThe latter, instead:\nâ€¢\nexposes a chainable controller interface according to\nros2_control\nâ€™s chaining mechanisms;\nâ€¢\nreads a preprocessed reference input from the chainable interfaces;\nâ€¢\nexecutes the control law and performs hardware-interface or downstream-controller-reference writes;\nIn this novel design, controllers are responsible only for executing control laws and interacting with hardware/downstream controllers, while reference acquisition, validation, and interpolation are delegated to the\nReference Generator\n.\nThis separation avoids code duplication and enhances reusability within the\nros2_control\nframework.\nThe\nReference Generator\noperates in two complementary modes: forwarding online point references received on a topic, and executing trajectories received via actions.\nAs shown in Fig.\n2\n, its behavior is governed by a finite state machine (FSM) with two states:\nONLINE_REFERENCE\nand\nTRAJECTORY_EXECUTION\n.\nOn startup, if no reference has been published on the topic yet, the reference generator reads the current robot state and computes an initial reference. In\nONLINE_REFERENCE\n, the generator forwards the most recent reference retrieved from the topic at the controllerâ€™s sampling period, keeping it constant until a new message or trajectory arrives.\nWhen a trajectory is received, the FSM switches to\nTRAJECTORY_EXECUTION\nand the reference generator produces interpolated points at each control period according to trajectory timestamps.\nWhen the trajectory is completed, aborted, or a new reference is received from the topic, the FSM returns to\nONLINE_REFERENCE\n.\nIf a new trajectory arrives while another is being executed, the reference generator aborts the current trajectory and starts the new one, providing action feedback and result codes accordingly.\nImportantly, all non-real-time processing (action/subscriber handling, parsing and validation) occurs outside the real-time controller path (thanks to the decoupling offered by the reference generators), while writing to the chainable interface remains deterministic.\nFigure 2:\nFinite state machine of the\nReference Generator\n.\nIII\nExperimental validation\nIII-A\nExperimental setup and results\nThe experiments validate the design presented in Section\nII\n.\nIn particular, across all experiments, the goal is to demonstrate three key properties of the proposed architecture:\n1.\nController-agnosticity\n: reference generators can easily be configured to work with downstream controllers.\n2.\nRobot-agnosticity\n: the same control pipeline can be exercised on different hardware platforms and Gazebo\n[\n18\n]\nsimulations.\n3.\nReference interpolation\n: the JRG and TRG preprocess incoming references and reliably deliver single-point references at the controllerâ€™s sampling period.\nFigure 3:\nExperiments on real robots: (left) FER executing an excitation trajectory in the JRG â†’ PDGC experiment; (center) control points defining the square Cartesian trajectory in the TRG â†’ CPC experiment on the UR10; (right) UR10 drawing on a blackboard with the TRG â†’ AC â†’ CPC pipeline.\nFigure 4:\nReference (dashed) and measured (solid) joint positions on the real FER under PD control with gravity compensation.\nEach experiment pairs a reference generator with one or more downstream controllers.\nSince the single-point reference functionality of the\nReference Generator\ntrivially consists of forwarding the received topic reference to the downstream controller, the experiments focus on trajectory tracking via actions.\nThe effectiveness of the design and of the controller pipelines is qualitatively demonstrated through trajectory-tracking results.\nThe following control pipelines are tested:\nâ€¢\nJRG â†’ PDGC â†’ simulated FER.\nThe JRG provides\nğ’’\nd\n\\bm{q}_{d}\nto the PDGC (\n2\n) at frequency\nf\n=\n1\nkHz\nf=$1\\text{\\,}\\mathrm{kHz}$\n, which issues torque commands to the simulated FER.\nâ€¢\nJRG â†’ PDGC â†’ real FER.\nThe same pipeline is deployed on the real FER.\nFig.\n3\nshows the robot executing the trajectory, with tracking results reported in Fig.\n4\n.\nIn this experiment, the user provides joint-space waypoints at the same rate as the controller (\nf\n=\n1\nkHz\nf=$1\\text{\\,}\\mathrm{kHz}$\n), so the interpolation functionality of the JRG is not exercised.\nâ€¢\nJRG â†’ PID â†’ simulated UR10.\nThe user provides a few sparse joint-space waypoints to the JRG via action, which interpolates them at the controller rate (\nf\n=\n1\nkHz\nf=$1\\text{\\,}\\mathrm{kHz}$\n) and sends them to the PID controller (\n3\n) in simulation.\nTracking results are shown in Fig.\n5\n.\nâ€¢\nTRG â†’ CPC â†’ simulated UR10.\nThe user sends sparse Cartesian waypoints to the TRG via action; the TRG provides Cartesian pose setpoints to the CPC at\nf\n=\n1\nkHz\nf=$1\\text{\\,}\\mathrm{kHz}$\n, which computes joint targets via inverse kinematics (\n6\n) and sends them to the simulated UR10.\nâ€¢\nTRG â†’ CPC â†’ real UR10.\nSimilar pipeline on the real UR10, but the frequency is reduced to\nf\n=\n125\nHz\nf=$125\\text{\\,}\\mathrm{Hz}$\nto accommodate hardware limitations.\nAn illustration of the trajectory waypoints given by the user is shown in Fig.\n3\n.\nTracking results (after interpolation) are in Fig.\n6\n.\nâ€¢\nTRG â†’ AC â†’ CPC â†’ real UR10.\nThe user sends a few Cartesian waypoints to perform an interaction experiment with the real UR10, consisting of sliding a piece of chalk on a blackboard, as shown in Fig.\n3\n.\nThe TRG provides Cartesian setpoints at\nf\n=\n125\nHz\nf=$125\\text{\\,}\\mathrm{Hz}$\n, which the AC modulates according to the measured end-effector wrench, as explained in (\n4\n) and (\n5\n); the modulated setpoints are executed by the CPC on the real UR10. The actual robot behavior is shown in Fig.\n7\nin terms of position errors.\nâ€¢\nTRG â†’ AC â†’ CPC â†’ PID â†’ simulated UR10.\nA composite pipeline consisting of TRG, AC, CPC, and PID controllers is executed on the simulated UR10 in an interaction scenario. The trajectory consists of a few Cartesian waypoints for a wall-sliding motion.\nIn this experiment, the TRG provides Cartesian setpoints at\nf\n=\n1\nkHz\nf=$1\\text{\\,}\\mathrm{kHz}$\n, which the AC modulates according to the measured end-effector wrench; the modulated setpoints are converted to joint targets by the CPC and finally into effort commands by the PID controller before being sent to the simulated UR10.\nFig.\n7\nshows the position error between the TRG references and the actual end-effector position over time.\nFigure 5:\nReference (circles) and measured (lines) joint positions on the simulated UR10 under PID control.\nIII-B\nDiscussion\nThe experiments confirm the three key properties stated in Section\nIII-A\n.\nThe same implementations of the reference generators were paired with different downstream controllers (PDGC, PID, CPC, AC) without modifying the code of any components.\nAll controllers successfully received the preprocessed references and executed their control laws.\nIdentical control pipelines were executed on both simulation and real hardware (FER and UR10) without architectural changes, demonstrating that the design separates reference generation and controller logic from robot-specific details.\nBoth TRG and JRG correctly preprocessed sparse, time-stamped waypoints and produced single-point references at the controller sampling period (see Figures\n5\nand\n6\n).\nHigher errors observed in the admittance experiments are expected, since interaction forces intentionally modulate the motion during contact, yielding compliant behavior.\nThe results also confirm that multi-layer pipelines (e.g., TRG â†’ AC â†’ CPC â†’ PID) can be assembled without specialized architectural design, demonstrating the frameworkâ€™s flexibility and support for hierarchical control.\nFinally, both ROS2-native (PID) and new proposed controllers (PDGC, CPC, and AC) were successfully validated, confirming their compatibility with the proposed design.\nFigure 6:\nReference (circles) and measured (lines) end-effector position (left) and orientation (right) signals on the real UR10 under Cartesian pose control.\nFigure 7:\nEnd-effector position errors on the real (left) and simulated (right) UR10 under admittance control. X and Y axes are contact directions in base frame, respectively.\nIV\nConclusions\nThis paper presented a modular architecture for ROS2 that separates reference processing from control-law execution, realized through two reference generators (JRG and TRG).\nThe work demonstrated that this separation improves reusability, simplifies controller design, and enables modular construction of flexible control pipelines through chaining.\nThe JRG and TRG were shown to be compatible not only with the custom controllers introduced in this work, but also with the\nros2_control\nPID controller, showing that the same reference generators can be used with controllers developed by the community as long as they adhere to the\nros2_control\nâ€™s chaining mechanisms.\nThe architecture naturally allows for extensions at the reference generation level; while linear interpolation was sufficient for our demonstrations, the modular design easily accommodates higher-order interpolation (e.g., quintic splines) to improve smoothness and reference fidelity without affecting downstream controllers.\nThe pipelines defined in Section\nIII\nwere configured by only changing the parameters in the configuration file (e.g., interface names, control period, and gains), demonstrating the limited effort required for reconfiguration.\nIn addition, the successful development of new control laws based on the same reference generators shows that they provide a stable abstraction for extending and prototyping additional control strategies.\n[Description of Supplementary Materials]\nTABLE I:\nDescription of Supplementary Materials\nMaterial\nDescription\nVideo\n(rap-rg-video.mp4)\nThe video shows the three experiments executed on the real robots:\n1.\nPDGC on the real FER;\n2.\nCPC on the real UR10 robot;\n3.\nAC\nâ†’\n\\rightarrow\nCPC pipeline on the real UR10 robot.\nThe video can be viewed on YouTube at\nhttps://youtu.be/qpMYzO2Cpx8\nSource code\n(online)\nThe source code is hosted in a GitHub repository, containing the ROS2 packages implementing the reference generators (JRG and TRG) described in the paper, together with documentation and launch files to use them.\nThe readers can directly access the GitHub repository at\nhttps://github.com/unisa-acg/reference-generators-demo/tree/rap\n.\nUML Class Diagram\n(rap-rg-class-diagram.png)\nThe Class Diagram better illustrates the main\nReference Generators\nclasses (\nReferenceGenerator\n,\nJointSpaceReferenceGenerator\n, and\nTaskSpaceReferenceGenerator\n), their methods, and their relationships.\nThis work is supported by the supplementary materials detailed in Table\nI\n.\nReferences\n[1]\nS.Â Macenski, T.Â Foote, B.Â Gerkey, C.Â Lalancette, and W.Â Woodall, â€œRobot Operating System 2: Design, architecture, and uses in the wild,â€\nScience Robotics\n, vol.Â 7, no.Â 66, 2022, art. no. eabm6074.\n[2]\nS.Â Chitta, E.Â Marder-Eppstein, W.Â Meeussen, V.Â Pradeep, A.Â R. Tsouroukdissian, J.Â Bohren, D.Â Coleman, B.Â Magyar, G.Â Raiola, M.Â LÃ¼dtke, and E.Â F. Perdomo, â€œros_control: A generic and simple control framework for ROS,â€\nJournal of Open Source Software\n, vol.Â 2, no.Â 20, p. 456, 2017. [Online]. Available:\nhttps://doi.org/10.21105/joss.00456\n[3]\nros2_control Development Team, â€œROS2 Control,â€ 2025. [Online]. Available:\nhttps://control.ros.org/rolling/index.html\n[4]\nâ€”â€”, â€œController Chaining / Cascade Control,â€ 2025. [Online]. Available:\nhttps://control.ros.org/rolling/doc/ros2_control/controller_manager/doc/controller_chaining.html\n[5]\nR.Â C. Martin,\nClean Code: A Handbook of Agile Software Craftsmanship\n, 1stÂ ed.â€ƒUSA: Prentice Hall PTR, 2008.\n[6]\nros2_control Development Team, â€œROS2 Controllers,â€ 2025. [Online]. Available:\nhttps://control.ros.org/rolling/doc/ros2_controllers/doc/controllers_index.html\n[7]\nOpen Robotics, â€œUnderstanding Topics,â€ 2025. [Online]. Available:\nhttps://docs.ros.org/en/rolling/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics.html\n[8]\nâ€”â€”, â€œUnderstanding Actions,â€ 2025. [Online]. Available:\nhttps://docs.ros.org/en/rolling/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Actions/Understanding-ROS2-Actions.html\n[9]\nP.Â Chiacchio, S.Â Chiaverini, L.Â Sciavicco, and B.Â Siciliano, â€œClosed-Loop Inverse Kinematics Schemes for Constrained Redundant Manipulators with Task Space Augmentation and Task Priority Strategy,â€\nThe International Journal of Robotics Research\n, vol.Â 10, no.Â 4, pp. 410â€“425, 1991. [Online]. Available:\nhttps://doi.org/10.1177/027836499101000409\n[10]\nUniversal Robots A/S, â€œUniversal Robots,â€ 2025. [Online]. Available:\nhttps://www.universal-robots.com/\n[11]\nS.Â Haddadin, S.Â Parusel, L.Â Johannsmeier, S.Â Golz, S.Â Gabl, F.Â Walch, M.Â Sabaghian, C.Â JÃ¤hne, L.Â Hausperger, and S.Â Haddadin, â€œThe Franka Emika Robot: A Reference Platform for Robotics Research and Education,â€\nIEEE Robotics & Automation Magazine\n, vol.Â 29, no.Â 2, pp. 46â€“64, Jun. 2022.\n[12]\nFranka Robotics GmbH, â€œFranka Robotics,â€ 2025. [Online]. Available:\nhttps://franka.de/products-overview\n[13]\nR.Â Featherstone and D.Â E. Orin, â€œDynamics,â€ in\nSpringer Handbook of Robotics\n, 2ndÂ ed., B.Â Siciliano and O.Â Khatib, Eds.â€ƒCham: Springer, 2016, vol.Â 3, pp. 195â€“211. [Online]. Available:\nhttps://link.springer.com/10.1007/978-3-319-32552-1\n[14]\nR.Â Kelly, V.Â SantibÃ¡Ã±ezÂ Davila, and A.Â LorÃ­a, â€œPD Control with Gravity Compensation,â€ in\nControl of Robot Manipulators in Joint Space\n.â€ƒLondon: Springer London, 2005, pp. 157â€“169. [Online]. Available:\nhttps://doi.org/10.1007/1-85233-999-3_9\n[15]\nâ€”â€”, â€œPID control,â€ in\nControl of Robot Manipulators in Joint Space\n.â€ƒLondon: Springer London, 2005, pp. 201â€“220. [Online]. Available:\nhttps://doi.org/10.1007/1-85233-999-3_11\n[16]\nW.Â S. Newman, â€œStability and Performance Limits of Interaction Controllers,â€\nJournal of Dynamic Systems, Measurement, and Control\n, vol. 114, no.Â 4, pp. 563â€“570, 12 1992. [Online]. Available:\nhttps://doi.org/10.1115/1.2897725\n[17]\nL.Â Villani and J.Â DeÂ Schutter, â€œForce control,â€ in\nSpringer Handbook of Robotics\n, B.Â Siciliano and O.Â Khatib, Eds.â€ƒCham: Springer International Publishing, 2016, pp. 195â€“220. [Online]. Available:\nhttps://doi.org/10.1007/978-3-319-32552-1_9\n[18]\nN.Â Koenig and A.Â Howard, â€œDesign and use paradigms for Gazebo, an open-source multi-robot simulator,â€ in\nIEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)\n, ser. IROS-04, vol.Â 3.â€ƒIEEE, 2004, pp. 2149â€“2154. [Online]. Available:\nhttp://dx.doi.org/10.1109/iros.2004.1389727",
    "preview_text": "This paper introduces a novel modular architecture for ROS2 that decouples the logic required to acquire, validate, and interpolate references from the control laws that track them. The design includes a dedicated component, named Reference Generator, that receives references, in the form of either single points or trajectories, from external nodes (e.g., planners), and writes single-point references at the controller's sampling period via the existing ros2_control chaining mechanism to downstream controllers. This separation removes duplicated reference-handling code from controllers and improves reusability across robot platforms. We implement two reference generators: one for handling joint-space references and one for Cartesian references, along with a set of new controllers (PD with gravity compensation, Cartesian pose, and admittance controllers) and validate the approach on simulated and real Universal Robots and Franka Emika manipulators. Results show that (i) references are tracked reliably in all tested scenarios, (ii) reference generators reduce duplicated reference-handling code across chained controllers to favor the construction and reuse of complex controller pipelines, and (iii) controller implementations remain focused only on control laws.\n\nSimplifying ROS2 controllers with a modular architecture for robot-agnostic reference generation\nDavide Risi,\nVincenzo Petrone,Â \nAntonio Langella,\nLorenzo Pagliara,Â \nEnrico Ferrentino,Â \nPasquale Chiacchio\nAuthors are with the Department of Information Engineering, Electrical Engineering and Applied Mathematics (DIEM), University of Salerno, 84084 Fisciano, Italy (email: {drisi, vipetrone, alangella, lpagliara, eferrentino, pchiacchio}@unisa.it).\nAbstract\nThis paper introduces a novel modular architecture for ROS2 that decouples the logic required to acquire, validate, and interpolate references from the control laws that track them.\nThe design includes a dedicated component, named\nReference Generator\n, that rece",
    "is_relevant": false,
    "relevance_score": 0.0,
    "extracted_keywords": [
        "ROS2",
        "modular architecture",
        "reference generation",
        "robot-agnostic",
        "controllers",
        "joint-space",
        "Cartesian",
        "simulation",
        "real robots"
    ],
    "one_line_summary": "æœ¬æ–‡æå‡ºäº†ä¸€ç§ç”¨äºROS2çš„æ¨¡å—åŒ–æ¶æ„ï¼Œé€šè¿‡è§£è€¦å‚è€ƒç”Ÿæˆä¸æ§åˆ¶å¾‹æ¥ç®€åŒ–æ§åˆ¶å™¨è®¾è®¡ï¼Œæé«˜è·¨æœºå™¨äººå¹³å°çš„å¯é‡ç”¨æ€§ã€‚",
    "detailed_summary": "",
    "qa_pairs": [],
    "is_hidden": false,
    "is_starred": false,
    "flag": true,
    "published_date": "2026-01-13T12:55:07Z",
    "created_at": "2026-01-20T17:49:44.621449",
    "updated_at": "2026-01-20T17:49:44.621457",
    "recommend": 0
}