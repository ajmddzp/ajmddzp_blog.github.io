{
    "id": "2601.22849v1",
    "title": "Robust Rigid Body Assembly via Contact-Implicit Optimal Control with Exact Second-Order Derivatives",
    "authors": [
        "Christian Dietz",
        "Sebastian Albrecht",
        "Gianluca Frison",
        "Moritz Diehl",
        "Armin NurkanoviÄ‡"
    ],
    "abstract": "é«˜æ•ˆè§„åˆ’è£…é…åŠ¨ä½œæ˜¯æœºå™¨äººé¢†åŸŸé•¿æœŸé¢ä¸´çš„æŒ‘æˆ˜ï¼Œå½“å‰ä¸»è¦ä¾èµ–å¼ºåŒ–å­¦ä¹ å’ŒåŸºäºé‡‡æ ·çš„æ–¹æ³•ï¼Œå¹¶éœ€å€ŸåŠ©å¤§é‡ç‰©ç†ä»¿çœŸã€‚æœ¬æ–‡æå‡ºä¸€ç§åŸºäºæ ·æœ¬é«˜æ•ˆçš„é²æ£’æœ€ä¼˜æ§åˆ¶æ–¹æ³•ï¼Œç”¨äºç¡®å®šè£…é…åŠ¨ä½œï¼Œè¯¥æ–¹æ³•é€šè¿‡æœ‰æ•ˆåˆ©ç”¨å¯¼æ•°ä¿¡æ¯ï¼Œåœ¨è§„åˆ’è¿‡ç¨‹ä¸­å¤§å¹…å‡å°‘ç‰©ç†ä»¿çœŸæ­¥éª¤ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬æ„å»ºäº†ä¸€ä¸ªå¯å¾®åˆ†çš„ç‰©ç†ä»¿çœŸç³»ç»Ÿï¼Œä¸ºæ•°å€¼æ±‚è§£å™¨æä¾›äºŒé˜¶è§£æå¯¼æ•°ï¼Œå¹¶å®ç°ä»ä¿¡æ¯ä¸°å¯Œçš„å¯¼æ•°åˆ°ç²¾ç¡®æ¥è§¦ä»¿çœŸçš„æ— ç¼è¿‡æ¸¡ã€‚é€šè¿‡é‡‡ç”¨å†…ç‚¹æ³•å¯å‘çš„å¹³æ»‘æŠ€æœ¯ï¼Œå¯¹ç¢°æ’æ£€æµ‹å’Œæ¥è§¦è§£æé—®é¢˜è¿›è¡Œä¼˜åŒ–ï¼Œä½¿ç‰©ç†ä»¿çœŸé—®é¢˜çš„è§£å…·å¤‡å¯å¾®æ€§ã€‚æˆ‘ä»¬æå‡ºäº†ä¸€ç§åŸºäºä¼˜åŒ–çš„ç¢°æ’æ£€æµ‹å…¬å¼çš„æ”¹è¿›å˜ä½“ï¼Œå°†å…¶è¡¨è¿°ä¸ºçº¿æ€§è§„åˆ’é—®é¢˜ï¼Œå¹¶å®ç°äº†æ ‡ç§°è¯„ä¼°åŠå¯¹åº”ä¸€é˜¶ã€äºŒé˜¶å¯¼æ•°çš„é«˜æ•ˆè®¡ç®—ã€‚æ­¤å¤–ï¼Œæ¨å¯¼äº†åŸºäºå¤šåœºæ™¯çš„è½¨è¿¹ä¼˜åŒ–é—®é¢˜ï¼Œä»¥ç¡®ä¿å¯¹ä»¿çœŸåˆ°ç°å®å·®å¼‚çš„é²æ£’æ€§ã€‚é€šè¿‡å®é™…å®éªŒå–å¾—è¶…è¿‡99%çš„æˆåŠŸæ‰§è¡Œç‡ï¼ŒéªŒè¯äº†æ‰€ææ–¹æ³•çš„æœ‰æ•ˆæ€§ã€‚æˆ‘ä»¬æ·±å…¥ç ”ç©¶äº†æ¥è§¦åŠ¨åŠ›å­¦å¹³æ»‘è¿‘ä¼¼å’Œé²æ£’å»ºæ¨¡å¯¹æˆåŠŸç‡çš„å½±å“ï¼Œå¹¶åœ¨ä»¿çœŸä¸­å¯¹ä¸åŒè½´å­”è£…é…é—®é¢˜æµ‹è¯•äº†è¯¥æ–¹æ³•ï¼Œè¯æ˜äº†ä½¿ç”¨ç²¾ç¡®æµ·æ£®çŸ©é˜µç›¸è¾ƒäºå¸¸ç”¨æµ·æ£®çŸ©é˜µè¿‘ä¼¼çš„ä¼˜åŠ¿ã€‚",
    "url": "https://arxiv.org/abs/2601.22849v1",
    "html_url": "https://arxiv.org/html/2601.22849v1",
    "html_content": "Robust Rigid Body Assembly via Contact-Implicit\nOptimal Control with Exact Second-Order Derivatives\nChristian Dietz\n1,2\n, Sebastian Albrecht\n1\n, Gianluca Frison\n2\n, Moritz Diehl\n2,3\n, Armin NurkanoviÄ‡\n2\n1\nAutonomous Systems and Control, Siemens AG, Germany\n2\nDepartment of Microsystems Engineering (IMTEK), University of Freiburg, Germany\n3\nDepartment of Mathematics, University of Freiburg, Germany\nCorrespondent:\ndietz.christian@siemens.com\nAbstract\nEfficient planning of assembly motions is a long standing challenge in the field of robotics that has been primarily tackled with reinforcement learning and sampling-based methods by using extensive physics simulations. This paper proposes a sample-efficient robust optimal control approach for the determination of assembly motions, which requires significantly less physics simulation steps during planning through the efficient use of derivative information. To this end, a differentiable physics simulation is constructed that provides second-order analytic derivatives to the numerical solver and allows one to traverse seamlessly from informative derivatives to accurate contact simulation. The solution of the physics simulation problem is made differentiable by using smoothing inspired by interior-point methods applied to both the collision detection as well as the contact resolution problem. We propose a modified variant of an optimization-based formulation of collision detection formulated as a linear program and present an efficient implementation for the nominal evaluation and corresponding first- and second-order derivatives. Moreover, a multi-scenario-based trajectory optimization problem that ensures robustness with respect to sim-to-real mismatches is derived. The capability of the considered formulation is illustrated by results where over 99% successful executions are achieved in real-world experiments. Thereby, we carefully investigate the effect of smooth approximations of the contact dynamics and robust modeling on the success rates. Furthermore, the methodâ€™s capability is tested on different peg-in-hole problems in simulation to show the benefit of using exact Hessians over commonly used Hessian approximations.\nI\nIntroduction\nDifferentiable physics simulation increasingly receives attention in the robotics community motivated by the potential that providing derivative information to planning and control algorithms can substantially increase their computational efficiency\n[\n23\n,\n50\n,\n30\n]\n. It is already successfully leveraged within reinforcement learning (RL) and model predictive control (MPC) methods applied to tasks such as quadruped walking or dexterous manipulation\n[\n40\n,\n19\n]\n. Assembly problems have predominantly been addressed by derivative-free reinforcement learning algorithms using extensive simulation\n[\n46\n,\n22\n]\neven though derivative-based methods showed improved sample-efficiency on other problem classes\n[\n50\n,\n30\n]\n. We deduce that there is currently a gap of derivative-based algorithms that successfully utilize differentiable physics simulation methods to solve assembly tasks.\nFigure 1\n:\nIllustration of a considered assembly problem and this paperâ€™s methodology. The optimization of assembly trajectories is facilitated by initially relaxing object shapes and force-distance complementarities followed by sequentially tightening the relaxations. Video highlighting the methodology:\nhttps://youtu.be/g4E83bjs7lg\nThe large majority of the work on physics simulation for robotics agrees on formulating contact-rich dynamical systems in continuous time as complementarity Lagrangian\nsystems with state jumps\n[\n7\n]\n, and deriving discrete-time dynamics by applying a time-stepping discretization to obtain a nonlinear complementarity problem (NCP)\n[\n34\n]\n. To construct the contact NCP, first multiple collision detection problems that compute the distance between pairs of convex objects have to be solved and corresponding contact normal vectors have to be determined which encode the direction in which contact forces act. These collision detection problems for convex objects can be formulated as convex quadratic programs such that their optimality conditions take the form of linear complementarity problems (LCP). Thus, computing a single simulation step comes down to solving multiple collision LCP and then using these solutions to construct and solve a single contact NCP.\nThe challenge for using derivative-based methods to solve contact-rich tasks lies primarily in the fact that the solution of the contact NCP is inherently nonsmooth with respect to its problem data. This means that the position and velocity of objects at the next time step can be nondifferentiable with respect to the position and velocity of objects as well as the control input at the current time step. This is due to two hierarchically structured causes. The first cause are positions, where an infinitesimal alteration results in a change of an active complementarity condition in a collision LCP. This means contact points switching between faces, edges or vertices on a convex object. The second cause are current positions and velocities where infinitesimal alterations result in changes of active complementarity conditions in the contact NCP. Here two distinctions can be made. Either such a switch corresponds to activation or deactivation of contact forces between a pair of convex objects, or one pair of such objects switches its friction mode from static to sliding or vice versa.\nConsequentially, constructing differentiable physics simulations necessarily requires additional custom design choices, as for the original NCP formulation derivatives do not exist everywhere. There are three common choices that can be found in the physics simulation literature. First, determining exact derivatives under the assumption that active complementarity conditions do not change\n[\n26\n,\n48\n]\n. For situations where infinitesimal changes in positions or velocities result in switches in the active complementarity conditions, one obtains subgradients. Second, using finite differences or randomized smoothing\n[\n32\n,\n27\n]\nto obtain approximate derivatives that do not correspond to exact derivatives of the nominal LCP or NCP evaluation. These two approaches both likely hinder success of optimization routines, as either the produced derivatives are not globally informative for the behavior of the underlying dynamics, or there is a mismatch between the nominal evaluation that is nonsmooth and the derivatives that correspond to a smooth approximation of the nonsmooth evaluation.\nA more optimization-suited approach is therefore the third, which is constructing smooth approximations to the complementarity problems and then determining corresponding exact derivatives\n[\n16\n,\n43\n]\n. Remarkably, most existing work on differentiable physics simulation only focuses on the nondifferentiabilities caused by the contact NCP while disregarding the contribution of the collision LCP. This likely contributes to the lack of work that tackles assembly problems with complex geometries using differentiable physics simulation.\nIn this paper, we focus on frictionless contacts which leads to the reduction of the contact NCP to a contact LCP, under the precondition that a semi-implicit Euler integration was used to derive the time-stepping discretization. A LCP formulation of contact dynamics can also be obtained when friction is considered by linearization of the friction cone as done in several physics engines\n[\n48\n]\n. We formulate the collision detection problem as a linear program (LP) using so-called growth distances\n[\n36\n]\n, where we propose a modified formulation that is motivated by the goal to obtain well-scaled derivatives that can be utilized in optimal control formulations. We construct smooth approximations to this distance problem by leveraging interior-point methods. Recurrent application of the implicit function theorem enables analytic formulations for first- and second-order derivatives.\nFor the contact resolution problem, the well-established quadratic program formulation of Moreau\n[\n34\n]\nis used, which allows one to obtain a smooth approximation again by utilizing smoothing as implied by interior-point methods. We take the approach of directly transcribing the optimality conditions of the contact resolution problem into the optimal control problem. In this case, the interior-point smoothing can also be interpreted as Scholtesâ€™ smoothing applied to the complementarity conditions of the contact LCP and also enables one to use Scholtesâ€™ relaxation method\n[\n38\n]\nwhich relaxes each complementarity condition individually. These two alternatives are compared within numerical experiments, emphasizing that control algorithms using differentiable physics simulation can profit from additional degrees of freedom that enables the optimization solver to control the physical evolution.\nTo ensure that the computed assembly motions can be reliably executed on real robotic systems, we utilize a multi-scenario-based optimal control formulation with a state-feedback control law given by a Cartesian impedance controller. We consider assembly problems with almost zero clearance. On the one hand, one then needs to obtain solutions for simulations where the collision and contact LCP are solved to high accuracy to ensure a reliable transfer to the real-world. On the other hand, substantial smoothing of these LCP results in nonstiff contact dynamics, enabling optimization solver convergence from trivial initial guesses. To get the best out of two worlds, we use a homotopy procedure that sequentially tightens the relaxations and uses previous solutions to warmstart the optimization solver, enabling the computation of solutions for very stiff contact dynamics which closely approximate the original nondifferentiable formulations.\nWe carefully investigate the effect that the amount of contact dynamics smoothing as well as robust modeling has on the real-world success rates of the motions.\nFurther results show improved convergence speed when exact Hessians are used over commonly used Hessian approximations such as Gauss-Newton or L-BFGS.\nOverall, we obtain a method that enables the computation of robust assembly motions that can directly be executed on real robots without necessity for further tuning, even in the presence of substantial model-reality mismatches. The approach is applicable to any rigid body assembly problem, where all shapes are represented through unions of convex polytopes. The optimal control formulation utilizes model information efficiently, through a differentiable physics simulation formulation which provides up to second-order derivatives. This enables improved sample-efficiency compared to derivative-free methods. The optimal control formulation also allows one to easily add additional constraints in an intuitive way, e.g., one could add bounds on velocities, accelerations or forces.\nI-A\nContribution\nThe main contributions of this paper are as follows:\nâˆ™\n\\bullet\nA modified formulation of signed distance functions (SDF) as growth distances that closely approximate the Euclidean SDF and a corresponding gradient approximation that is used as contact normal vector.\nâˆ™\n\\bullet\nAn efficient implementation for SDF and contact normals and corresponding first- and second-order derivatives using the high-performance interior-point solver\nHPIPM\n[\n11\n]\nand the linear algebra library\nBLASFEO\n[\n12\n]\n, and a interface that allows one to use these computations in the optimal control library\nCasADi\n[\n3\n]\n.\nâˆ™\n\\bullet\nA multi-scenario-based robust optimal control formulation for assembly planning that ensures successfully executable motions on real robotic systems.\nâˆ™\n\\bullet\nReal-world experiments that investigate how smoothing of the contact simulation and robustness parameters of the optimal control problem affect success rates on the real system.\nâˆ™\n\\bullet\nNumerical results that illustrate the impact of different smoothing schemes on the convergence behavior of the algorithm and the benefit of using exact Hessians over commonly used approximations such as Gauss-Newton or L-BFGS.\nI-B\nNotation\nTo stack vectors, we compactly write\n(\nx\n1\n,\nâ€¦\n,\nx\nm\n)\n=\n[\nx\n1\nâŠ¤\n,\nâ€¦\n,\nx\nm\nâŠ¤\n]\nâŠ¤\n(x_{1},\\dots,x_{m})=[x_{1}^{\\top},\\dots,x_{m}^{\\top}]^{\\top}\nfor\nx\n1\nâˆˆ\nâ„\nn\n1\n,\nâ€¦\n,\nx\nm\nâˆˆ\nâ„\nn\nm\nx_{1}\\in\\mathbb{R}^{n_{1}},\\dots,x_{m}\\in\\mathbb{R}^{n_{m}}\n. Furthermore,\nğŸ\n=\n(\n0\n,\nâ€¦\n,\n0\n)\n\\bm{0}=(0,\\dots,0)\nand\nğŸ\n=\n(\n1\n,\nâ€¦\n,\n1\n)\n\\bm{1}=(1,\\dots,1)\nare the vectors with all zeros or all ones, respectively, where the corresponding dimension becomes clear from the context.\nFor a unit quaternion\nÎ¾\nâˆˆ\nâ„\n4\n\\xi\\in\\mathbb{R}^{4}\n,\nR\nâ€‹\n(\nÎ¾\n)\nR(\\xi)\nis the associated\n3\nÃ—\n3\n3\\times 3\nrotation matrix. Given another unit quaternion\nÎ¶\nâˆˆ\nâ„\n4\n\\zeta\\in\\mathbb{R}^{4}\n,\nÎ¾\nâŠ—\nÎ¶\n\\xi\\otimes\\zeta\ndenotes quaternion multiplication. We further define the identity position\nÏ\nÂ¯\nid\n=\n(\n0\n,\n0\n,\n0\n)\n\\bar{\\rho}_{\\mathrm{id}}=(0,0,0)\n, the identity quaternion\nÎ¾\nÂ¯\nid\n=\n(\n1\n,\n0\n,\n0\n,\n0\n)\n\\bar{\\xi}_{\\mathrm{id}}=(1,0,0,0)\nand the analogous identity pose\nq\nÂ¯\nid\n=\n(\nÏ\nÂ¯\nid\n,\nÎ¾\nÂ¯\nid\n)\n\\bar{q}_{\\mathrm{id}}=(\\bar{\\rho}_{\\mathrm{id}},\\bar{\\xi}_{\\mathrm{id}})\n.\nFor a multivariate function\nf\n:\nâ„\nn\nÃ—\nâ„\nm\nâ†’\nâ„\nl\nf:\\mathbb{R}^{n}\\times\\mathbb{R}^{m}\\rightarrow\\mathbb{R}^{l}\n, total derivatives are compactly denoted by\nD\nx\nâ€‹\nf\nâ€‹\n(\nx\n,\ny\n)\n=\nd\nâ€‹\nf\nâ€‹\n(\nx\n,\ny\n)\nd\nâ€‹\nx\nâˆˆ\nâ„\nl\nÃ—\nn\n\\mathrm{D}_{x}f(x,y)=\\frac{\\mathrm{d}f(x,y)}{\\mathrm{d}x}\\in\\mathbb{R}^{l\\times n}\nand partial derivatives are compactly denoted by\nâˆ‚\nx\nf\nâ€‹\n(\nx\n,\ny\n)\n=\nâˆ‚\nf\nâ€‹\n(\nx\n,\ny\n)\nâˆ‚\nx\nâˆˆ\nâ„\nl\nÃ—\nn\n\\partial_{x}f(x,y)=\\frac{\\partial f(x,y)}{\\partial x}\\in\\mathbb{R}^{l\\times n}\n. For a seed\ns\nâˆˆ\nâ„\nl\ns\\in\\mathbb{R}^{l}\nsecond-order total directional derivatives are written as\nâŸ¨\ns\n,\nD\nx\n,\ny\n2\nâ€‹\nf\nâ€‹\n(\nx\n,\ny\n)\nâŸ©\n=\nâˆ‘\ni\n=\n1\nl\ns\ni\nâ€‹\nd\n2\nâ€‹\nf\ni\nâ€‹\n(\nx\n,\ny\n)\nd\nâ€‹\nx\nâ€‹\nd\nâ€‹\ny\nâˆˆ\nâ„\nn\nÃ—\nm\n.\n\\langle s,\\,\\mathrm{D}^{2}_{x,y}f(x,y)\\rangle=\\sum_{i=1}^{l}s_{i}\\frac{\\mathrm{d}^{2}f_{i}(x,y)}{\\mathrm{d}x\\,\\mathrm{d}y}\\in\\mathbb{R}^{n\\times m}.\nIf it is clear from the context, we use the shorthand notation\nâŸ¨\ns\n,\nD\nx\n,\ny\n2\nâ€‹\nf\nâŸ©\n\\langle s,\\,\\mathrm{D}^{2}_{x,y}f\\rangle\n. This notation is equally adapted for second-order partial directional derivatives, thus, we write\nâŸ¨\ns\n,\nâˆ‚\nx\n,\ny\n2\nf\nâ€‹\n(\nx\n,\ny\n)\nâŸ©\n=\nâˆ‘\ni\n=\n1\nl\ns\ni\nâ€‹\nâˆ‚\n2\nf\ni\nâ€‹\n(\nx\n,\ny\n)\nâˆ‚\nx\nâ€‹\nâˆ‚\ny\nâˆˆ\nâ„\nn\nÃ—\nm\n,\n\\langle s,\\,\\partial^{2}_{x,y}f(x,y)\\rangle=\\sum_{i=1}^{l}s_{i}\\frac{\\partial^{2}f_{i}(x,y)}{\\partial x\\,\\partial y}\\in\\mathbb{R}^{n\\times m},\nand in short\nâŸ¨\ns\n,\nâˆ‚\nx\n,\ny\n2\nf\nâŸ©\n\\langle s,\\,\\partial^{2}_{x,y}f\\rangle\n.\nTable\nI\ndenotes further key symbols used in this paper. We will write\nq\nâˆˆ\nâ„\nn\nq\nq\\in\\mathbb{R}^{n_{\\mathrm{q}}}\n,\nv\nâˆˆ\nâ„\nn\nv\nv\\in\\mathbb{R}^{n_{\\mathrm{v}}}\nand\nx\nâˆˆ\nâ„\nn\nx\nx\\in\\mathbb{R}^{n_{\\mathrm{x}}}\nfor improved readability and to emphasize that the proposed method can be easily extended to the case with multiple actuated objects, where in this paper the special case\nn\nq\n=\n7\nn_{\\mathrm{q}}=7\n,\nn\nv\n=\n6\nn_{\\mathrm{v}}=6\n,\nn\nx\n=\n13\nn_{\\mathrm{x}}=13\nis considered.\nI-C\nOutline\nThis paper is organized as follows. Section\nII\ndiscusses related work on differentiable collision detection, differentiable physics simulation and corresponding planning and control algorithms. In Section\nIII\nthe proposed optimization-based collision detection formulation, a corresponding contact normal approximation and derivation of first- and second-order derivatives are introduced. The considered dynamical system for contact simulation and corresponding relaxation approaches are discussed in Section\nIV\n. Section\nV\nintroduces the optimal control problem formulation for robust assembly planning. Finally, experiments on real hardware and in simulation are conducted in Section\nVI\n, highlighting the properties of the considered methodology.\nTABLE I\n:\nOverview of key symbols.\nSymbol\nDescription\nFirst introduced\nâ„\nâ‰¥\n0\n\\mathbb{R}_{\\geq 0}\nSet of nonnegative real numbers\nSection\nIII\nÏ\nâˆˆ\nâ„\n3\n\\rho\\in\\mathbb{R}^{3}\nTranslational position\nSection\nIII\nÎ¾\nâˆˆ\nâ„\n4\n\\xi\\in\\mathbb{R}^{4}\nUnit quaternion orientation\nSection\nIII\nq\n=\n(\nÏ\n,\nÎ¾\n)\nâˆˆ\nâ„\n7\nq=(\\rho,\\xi)\\in\\mathbb{R}^{7}\nRigid body pose\nSection\nIII\n|\nÎ \n|\nâˆˆ\nâ„•\n|\\Pi|\\in\\mathbb{N}\nNumber of considered collision pairs\nSection\nIII\nÏ„\nâˆˆ\nâ„\nâ‰¥\n0\n\\tau\\in\\mathbb{R}_{\\geq 0}\nSmoothing parameter of collision detection\nSection\nIII\nÎ¦\nÏ„\nâˆˆ\nâ„\n\\Phi_{\\tau}\\in\\mathbb{R}\nSigned distance function (SDF)\nSection\nIII\nn\nÏ„\nâˆˆ\nâ„\n7\nn_{\\tau}\\in\\mathbb{R}^{7}\nContact normal vector\nSection\nIII\nw\nÏ„\nâˆˆ\nâ„\n8\nw_{\\tau}\\in\\mathbb{R}^{8}\nContact information vector\nSection\nIII\nÎ½\nâˆˆ\nâ„\n3\n\\nu\\in\\mathbb{R}^{3}\nTranslational velocity\nSection\nIV\nÏ‰\nâˆˆ\nâ„\n3\n\\omega\\in\\mathbb{R}^{3}\nRotational velocity\nSection\nIV\nv\n=\n(\nÎ½\n,\nÏ‰\n)\nâˆˆ\nâ„\n6\nv=(\\nu,\\omega)\\in\\mathbb{R}^{6}\nRigid body velocity\nSection\nIV\nx\n=\n(\nq\n,\nv\n)\nâˆˆ\nâ„\n13\nx=(q,v)\\in\\mathbb{R}^{13}\nRigid body state\nSection\nIV\nÏƒ\nâˆˆ\nâ„\nâ‰¥\n0\n\\sigma\\in\\mathbb{R}_{\\geq 0}\nSmoothing parameter of contact resolution\nSection\nIV\nM\nâˆˆ\nâ„\n6\nÃ—\n6\nM\\in\\mathbb{R}^{6\\times 6}\nMass matrix\nSection\nIV\nQ\nâ€‹\n(\nq\n)\nâˆˆ\nâ„\n7\nÃ—\n6\nQ(q)\\in\\mathbb{R}^{7\\times 6}\nKinematic map\nSection\nIV\nÎ»\nn\nâˆˆ\nâ„\nâ‰¥\n0\n\\lambda_{\\mathrm{n}}\\in\\mathbb{R}_{\\geq 0}\nContact force magnitude\nSection\nIV\nÎ”\nâ€‹\nt\nâˆˆ\nâ„\nâ‰¥\n0\n\\Delta t\\in\\mathbb{R}_{\\geq 0}\nTime step\nSection\nIV\nH\nÏƒ\n,\nÏ„\nâ€‹\n(\nâ€¦\n)\nH_{\\sigma,\\tau}(\\dots)\nContact dynamics equality conditions\nSection\nIV\nG\nÏƒ\n,\nÏ„\nâ€‹\n(\nâ€¦\n)\nG_{\\sigma,\\tau}(\\dots)\nContact dynamics inequality conditions\nSection\nIV\nx\nr\nx_{\\mathrm{r}}\nReference state\nSection\nV\nx\nc\nx_{\\mathrm{c}}\nCompliant state\nSection\nV\nN\nâˆˆ\nâ„•\nN\\in\\mathbb{N}\nOptimization horizon\nSection\nV\nn\ns\nâˆˆ\nâ„•\nn_{\\mathrm{s}}\\in\\mathbb{N}\nNumber of scenarios\nSection\nV\nq\n^\n(\nl\n)\n\\hat{q}^{(l)}\nOffset pose for tracking\nSection\nV\nÎ´\n^\nâˆˆ\nâ„\nâ‰¥\n0\n\\hat{\\delta}\\in\\mathbb{R}_{\\geq 0}\nNorm of positional offset\nSection\nV\nn\nhom\nâˆˆ\nâ„•\nn_{\\mathrm{hom}}\\in\\mathbb{N}\nTotal number of homotopy iterations\nSection\nV\nII\nRelated Work\nWe split the discussion of related work into three parts, the first one on differentiable collision detection, the second one on differentiable physics simulation and the last one on planning and control methods that utilize these simulations to solve contact-rich tasks.\nII-A\nDifferentiable Collision Detection\nCollision detection in robotics is classically addressed by the Gilbert-Johnson-Keerthi algorithm (GJK)\n[\n13\n]\n, which determines a separation distance between two convex meshes, and the expanding polytope algorithm (EPA), which is an adapted GJK-variant for determining the penetration distance in case of collision. GJK originally solves the collision detection problem using a simplex method. Though this method exists since thirty years it is still frequently used in many physic engines\n[\n41\n,\n9\n]\n. Recent work has shown that the original GJK algorithm is a special case of the Frank-Wolfe algorithm, a first-order optimization method. By combining the Frank-Wolfe interpretation with acceleration methods for gradient descent optimization, a modern GJK implementation with improved efficiency has been developed in\n[\n31\n]\n.\nGiven a fast method for collision detection, derivatives can be approximately constructed by finite-differences or randomized smoothing\n[\n32\n]\n. This requires many evaluations of the nominal function and unavoidably results in noise on the derivatives which can only be decreased by using more evaluations which becomes computationally expensive. Additionally, the convergence of optimization procedures can be affected by derivative information that does not match the nominal function evaluation, which is the case since the nominal GJK solution is nonsmooth while the derivatives correspond to an implicitly constructed smoothed variant\n[\n37\n]\n.\nA second approach that closely resembles the method used in this paper, is interpreting collision detection as a convex quadratic or linear program. In this case, interior-point methods can be used to solve for signed distances. Interior-point methods solve a sequence of smoothed problems, where the solution to each smoothed problem becomes differentiable under mild assumptions\n[\n43\n,\n44\n]\n. For collision detection, this observation was used in conjunction with so-called growth distances\n[\n36\n]\n. The great benefit of this method is that it provides a smoothed nominal evaluation of the SDF and by application of the implicit function theorem to its optimality conditions also the corresponding exact first- and second-order derivatives.\nAlternatively, one can also use smooth approximations to the maximum operator such as the\nLogSumExp\nor\nsoftmax\noperator to obtain smooth analytic point-polytope distances\n[\n51\n]\n. In\n[\n32\n]\nthe\nsoftmax\napproach is extended to polytope-polytope distances by combining it with the GJK algorithm.\nII-B\nDifferentiable Physics Simulation\nTo solve the contact NCP, various approximation methods and accompanying solver choices have been introduced, each with the intention to enable a reliable and efficient solution of simulation steps. A structured overview and discussion is given in\n[\n25\n]\n. We focus in the following on work that aims at providing derivatives to these contact simulation approaches. To this end, we distinguish four approaches.\nIn the first case, a method for solving physics simulation steps is combined with finite-differencing or randomized smoothing to obtain derivatives for a nondifferentiable nominal evaluation model. As already discussed for the case of collision detection, this can be prohibitive for optimization approaches where precise convergence should be obtained since nominal function evaluations do not match to the determined derivatives. Even if the nominal problem would be smooth, derivatives obtained this way are only noisy approximations of the exact derivatives, which can harm convergence behavior. These derivatives can however be meaningful for reinforcement learning or model predictive control methods where the optimization procedure is not applied until convergence is achieved. The physics engine\nMuJoCo\n[\n41\n]\nprovides first-order derivatives by finite differencing. In\n[\n27\n]\nrandomized smoothing is utilized to differentiate through nonsmooth contact dynamics.\nAnother class of differentiable physics simulation methods solves for a nonsmooth simulation step and then differentiates with the current active set fixed. That is assuming active contact points remain active and contact points remain on current faces of the geometric shapes. In this case one has a locally smooth model for which exact derivatives can be obtained. This is done in\n[\n48\n]\nfor an LCP and in\n[\n26\n]\nfor the original NCP formulation. However, these derivatives do not contain information that switching the active set of contact points or active geometric surfaces could help to solve the underlying task, thus preventing the optimization solver from finding a descent direction. To this end,\n[\n48\n]\nproposes a heuristic to obtain what is referred to as complementarity-aware gradients, meaning derivatives that give information about a possible active set change. Apart from simple examples, it is unclear if such a philosophy can be used to solve complex problems.\nModern implementations of differentiable physics engines use the frameworks\nJAX\nand\nWarp\nto build computational graphs that are auto-differentiable and that can be efficiently evaluated on GPUs. For\nMuJoCo\n, accelerated versions using both frameworks are available and under active development. Differentiating the physic simulation steps of these simulators boils down to differentiating every operation of an iterative solver used to solve the collision detection and contact resolution problem. Thus, in this approach the computational cost for derivative evaluation is directly proportional to the computational cost of the simulation step calculation.\nThe fourth method to obtain a differentiable physics simulation is to determine a smooth approximation to the nominal NCP evaluation and then to determine the corresponding exact derivatives. This approach is proposed in\nDojo\n[\n16\n]\n, where a custom interior-point type solver is used to solve the NCP up to a given smoothing parameter.\nDojo\ndoes however not consider smoothing of the collision detection contribution. This approach is also used in this paper, whereby we put particular focus on obtaining a smoothing collision detection evaluation and to include it in the physics simulation model.\nII-C\nPlanning and Control for Contact-Rich Manipulation\nModel-based planning and control approaches can mostly be split into the three categories of sampling-based, reinforcement learning and optimal control methods. Where one can additionally differ between gradient-free reinforcement learning where no derivative information of the dynamic model is utilized and gradient-based reinforcement learning where such derivatives are used for policy optimization.\nImpressive results have been accomplished for bi- and quadruped locomotion as well as dexterous manipulation tasks such as pushing objects with robotic arms or in-hand reorientation of objects using actuated multi-finger hands. Without the usage of derivative information in sampling-based approaches\n[\n17\n,\n2\n]\nand gradient-free reinforcement learning\n[\n24\n,\n39\n,\n20\n]\n, as well as with usage of first-order derivatives in model-based reinforcement learning\n[\n50\n]\nand model predictive control methods\n[\n40\n,\n19\n,\n18\n,\n21\n]\n. Also combinations of sampling-based, RL and MPC methods are utilized to succeed in solving the mentioned tasks\n[\n23\n,\n37\n,\n29\n]\n.\nFor assembly planning, mainly work which utilizes sampling-based approaches and gradient-free reinforcement learning exists, illustrating the lack of work that utilizes differentiable physics simulations for this problem class. In\n[\n46\n,\n22\n]\nrobust peg assembly is achieved via gradient-free reinforcement learning under excessive use of simulation steps. In\n[\n49\n]\nsimilar problems are solved through random sampling of reference trajectories which are tracked by multiple domain randomized compliant trajectories through a Cartesian impedance law.\nTo randomize compliant trajectories, we use the domain randomization approach of\n[\n33\n]\n, which was originally utilized to robustify a controller for biped walking.\nIII\nSmooth Differentiable Collision Detection\nHere, we derive a modified variant of an established growth distance\n[\n36\n]\nthat ensures well-scaled contact-implicit optimal control problems. This growth distance is a signed distance formulation between convex polytopes. In Section\nIII-A\n, we state the nominal formulation and discuss its differentiability. In Section\nIII-B\n, we propose an approximation to the gradient of the SDF that will be used as contact normal vector for the contact resolution problem. In Section\nIII-C\n, we derive first- and second-order derivatives for the SDF and the corresponding contact normal vector and discuss their efficient implementation. In Section\nIII-D\n, we propose a heuristic approach to reliably solve the nominal problem by introducing scaled variants with the same solution that are solved if the numerical solver fails on the original problem.\nIII-A\nOptimization-based Collision Detection\nOur goal is to simulate the contact interactions of one actuated rigid object with another rigid object fixed in the environment. This emulates assembling one object onto another on a fixed position, a common process in automated industrial production lines. To this end, the actuated object consists of\nn\nact\nâˆˆ\nâ„•\nn_{\\mathrm{act}}\\in\\mathbb{N}\npolytopes and the environment consists of\nn\nenv\nâˆˆ\nâ„•\nn_{\\mathrm{env}}\\in\\mathbb{N}\npolytopes, cf. Figure\n2\n. The three-dimensional polytopes are represented in a halfspace representation given by\nğ’«\ni\n=\n{\np\nâˆˆ\nâ„\n3\n|\nG\ni\nâ€‹\np\nâ‰¤\nh\ni\n}\n,\ni\n=\n1\n,\nâ€¦\n,\nn\nact\n+\nn\nenv\n,\n\\mathcal{P}_{i}=\\{p\\in\\mathbb{R}^{3}\\ |\\ G_{i}p\\leq h_{i}\\},\\quad i=1,\\dots,n_{\\mathrm{act}}+n_{\\mathrm{env}},\nwhere\nG\ni\nâˆˆ\nâ„\nn\nh\n,\ni\nÃ—\n3\nG_{i}\\in\\mathbb{R}^{n_{\\mathrm{h},i}\\times 3}\nand\nh\ni\nâˆˆ\nâ„\nn\nh\n,\ni\nh_{i}\\in\\mathbb{R}^{n_{\\mathrm{h},i}}\n. We make the following assumptions on the polytopes that are without loss of practical applicability.\nAssumption 1\n.\nLet\nğ’«\ni\n\\mathcal{P}_{i}\nbe bounded convex polytopes that have nonempty interior. Let the matrix\nG\ni\nG_{i}\nbe constructed such that its rows are vectors with norm unity. Let\nh\ni\n>\nğŸ\nh_{i}>\\bm{0}\n, i.e., the origin is contained in the interior of the polytopes.\nTo simulate the contact interactions between the actuated and environmental polytopes, we consider a set of relevant contact pairs\nÎ \nâŠ‚\n{\n(\ni\n,\nj\n)\nâˆ£\ni\n=\n1\n,\nâ€¦\n,\nn\nact\n,\nj\n=\nn\nact\n+\n1\n,\nâ€¦\n,\nn\nact\n+\nn\nenv\n}\n.\n\\Pi\\subset\\{(i,j)\\mid i=1,\\dots,n_{\\mathrm{act}},\\ j=n_{\\mathrm{act}}+1,\\dots,n_{\\mathrm{act}}+n_{\\mathrm{env}}\\}.\nFor each polytope, we associate positional offsets, namely\nÏ\ni\nâˆˆ\nâ„\n3\n\\rho_{i}\\in\\mathbb{R}^{3}\nfor the translational position and the unit quaternion\nÎ¾\ni\nâˆˆ\nâ„\n4\n\\xi_{i}\\in\\mathbb{R}^{4}\nfor the orientation. These offsets determine the position of the polytopes with respect to a parent coordinate frame. In case of the polytopes making up the environment this will be the world frame, in case of the actuated polytopes this is a frame defined by a common degree of freedom (DoF)\nq\n=\n(\nÏ\nd\n,\nÎ¾\nd\n)\nâˆˆ\nâ„\n7\nq=(\\rho_{\\mathrm{d}},\\xi_{\\mathrm{d}})\\in\\mathbb{R}^{7}\n, where\nÏ\nd\nâˆˆ\nâ„\n3\n\\rho_{\\mathrm{d}}\\in\\mathbb{R}^{3}\ncorresponds to the translational position and\nÎ¾\nd\nâˆˆ\nâ„\n4\n\\xi_{\\mathrm{d}}\\in\\mathbb{R}^{4}\ncorresponds to a unit quaternion orientation of the actuated object in the world frame.\nAssumption 2\n.\nLet the offsets\nÏ\ni\n\\rho_{i}\nand\nÎ¾\ni\n\\xi_{i}\nfor\ni\n=\n1\n,\nâ€¦\n,\nn\nact\ni=1,\\dots,n_{\\mathrm{act}}\nbe constructed such that\nÏ\nd\n\\rho_{\\mathrm{d}}\ncorresponds to the center of mass (CoM) of the actuated object.\nFigure 2\n:\nIllustration of the type of assembly problem addressed in this paper. For this specific example, we have\nn\nact\n=\n3\nn_{\\mathrm{act}}=3\nand\nn\nenv\n=\n2\nn_{\\mathrm{env}}=2\n.\nThe translational and rotational position of the actuated polytopes in the world frame is retained through\nÏ\nÂ¯\na\n,\ni\nâ€‹\n(\nq\n)\n\\displaystyle\\bar{\\rho}_{a,i}(q)\n=\nÏ\nd\n+\nR\nâ€‹\n(\nÎ¾\nd\n)\nâ€‹\nÏ\ni\n,\n\\displaystyle=\\rho_{\\mathrm{d}}+R(\\xi_{\\mathrm{d}})\\rho_{i},\nÎ¾\nÂ¯\na\n,\ni\nâ€‹\n(\nq\n)\n\\displaystyle\\bar{\\xi}_{a,i}(q)\n=\nÎ¾\nd\nâŠ—\nÎ¾\ni\n,\n\\displaystyle=\\xi_{\\mathrm{d}}\\otimes\\xi_{i},\nwhere\nR\nâ€‹\n(\nâ‹…\n)\nR(\\cdot)\nis the\n3\nÃ—\n3\n3\\times 3\nrotation matrix associated with an unit quaternion and\nâŠ—\n\\otimes\ndenotes quaternion multiplication. For the remainder of this section, we focus on a fixed distance pair\n(\ni\n,\nj\n)\nâˆˆ\nÎ \n(i,j)\\in\\Pi\n. We define the SDF for this pair by\nÎ¦\n0\nâ€‹\n(\nq\n)\n=\n\\displaystyle\\Phi_{0}(q)=\nmin\np\n,\nÎ±\n2\nâ€‹\nÎ±\n\\displaystyle\\underset{p,\\alpha}{\\mathrm{min}}\\quad 2\\alpha\\phantom{aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}\\hfil\\hfil\\hfil\\hfil\n(1)\ns\n.\nt\n.\n\\displaystyle\\mathmakebox[\\widthof{$\\underset{\\phantom{p,\\alpha}}{\\mathrm{min}}$}][c]{\\mathmakebox[\\widthof{$\\mathrm{min}$}][c]{\\mathrm{\\kern 1.00006pts.t.}}}\\quad\nG\ni\nâ€‹\nR\nâ€‹\n(\nÎ¾\nÂ¯\na\n,\ni\nâ€‹\n(\nq\n)\n)\nâŠ¤\nâ€‹\n(\np\nâˆ’\nÏ\nÂ¯\na\n,\ni\nâ€‹\n(\nq\n)\n)\n\\displaystyle G_{i}R(\\bar{\\xi}_{a,i}(q))^{\\top}(p-\\bar{\\rho}_{a,i}(q))\nâ‰¤\nh\ni\n+\nÎ±\nâ€‹\nğŸ\n,\n,\n\\displaystyle\\leq h_{i}+\\alpha\\bm{1},,\\hfil\\hfil\nG\nj\nâ€‹\nR\nâ€‹\n(\nÎ¾\ne\n,\nj\n)\nâŠ¤\nâ€‹\n(\np\nâˆ’\nÏ\ne\n,\nj\n)\n\\displaystyle G_{j}R(\\xi_{\\mathrm{e},j})^{\\top}(p-\\rho_{\\mathrm{e},j})\nâ‰¤\nh\nj\n+\nÎ±\nâ€‹\nğŸ\n,\n\\displaystyle\\leq h_{j}+\\alpha\\bm{1},\nwhere smoothed variants\nÎ¦\nÏ„\nâ€‹\n(\nq\n)\n\\Phi_{\\tau}(q)\nfor\nÏ„\n>\n0\n\\tau>0\nwill be introduced in the following. A similar formulation was originally devised in\n[\n36\n]\nand termed as growth distance as it determines the smallest scaling factor\nÎ±\nâˆˆ\nâ„\n\\alpha\\in\\mathbb{R}\nby which two polytopes have to be altered such that there is a common point\np\nâˆˆ\nâ„\n3\np\\in\\mathbb{R}^{3}\nin both scaled shapes. We note a slight but for our purposes crucial modification to previous work: instead of scaling the polytopes in a form-stable manner through multiplying\nÎ±\n\\alpha\nto the right-hand side of the halfspace representations (\nÎ±\nâ€‹\nh\ni\n\\alpha h_{i}\nand\nÎ±\nâ€‹\nh\nj\n\\alpha h_{j}\nas in\n[\n36\n]\n), we apply a uniform scaling in all directions through the term\nÎ±\nâ€‹\nğŸ\n\\alpha\\bm{1}\n. This proved to be useful to retain well-scaled optimization problems when this SDF is used within contact-implicit optimal control. Additionally, a factor of two is introduced into the cost function in (\n1\n) to obtain a more accurate approximation of the corresponding Euclidean distance. This factor is necessary because the scaling is applied to both polytopes.\nWe construct a simple point-polytope distance in two dimensions based on the above introduced signed distance function that will be used for visualization purposes.\nExample 1\n.\nLet\nÏ\n2\nâ€‹\nd\nâˆˆ\nâ„\n2\n\\rho^{\\mathrm{2d}}\\in\\mathbb{R}^{2}\n,\nG\n2\nâ€‹\nd\nâˆˆ\nâ„\nn\nh\nÃ—\n2\nG^{\\mathrm{2d}}\\in\\mathbb{R}^{n_{\\mathrm{h}}\\times 2}\n,\nh\n2\nâ€‹\nd\nâˆˆ\nâ„\nn\nh\nh^{\\mathrm{2d}}\\in\\mathbb{R}^{n_{\\mathrm{h}}}\n. By transferring formulation (\n1\n) to compute the distance of\nÏ\n2\nâ€‹\nd\n\\rho^{\\mathrm{2d}}\nand the fixed polytope\nğ’«\n2\nâ€‹\nd\n=\n{\np\n2\nâ€‹\nd\nâˆˆ\nâ„\n2\n|\nG\n2\nâ€‹\nd\nâ€‹\np\n2\nâ€‹\nd\nâ‰¤\nh\n2\nâ€‹\nd\n}\n\\mathcal{P}^{\\mathrm{2d}}=\\{p^{\\mathrm{2d}}\\in\\mathbb{R}^{2}\\ |\\ G^{\\mathrm{2d}}p^{\\mathrm{2d}}\\leq h^{\\mathrm{2d}}\\}\n, we obtain the formulation\nÎ¦\n0\n2\nâ€‹\nd\nâ€‹\n(\nÏ\n2\nâ€‹\nd\n)\n=\n\\displaystyle\\Phi^{\\mathrm{2d}}_{0}(\\rho^{\\mathrm{2d}})=~\nmin\np\n2\nâ€‹\nd\n,\nÎ±\nÎ±\n\\displaystyle\\underset{p^{\\mathrm{2d}},\\alpha}{\\mathrm{min}}\\quad\\alpha\\phantom{aaaaaaaaaa}\ns\n.\nt\n.\n\\displaystyle\\mathmakebox[\\widthof{$\\underset{\\phantom{p^{\\mathrm{2d}},\\alpha}}{\\mathrm{min}}$}][c]{\\mathmakebox[\\widthof{$\\mathrm{min}$}][c]{\\mathrm{\\kern 1.00006pts.t.}}}\\quad\np\n2\nâ€‹\nd\n=\nÏ\n2\nâ€‹\nd\n,\n,\n\\displaystyle p^{\\mathrm{2d}}=\\rho^{\\mathrm{2d}},,\nG\n2\nâ€‹\nd\nâ€‹\np\n2\nâ€‹\nd\n\\displaystyle G^{\\mathrm{2d}}p^{\\mathrm{2d}}\nâ‰¤\nh\n2\nâ€‹\nd\n+\nÎ±\nâ€‹\nğŸ\n.\n\\displaystyle\\leq h^{\\mathrm{2d}}+\\alpha\\bm{1}.\nHere, no factor of two is introduced into the cost function since only one polytope is scaled. All following general derivations for\nÎ¦\n0\nâ€‹\n(\nq\n)\n\\Phi_{0}(q)\nmay be equivalently done for\nÎ¦\n0\n2\nâ€‹\nd\nâ€‹\n(\nÏ\n2\nâ€‹\nd\n)\n\\Phi^{\\mathrm{2d}}_{0}(\\rho^{\\mathrm{2d}})\n.\nFigure\n3\nshows different level lines for point-polytope distances with a two-dimensional cuboid. The Euclidean distance, the previously established growth distance\n[\n36\n]\nand our formulation are considered. The 0-level line coincides for all formulations but during the trajectory optimization process values larger and smaller than zero are also crucially relevant, thus, well-scaled distance formulations are desirable. Using Euclidean distances is the gold standard but signed Euclidean distances may be only formulated as nonconvex optimization problems\n[\n52\n]\n, making it challenging to efficiently solve these distance formulations. In contrast to previous work, the here proposed growth distance exactly matches the Euclidean distance for negative values and closely approximates it for positive values.\nNow, to calculate the SDF\nÎ¦\n0\nâ€‹\n(\nq\n)\n\\Phi_{0}(q)\n, we consider the Karush-Kuhn-Tucker (KKT) system of the corresponding LP (\n1\n). To this end, denote the number of inequality conditions by\nn\ng\n=\nn\nh\n,\ni\n+\nn\nh\n,\nj\nn_{\\mathrm{g}}=n_{\\mathrm{h},i}+n_{\\mathrm{h},j}\n. We then represent the inequality constraints in compact notation and define\nA\nâ€‹\n(\nq\n)\n=\n(\nG\ni\nâ€‹\nR\nâ€‹\n(\nÎ¾\nÂ¯\na\n,\ni\nâ€‹\n(\nq\n)\n)\nâŠ¤\nâˆ’\nğŸ\nG\nj\nâ€‹\nR\nâ€‹\n(\nÎ¾\ne\n,\nj\n)\nâŠ¤\nâˆ’\nğŸ\n)\nâˆˆ\nâ„\nn\ng\nÃ—\n3\nA(q)=\\begin{pmatrix}G_{i}R(\\bar{\\xi}_{a,i}(q))^{\\top}&-\\bm{1}\\\\\nG_{j}R(\\xi_{\\mathrm{e},j})^{\\top}&-\\bm{1}\\end{pmatrix}\\in\\mathbb{R}^{n_{\\mathrm{g}}\\times 3}\nand\nb\nâ€‹\n(\nq\n)\n=\n(\nh\ni\n+\nG\ni\nâ€‹\nR\nâ€‹\n(\nÎ¾\nÂ¯\na\n,\ni\nâ€‹\n(\nq\n)\n)\nâŠ¤\nâ€‹\nÏ\nÂ¯\na\n,\ni\nâ€‹\n(\nq\n)\nh\nj\n+\nG\nj\nâ€‹\nR\nâ€‹\n(\nÎ¾\ne\n,\nj\n)\nâŠ¤\nâ€‹\nÏ\ne\n,\nj\n)\nâˆˆ\nâ„\nn\ng\n.\nb(q)=\\begin{pmatrix}h_{i}+G_{i}R(\\bar{\\xi}_{a,i}(q))^{\\top}\\bar{\\rho}_{a,i}(q)\\\\\nh_{j}+G_{j}R(\\xi_{\\mathrm{e},j})^{\\top}\\rho_{\\mathrm{e},j}\\end{pmatrix}\\in\\mathbb{R}^{n_{\\mathrm{g}}}.\nDenoting the primal variables by\nz\n=\n(\np\n,\nÎ±\n)\nâˆˆ\nâ„\n4\nz=(p,\\alpha)\\in\\mathbb{R}^{4}\n, the dual variables by\nÎ»\nâˆˆ\nâ„\nn\ng\n\\lambda\\in\\mathbb{R}^{n_{\\mathrm{g}}}\nand the combined primal-dual variables as\nÎ³\n=\n(\nz\n,\nÎ»\n)\nâˆˆ\nâ„\n4\n+\nn\ng\n\\gamma=(z,\\lambda)\\in\\mathbb{R}^{4+n_{\\mathrm{g}}}\n, solving the problem corresponds to solving the KKT system for\nÏ„\n=\n0\n\\tau=0\nwhich is given by\nF\nÏ„\nâ€‹\n(\nÎ³\n,\nq\n)\n=\n(\nc\n+\nA\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\nÎ»\nÎ›\nâ€‹\n(\nb\nâ€‹\n(\nq\n)\nâˆ’\nA\nâ€‹\n(\nq\n)\nâ€‹\nz\n)\nâˆ’\nğŸ\nâ€‹\nÏ„\n)\n=\n0\n,\nF_{\\tau}(\\gamma,q)=\\begin{pmatrix}c+A(q)^{\\top}\\lambda\\\\\n\\Lambda(b(q)-A(q)z)-\\bm{1}\\tau\\end{pmatrix}=0,\n(2)\nunder the additional constraints\nÎ»\nâ‰¥\n0\n,\nb\nâ€‹\n(\nq\n)\nâˆ’\nA\nâ€‹\n(\nq\n)\nâ€‹\nz\nâ‰¥\n0\n.\n\\lambda\\geq 0,\\ b(q)-A(q)z\\geq 0.\n(3)\nHere\nÎ›\n=\ndiag\nâ€‹\n(\nÎ»\n)\n\\Lambda=\\mathrm{diag}(\\lambda)\nis the diagonal matrix constructed from\nÎ»\n\\lambda\nand\nc\n=\n(\nğŸ\n,\n2\n)\nc=(\\bm{0},2)\nis the cost vector for (\n1\n). Interior-point methods solve (\n2\n) by applying Newton steps to the system of equations starting with a large\nÏ„\nâ‰«\n0\n\\tau\\gg 0\nand then consecutively decreasing this value until a solution for the exact system with\nÏ„\n=\n0\n\\tau=0\nis found up to a user-defined tolerance. However, solving the problem exactly makes the distance definition nondifferentiable. In\n[\n10\n]\nit was shown that under\nAssumption\n1\nsolving the KKT system up to any\nÏ„\n>\n0\n\\tau>0\nensures existence of a unique primal-dual solution\nÎ³\n\\gamma\n. This allows one to apply the implicit function theorem to (\n2\n) to obtain corresponding derivatives of arbitrary order.\nFigure 3\n:\nThe {1,0,-0.4}-level lines for different optimization-based distance formulations for the distance between a point and the gray cuboid. Previous work refers to\n[\n36\n,\n43\n]\n. The 0-level lines coincide for all distance formulations.\nWe therefore introduce the notation\nz\nÏ„\nâ€‹\n(\nq\n)\n=\n(\np\nÏ„\nâ€‹\n(\nq\n)\n,\nÎ±\nÏ„\nâ€‹\n(\nq\n)\n)\nz_{\\tau}(q)=(p_{\\tau}(q),\\alpha_{\\tau}(q))\nand further\nÎ³\nÏ„\nâ€‹\n(\nq\n)\n=\n(\nz\nÏ„\nâ€‹\n(\nq\n)\n,\nÎ»\nÏ„\nâ€‹\n(\nq\n)\n)\n\\gamma_{\\tau}(q)=(z_{\\tau}(q),\\lambda_{\\tau}(q))\nfor the unique primal-dual solution of (\n2\n) and (\n3\n) for given\nÏ„\n>\n0\n\\tau>0\nand\nq\nq\n. This enables the following definition of a smooth SDF approximation given by\nÎ¦\nÏ„\nâ€‹\n(\nq\n)\n=\nÎ±\nÏ„\nâ€‹\n(\nq\n)\n.\n\\Phi_{\\tau}(q)=\\alpha_{\\tau}(q).\n(4)\nThis SDF approximation has the following properties.\nProposition 1\n.\nLet Assumption 1 hold. Then the SDF approximation\nÎ¦\nÏ„\nâ€‹\n(\nq\n)\n\\Phi_{\\tau}(q)\nfor\nÏ„\n>\n0\n\\tau>0\nis a well-defined infinitely differentiable function. For\nÏ„\nâ†’\n0\n\\tau\\rightarrow 0\n, the smooth SDF\nÎ¦\nÏ„\nâ€‹\n(\nq\n)\n\\Phi_{\\tau}(q)\nconverges to the nonsmooth SDF\nÎ¦\n0\nâ€‹\n(\nq\n)\n\\Phi_{0}(q)\n. It holds\nÎ¦\nÏ„\nâ€‹\n(\nq\n)\nâ‰¥\nÎ¦\n0\nâ€‹\n(\nq\n)\n\\Phi_{\\tau}(q)\\geq\\Phi_{0}(q)\n.\nTo show this, one can adapt the proof of\n[\n10\n]\nto the three-dimensional case and the proposed SDF modification. The key requirement is to ensure that\nA\nâ€‹\n(\nq\n)\nA(q)\nhas rank three which is the case for polytopes with nonempty interior.\nThe characteristic that the considered SDF approximation is an upper bound for the exact signed distance is crucial, as this ensures that the feasible space of configurations is not decreased. Thus, we have\n{\nq\nâˆˆ\nâ„\nn\nq\nâˆ£\nÎ¦\n0\nâ€‹\n(\nq\n)\nâ‰¥\n0\n}\nâŠ‚\n{\nq\nâˆˆ\nâ„\nn\nq\nâˆ£\nÎ¦\nÏ„\nâ€‹\n(\nq\n)\nâ‰¥\n0\n}\n.\n\\{q\\in\\mathbb{R}^{n_{\\mathrm{q}}}\\mid\\Phi_{0}(q)\\geq 0\\}\\subset\\{q\\in\\mathbb{R}^{n_{\\mathrm{q}}}\\mid\\Phi_{\\tau}(q)\\geq 0\\}.\nThis is of particular importance when considering assembly problems involving tight clearances, since for such problems the feasible configuration space is highly confined. Using a SDF approximation that underestimates the exact distance would then quickly lead to infeasible problem formulations, for which no valid solution trajectory exists.\nIII-B\nSDF Gradient Approximation\nFor physics simulation, one requires a contact normal vector for each touching contact pair that defines the direction in which contact forces act. Classically, one uses the gradient of the SDF\n[\n7\n]\n. However, since we aim to use second-order optimization methods together with the considered contact simulation formulation, defining the contact normal vector as the SDF gradient results in third-order derivatives of the SDF that have to be passed to the numerical solver in contact-implicit optimal control. Therefore, we propose an approximation to the gradient of the smooth SDF\nÎ¦\nÏ„\nâ€‹\n(\nq\n)\n\\Phi_{\\tau}(q)\nthat is a function of the primal-dual variables of the distance problem. Differentiating the dynamical system twice will then only result in the requirement of differentiating the primal-dual variables of the distance problem twice with respect to the object poses\nq\nq\n. The contact normal approximation is motivated by the following observation as discussed in\n[\n10\n]\n. Since the SDF (\n1\n) is a parametric LP in\nq\nq\n, we denote by\nZ\nÂ¯\n0\nâ€‹\n(\nq\n)\n\\bar{Z}_{0}(q)\nthe set of all primal optimal solutions and by\nÎ›\nÂ¯\n0\nâ€‹\n(\nq\n)\n\\bar{\\Lambda}_{0}(q)\nthe set of all corresponding dual optimal solutions. Whenever one of these sets is not a singleton set for a given\nq\nq\n, the SDF\nÎ¦\n0\nâ€‹\n(\nq\n)\n\\Phi_{0}(q)\nis nondifferentiable. Further, let\ng\nâ€‹\n(\nz\n,\nq\n)\n=\nA\nâ€‹\n(\nq\n)\nâ€‹\nz\nâˆ’\nb\nâ€‹\n(\nq\n)\ng(z,q)=A(q)z-b(q)\ncompactly capture the inequality constraints of the distance problem (\n1\n). Now directional derivatives for the nonsmooth SDF\nÎ¦\n0\nâ€‹\n(\nq\n)\n\\Phi_{0}(q)\nare given by\nlim\nh\nâ†’\n0\nÎ¦\n0\nâ€‹\n(\nq\n+\nh\nâ€‹\nd\n)\nâˆ’\nÎ¦\n0\nâ€‹\n(\nq\n)\nh\nâ€‹\nâ€–\nd\nâ€–\n=\nmin\nz\nâˆˆ\nZ\nÂ¯\n0\nâ€‹\n(\nq\n)\nâ¡\nmax\nÎ»\nâˆˆ\nÎ›\nÂ¯\n0\nâ€‹\n(\nq\n)\nâ¡\nd\nâŠ¤\nâ€‹\nâˆ‚\nq\ng\nâ€‹\n(\nz\n,\nq\n)\nâŠ¤\nâ€‹\nÎ»\n,\n\\lim_{h\\rightarrow 0}\\frac{\\Phi_{0}(q+hd)-\\Phi_{0}(q)}{h\\|d\\|}=\\min_{z\\in\\bar{Z}_{0}(q)}\\max_{\\lambda\\in\\bar{\\Lambda}_{0}(q)}d^{\\top}\\partial_{q}g(z,q)^{\\top}\\lambda,\n(5)\nfor direction\nd\nâˆˆ\nâ„\nn\nq\nd\\in\\mathbb{R}^{n_{q}}\n, see\n[\n15\n]\n. This motivates us to define the gradient approximation for the smooth SDF as\nn\nÏ„\nâ€‹\n(\nÎ³\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\n=\nâˆ‚\nq\ng\nâ€‹\n(\nz\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\nâŠ¤\nâ€‹\nÎ»\nÏ„\nâ€‹\n(\nq\n)\n.\nn_{\\tau}(\\gamma_{\\tau}(q),q)=\\partial_{q}g(z_{\\tau}(q),q)^{\\top}\\lambda_{\\tau}(q).\n(6)\nIn compact form we also write\nn\nÏ„\nâ€‹\n(\nq\n)\nâ‰”\nn\nÏ„\nâ€‹\n(\nÎ³\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\nn_{\\tau}(q)\\coloneqq n_{\\tau}(\\gamma_{\\tau}(q),q)\n.\nThis gradient approximation naturally has the property that whenever\nâˆ‡\nq\nÎ¦\n0\nâ€‹\n(\nq\n)\n\\nabla_{q}\\Phi_{0}(q)\nclassically exists, i.e.,\nZ\nÂ¯\n0\nâ€‹\n(\nq\n)\n\\bar{Z}_{0}(q)\nand\nÎ›\nÂ¯\n0\nâ€‹\n(\nq\n)\n\\bar{\\Lambda}_{0}(q)\nare singletons, then\nn\nÏ„\nâ€‹\n(\nq\n)\nn_{\\tau}(q)\nconverges to\nâˆ‡\nq\nÎ¦\n0\nâ€‹\n(\nq\n)\n\\nabla_{q}\\Phi_{0}(q)\nfor\nÏ„\nâ†’\n0\n\\tau\\rightarrow 0\n. This is illustrated in Figure\n4\nfor the two-dimensional point-polytope distance that was already considered in Figure\n3\n. One can observe that\nn\nÏ„\nâ€‹\n(\nq\n)\nn_{\\tau}(q)\nis generally a close approximation of\nâˆ‡\nq\nÎ¦\n0\nâ€‹\n(\nq\n)\n\\nabla_{q}\\Phi_{0}(q)\nthat can be made arbitrarily accurate for\nÏ„\nâ†’\n0\n\\tau\\rightarrow 0\n. Furthermore, the exact and approximate gradient attain norm unity for\nÏ„\nâ†’\n0\n\\tau\\rightarrow 0\n, which ensures the well-scaledness of the optimization problems in which the gradient approximation will be utilized, as already mentioned in Section\nIII-A\n. If one would use the growth distance formulation introduced in previous work\n[\n36\n,\n43\n]\n(the orange level lines in Figure\n3\n), one would obtain exact and approximate gradients with varying norms depending on the shape of the considered polytopes.\nIf the primal or dual optimal set is not a singleton, an interior-point method converges to the primal-dual solution corresponding to the analytic center of these sets\n[\n6\n]\n. Consequentially,\nn\nÏ„\nâ€‹\n(\nq\n)\nn_{\\tau}(q)\nthen converges to the subgradient for this particular primal-dual solution.\nRemark 1\n.\nThe considered SDF gradient approximation can also be interpreted as the exact gradient for the objective value of the associated barrier problem to the distance LP (\n1\n). I.e., consider the barrier function\nB\nÏ„\nâ€‹\n(\nz\n,\nq\n)\n=\nc\nâŠ¤\nâ€‹\nz\nâˆ’\nÏ„\nâ€‹\nâˆ‘\ni\n=\n1\nn\ng\nlog\nâ¡\n(\nâˆ’\ng\ni\nâ€‹\n(\nz\n,\nq\n)\n)\n,\nB_{\\tau}(z,q)=c^{\\top}z-\\tau\\sum_{i=1}^{n_{\\mathrm{g}}}\\log(-g_{i}(z,q)),\nand define the alternative smooth SDF by\nÎ¦\n~\nÏ„\nâ€‹\n(\nq\n)\n\\displaystyle\\tilde{\\Phi}_{\\tau}(q)\n=\nmin\nz\nâ¡\nB\nÏ„\nâ€‹\n(\nz\n,\nq\n)\n\\displaystyle=\\min_{z}B_{\\tau}(z,q)\n(7)\n=\nB\nÏ„\nâ€‹\n(\nz\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\n,\n\\displaystyle=B_{\\tau}(z_{\\tau}(q),q),\nwhere the second equality follows from the definitions made in Section\nIII-A\nsince (\n2\n) and (\n3\n) denote the optimality conditions of the barrier problem. One can check that now it holds\nâˆ‡\nq\nÎ¦\n~\nÏ„\nâ€‹\n(\nq\n)\n=\nn\nÏ„\nâ€‹\n(\nq\n)\n,\n\\displaystyle\\nabla_{q}\\tilde{\\Phi}_{\\tau}(q)=n_{\\tau}(q),\nsince we have by the chain rule\nD\nq\nâ€‹\nÎ¦\n~\nÏ„\nâ€‹\n(\nq\n)\n\\displaystyle\\mathrm{D}_{q}\\tilde{\\Phi}_{\\tau}(q)\n=\nâˆ‚\nq\nB\nÏ„\nâ€‹\n(\nz\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\n+\nâˆ‚\nz\nB\nÏ„\nâ€‹\n(\nz\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\nâ€‹\nD\nq\nâ€‹\nz\nÏ„\nâ€‹\n(\nq\n)\n\\displaystyle=\\partial_{q}B_{\\tau}(z_{\\tau}(q),q)+\\partial_{z}B_{\\tau}(z_{\\tau}(q),q)\\mathrm{D}_{q}z_{\\tau}(q)\n=\nâˆ‚\nq\nB\nÏ„\nâ€‹\n(\nz\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\n,\n\\displaystyle=\\partial_{q}B_{\\tau}(z_{\\tau}(q),q),\nand the second equality follows since due to optimality of\nz\nÏ„\nâ€‹\n(\nq\n)\nz_{\\tau}(q)\nfor (\n7\n) it holds\nâˆ‚\nz\nB\nÏ„\nâ€‹\n(\nz\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\n=\n0\n\\partial_{z}B_{\\tau}(z_{\\tau}(q),q)=0\n. By evaluating the partial derivative of the barrier function one then obtains\nâˆ‚\nq\nB\nÏ„\nâ€‹\n(\nz\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\n\\displaystyle\\partial_{q}B_{\\tau}(z_{\\tau}(q),q)\n=\nÎ»\nÏ„\nâ€‹\n(\nq\n)\nâ€‹\nâˆ‚\nq\ng\nâ€‹\n(\nz\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\n\\displaystyle=\\lambda_{\\tau}(q)\\partial_{q}g(z_{\\tau}(q),q)\n=\nn\nÏ„\nâ€‹\n(\nq\n)\nâŠ¤\n.\n\\displaystyle=n_{\\tau}(q)^{\\top}.\nFigure 4\n:\nExact gradients\nâˆ‡\nÏ\nÎ¦\nÏ„\nâ€‹\n(\nÏ\n)\n\\nabla_{\\rho}\\Phi_{\\tau}(\\rho)\nand the proposed gradient approximation\nn\nÏ„\nâ€‹\n(\nÏ\n)\nn_{\\tau}(\\rho)\nfor a point-polytope distance in two dimensions. Four different values of\nÏ„\n\\tau\nare considered, the behavior that for\nÏ„\nâ†’\n0\n\\tau\\rightarrow 0\nthe approximation converges to the exact gradient can be observed.\nIII-C\nFirst- and Second-Order Derivatives of Collision Detection\nIn this section first- and second-order derivatives for the SDF\nÎ¦\nÏ„\nâ€‹\n(\nq\n)\n\\Phi_{\\tau}(q)\nand the corresponding contact normal vector\nn\nÏ„\nâ€‹\n(\nq\n)\nn_{\\tau}(q)\nare derived. We analytically compute these derivatives to guarantee a high-performance implementation that utilizes problem structures efficiently. To this end, we define the contact information function\nw\nÏ„\nâ€‹\n(\nÎ³\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\n=\n(\nÎ±\nÏ„\nâ€‹\n(\nq\n)\nn\nÏ„\nâ€‹\n(\nÎ³\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\n)\nâˆˆ\nâ„\nn\nq\n+\n1\n.\nw_{\\tau}(\\gamma_{\\tau}(q),q)=\\begin{pmatrix}\\alpha_{\\tau}(q)\\\\\nn_{\\tau}(\\gamma_{\\tau}(q),q)\\end{pmatrix}\\in\\mathbb{R}^{n_{\\mathrm{q}}+1}.\n(8)\nThis function contains all the contact information that will be used in the contact-rich dynamical system. In the following we drop the arguments and subscripts for the functions\nw\nÏ„\nâ€‹\n(\nÎ³\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\nw_{\\tau}(\\gamma_{\\tau}(q),q)\nand\nF\nÏ„\nâ€‹\n(\nÎ³\n,\nq\n)\nF_{\\tau}(\\gamma,q)\nfor improved readability. We need to provide the Jacobian\nD\nq\nâ€‹\nw\n\\mathrm{D}_{q}w\nand the directional Hessian\nâŸ¨\ns\nw\n,\nD\nq\n,\nq\n2\nâ€‹\nw\nâŸ©\n\\langle s_{\\mathrm{w}}\\,,\\,\\mathrm{D}^{2}_{q,q}w\\rangle\n, for a seed\ns\nw\nâˆˆ\nâ„\nn\nq\n+\n1\ns_{\\mathrm{w}}\\in\\mathbb{R}^{n_{\\mathrm{q}}+1}\n, which are used by Newton-based numerical optimization solvers.\nFor the Jacobian of (\n8\n) we have by the chain rule\nD\nq\nâ€‹\nw\n=\nâˆ‚\nÎ³\nw\nâ€‹\nD\nq\nâ€‹\nÎ³\n+\nâˆ‚\nq\nw\n.\n\\mathrm{D}_{q}w=\\partial_{\\gamma}w\\,\\mathrm{D}_{q}\\gamma+\\partial_{q}w.\n(9)\nThe Jacobian of the primal-dual variables\nD\nq\nâ€‹\nÎ³\n\\mathrm{D}_{q}\\gamma\nis obtained from the implicit function theorem (IFT) by solving the linear system\nâˆ‚\nÎ³\nF\nâ€‹\nD\nq\nâ€‹\nÎ³\n=\nâˆ’\nâˆ‚\nq\nF\n,\n\\partial_{\\gamma}F\\,\\mathrm{D}_{q}\\gamma=-\\partial_{q}F,\n(10)\nwhere the invertibility of\nâˆ‚\nÎ³\nF\n\\partial_{\\gamma}F\nis directly ensured by the uniqueness of\nÎ³\nÏ„\nâ€‹\n(\nq\n)\n\\gamma_{\\tau}(q)\n, i.e., a rank deficient\nâˆ‚\nÎ³\nF\n\\partial_{\\gamma}F\nwould imply a nonunqiue primal-dual solution.\nTo obtain directional second-derivatives of (\n8\n), we need to differentiate\ns\nw\nâŠ¤\nâ€‹\nw\ns_{\\mathrm{w}}^{\\top}w\ntwice w.r.t.\nq\nq\n. To this end, we first obtain the Jacobian of\ns\nw\nâŠ¤\nâ€‹\nw\ns_{\\mathrm{w}}^{\\top}w\nby multiplying (\n10\n) with the seed\ns\nw\ns_{\\mathrm{w}}\nand obtain\ns\nw\nâŠ¤\nâ€‹\nD\nq\nâ€‹\nw\n=\ns\nw\nâŠ¤\nâ€‹\nâˆ‚\nÎ³\nw\nâ€‹\nD\nq\nâ€‹\nÎ³\n+\ns\nw\nâŠ¤\nâ€‹\nâˆ‚\nq\nw\n.\ns_{\\mathrm{w}}^{\\top}\\mathrm{D}_{q}w=s_{\\mathrm{w}}^{\\top}\\partial_{\\gamma}w\\,\\mathrm{D}_{q}\\gamma+s_{\\mathrm{w}}^{\\top}\\partial_{q}w.\nDifferentiating a second time with respect to\nq\nq\nusing the chain rule results in\nâŸ¨\ns\nw\n,\nD\nq\n,\nq\n2\nâ€‹\nw\nâŸ©\n=\nâŸ¨\ns\nw\n,\nâˆ‚\nq\n,\nq\n2\nw\nâŸ©\n+\nâŸ¨\ns\nw\n,\nâˆ‚\nq\n,\nÎ³\n2\nw\nâŸ©\nâ€‹\nD\nq\nâ€‹\nÎ³\n+\nD\nq\nâ€‹\nÎ³\nâŠ¤\nâ€‹\nâŸ¨\ns\nw\n,\nâˆ‚\nÎ³\n,\nq\n2\nw\nâŸ©\n+\nD\nq\nâ€‹\nÎ³\nâŠ¤\nâ€‹\nâŸ¨\ns\nw\n,\nâˆ‚\nÎ³\n,\nÎ³\n2\nw\nâŸ©\nâ€‹\nD\nq\nâ€‹\nÎ³\n+\nâŸ¨\ns\nÎ³\n,\nD\nq\n,\nq\n2\nâ€‹\nÎ³\nâŸ©\n,\n\\begin{split}\\langle s_{\\mathrm{w}}\\,,\\,\\mathrm{D}^{2}_{q,q}w\\rangle&=\\langle s_{\\mathrm{w}}\\,,\\,\\partial^{2}_{q,q}w\\rangle\\\\\n&+\\langle s_{\\mathrm{w}}\\,,\\,\\partial^{2}_{q,\\gamma}w\\rangle\\mathrm{D}_{q}\\gamma\\\\\n&+\\mathrm{D}_{q}\\gamma^{\\top}\\langle s_{\\mathrm{w}}\\,,\\,\\partial^{2}_{\\gamma,q}w\\rangle\\\\\n&+\\mathrm{D}_{q}\\gamma^{\\top}\\langle s_{\\mathrm{w}}\\,,\\,\\partial^{2}_{\\gamma,\\gamma}w\\rangle\\mathrm{D}_{q}\\gamma\\\\\n&+\\langle s_{\\gamma}\\,,\\,\\mathrm{D}^{2}_{q,q}\\gamma\\rangle,\\end{split}\n(11)\nwhere we obtained a new seed\ns\nÎ³\nâˆˆ\nâ„\nn\nÎ³\ns_{\\mathrm{\\gamma}}\\in\\mathbb{R}^{n_{\\mathrm{\\gamma}}}\nas\ns\nÎ³\n=\nâˆ‚\nÎ³\nw\nâŠ¤\nâ€‹\ns\nw\n.\ns_{\\mathrm{\\gamma}}=\\partial_{\\gamma}w^{\\top}s_{\\mathrm{w}}.\nIt remains to determine the directional Hessian of the primal-dual variables\nâŸ¨\ns\nÎ³\n,\nD\nq\n,\nq\n2\nâ€‹\nÎ³\nâŸ©\n\\langle s_{\\gamma}\\,,\\,\\mathrm{D}^{2}_{q,q}\\gamma\\rangle\n. To this end, we interpret (\n10\n) as a parametric linear system and apply the IFT one more time. A detailed derivation is given in Appendix\nA\n. One then first solves the adjoint equation\nâˆ‚\nÎ³\nF\nâŠ¤\nâ€‹\nr\nÎ³\n=\nâˆ’\ns\nÎ³\n,\n\\partial_{\\gamma}F^{\\top}\\,r_{\\gamma}=-s_{\\gamma},\n(12)\nto obtain\nr\nÎ³\nâˆˆ\nâ„\nn\nÎ³\nr_{\\gamma}\\in\\mathbb{R}^{n_{\\mathrm{\\gamma}}}\n. Then we have\nâŸ¨\ns\nÎ³\n,\nD\nq\n,\nq\n2\nâ€‹\nÎ³\nâŸ©\n=\nâŸ¨\nr\nÎ³\n,\nâˆ‚\nq\n,\nq\n2\nF\nâŸ©\n+\nâŸ¨\nr\nÎ³\n,\nâˆ‚\nq\n,\nÎ³\n2\nF\nâŸ©\nâ€‹\nD\nq\nâ€‹\nÎ³\n+\nD\nq\nâ€‹\nÎ³\nâŠ¤\nâ€‹\nâŸ¨\nr\nÎ³\n,\nâˆ‚\nÎ³\n,\nq\n2\nF\nâŸ©\n+\nD\nq\nâ€‹\nÎ³\nâŠ¤\nâ€‹\nâŸ¨\nr\nÎ³\n,\nâˆ‚\nÎ³\n,\nÎ³\n2\nF\nâŸ©\nâ€‹\nD\nq\nâ€‹\nÎ³\n.\n\\begin{split}\\langle s_{\\gamma}\\,,\\,\\mathrm{D}^{2}_{q,q}\\gamma\\rangle&=\\langle r_{\\gamma}\\,,\\,\\partial^{2}_{q,q}F\\rangle\\\\\n&+\\langle r_{\\gamma}\\,,\\,\\partial^{2}_{q,\\gamma}F\\rangle\\mathrm{D}_{q}\\gamma\\\\\n&+\\mathrm{D}_{q}\\gamma^{\\top}\\langle r_{\\gamma}\\,,\\,\\partial^{2}_{\\gamma,q}F\\rangle\\\\\n&+\\mathrm{D}_{q}\\gamma^{\\top}\\langle r_{\\gamma}\\,,\\,\\partial^{2}_{\\gamma,\\gamma}F\\rangle\\mathrm{D}_{q}\\gamma.\\end{split}\n(13)\nTo obtain a highly efficient implementation, many quantities evaluated during construction of first-order derivatives in (\n9\n) and (\n10\n) can be reused for the construction of second-order derivatives in (\n11\n)-(\n13\n). Notably, (\n10\n) is solved through the construction of a LU decomposition and subsequent backsolving where the LU decomposition is then reused for (\n12\n).\nFurthermore, we notice the following relation between the contact normal vector and the KKT system. For the selection vector\ns\ns\n=\n(\nğŸ\n,\nğŸ\n)\ns_{\\mathrm{s}}=(\\bm{0},\\bm{1})\n, we have\nn\nÏ„\nâ€‹\n(\nÎ³\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\n=\nâˆ’\nâˆ‚\nq\nF\nÏ„\nâ€‹\n(\nÎ³\nÏ„\nâ€‹\n(\nq\n)\n,\nq\n)\nâŠ¤\nâ€‹\ns\ns\n.\nn_{\\tau}(\\gamma_{\\tau}(q),q)=-\\partial_{q}F_{\\tau}(\\gamma_{\\tau}(q),q)^{\\top}s_{\\mathrm{s}}.\nThus, when dividing contact information evaluation in three phases: nominal, first derivative and second derivative evaluation, some derivatives of\nF\nF\nwith respect to\nq\nq\nnaturally have already been evaluated in the preceding phase.\nIII-D\nReliable solutions for the distance problems\nTo obtain solutions to the distance problem (\n1\n), we utilize the high-performance interior-point solver\nHPIPM\n[\n11\n]\n, which supports the option to solve the problem only up to a fixed barrier parameter\nÏ„\n>\n0\n\\tau>0\n. However, in rare cases the solver may fail to converge to a solution of (\n1\n), as it may run into a primal-dual pair where the KKT matrix becomes ill-conditioned. To ensure that correct contact information can always be passed to the OCP solver, we construct scaled variants of (\n1\n) from which the solution of the original problem can be retained. The process is as follows.\nWe determine uniformly drawn random vectors\nÎ¶\nl\nâˆ¼\nğ’°\nâ€‹\n[\nÎº\nmin\n,\nÎº\nmax\n]\nn\ng\n\\zeta_{l}\\sim\\mathcal{U}[\\kappa_{\\mathrm{min}},\\kappa_{\\mathrm{max}}]^{n_{\\mathrm{g}}}\nfor\nl\n=\n1\n,\nâ€¦\n,\nn\ntries\nl=1,\\dots,n_{\\mathrm{tries}}\nwith\nÎº\nmin\n,\nÎº\nmax\n>\n0\n\\kappa_{\\mathrm{min}},\\kappa_{\\mathrm{max}}>0\nand\nn\ntries\nâˆˆ\nâ„•\nn_{\\mathrm{tries}}\\in\\mathbb{N}\n, where we, e.g., use\nÎº\nmin\n=\n1\n,\nÎº\nmax\n=\n10\n\\kappa_{\\mathrm{min}}=1,\\kappa_{\\mathrm{max}}=10\nand\nn\ntries\n=\n20\nn_{\\mathrm{tries}}=20\n. After a failed solve attempt of (\n1\n), we switch instead to the problem\nmin\nğ‘§\nc\nâŠ¤\nâ€‹\nz\n\\displaystyle\\underset{z}{\\mathrm{min}}\\quad c^{\\top}z\\hfil\\hfil\\hfil\\hfil\n(14)\ns\n.\nt\n.\n\\displaystyle\\mathmakebox[\\widthof{$\\underset{\\phantom{z}}{\\mathrm{min}}$}][c]{\\mathmakebox[\\widthof{$\\mathrm{min}$}][c]{\\mathrm{\\kern 1.00006pts.t.}}}\\quad\nA\n~\nâ€‹\n(\nq\n)\nâ€‹\nz\nâ‰¤\nb\n~\nâ€‹\n(\nq\n)\n,\n\\displaystyle\\widetilde{A}(q)z\\leq\\widetilde{b}(q),\nwhere\nA\n~\nâ€‹\n(\nq\n)\n=\ndiag\nâ€‹\n(\nÎ¶\nl\n)\nâ€‹\nA\nâ€‹\n(\nq\n)\n,\nb\n~\nâ€‹\n(\nq\n)\n=\ndiag\nâ€‹\n(\nÎ¶\nl\n)\nâ€‹\nb\nâ€‹\n(\nq\n)\n.\n\\widetilde{A}(q)=\\mathrm{diag}(\\zeta_{l})A(q),\\quad\\widetilde{b}(q)=\\mathrm{diag}(\\zeta_{l})b(q).\nThis definition implies that for\nÎ¶\nl\n=\nğŸ\n\\zeta_{l}=\\bm{1}\n, the original problem (\n1\n) is retained. Solving (\n14\n) results in various evolutions of iterates produced by the interior-point solver and, thus, enables converge to a solution if another evolution of iterates ended up in an ill-conditioned KKT matrix.\nA primal-dual solution\nÎ³\n~\n=\n(\nz\n~\n,\nÎ»\n~\n)\n\\widetilde{\\gamma}=(\\widetilde{z},\\widetilde{\\lambda})\nof (\n14\n) up to the barrier parameter\nÏ„\n>\n0\n\\tau>0\nthen satisfies the perturbed KKT conditions analogous to (\n2\n) and (\n3\n) given by\n(\nc\n+\nA\n~\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\nÎ»\n~\nÎ›\nâ€‹\n(\nb\n~\nâ€‹\n(\nq\n)\nâˆ’\nA\n~\nâ€‹\n(\nq\n)\nâ€‹\nz\n~\n)\nâˆ’\nğŸ\nâ€‹\nÏ„\n)\n=\n0\n,\nÎ»\n~\nâ‰¥\n0\n,\nb\n~\nâ€‹\n(\nq\n)\nâˆ’\nA\n~\nâ€‹\n(\nq\n)\nâ€‹\nz\n~\nâ‰¥\n0\n.\n\\begin{split}\\begin{pmatrix}c+\\widetilde{A}(q)^{\\top}\\widetilde{\\lambda}\\\\\n\\Lambda(\\widetilde{b}(q)-\\widetilde{A}(q)\\widetilde{z})-\\bm{1}\\tau\\end{pmatrix}&=0,\\\\\n\\widetilde{\\lambda}\\geq 0,\\ \\widetilde{b}(q)-\\widetilde{A}(q)\\widetilde{z}&\\geq 0.\\end{split}\n(15)\nOne can then deduce, that if\nz\n~\n\\widetilde{z}\nand\nÎ»\n~\n\\widetilde{\\lambda}\nsatisfy (\n15\n), then\nz\n=\nz\n~\nz=\\widetilde{z}\nand\nÎ»\n=\ndiag\nâ€‹\n(\nÎ¶\nl\nâˆ’\n1\n)\nâ€‹\nÎ»\n~\n\\lambda=\\mathrm{diag}(\\zeta_{l}^{-1})\\widetilde{\\lambda}\nsatisfy (\n2\n) and (\n3\n), where\nÎ¶\nl\nâˆ’\n1\n=\n(\nÎ¶\nl\n,\n1\nâˆ’\n1\n,\nâ€¦\n,\nÎ¶\nl\n,\nn\nÎ»\nâˆ’\n1\n)\n\\zeta_{l}^{-1}=(\\zeta_{l,1}^{-1},\\dots,\\zeta_{l,n_{\\lambda}}^{-1})\n. In our case, we have to re-solve less than\n1\n%\n1\\%\nof the considered distance problems and always obtain a solution after a few attempts on scaled problems.\nIV\nDifferentiable Multi-Contact Physics\nWe formulate frictionless contact dynamics between rigid bodies with Cartesian coordinates. In Section\nIV-A\ncontinuous-time dynamics are stated and in Section\nIV-B\nthe corresponding discrete-time dynamics are derived by utilizing a common time-stepping scheme.\nIV-A\nContinuous-Time Contact Dynamics\nContinuous-time dynamics of frictionless contact-rich systems combine Newton-Euler equations with complementarity conditions for the determination of contact forces. Additionally, in continuous time, multi impact laws have to be considered that describe how system velocities jump if objects initially make contact. Choosing such a multi impact law is a modeling decision\n[\n7\n]\n. A dynamical system describing the motion of a single rigid body interacting with a static environment is given by\nq\nË™\n=\nQ\nâ€‹\n(\nq\n)\nâ€‹\nv\n,\n\\displaystyle\\dot{q}=Q(q)v,\n(16a)\nM\nâ€‹\nv\nË™\n=\nU\n+\nâˆ‘\n(\ni\n,\nj\n)\nâˆˆ\nÎ \nQ\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\nn\nÏ„\n(\ni\n,\nj\n)\nâ€‹\n(\nq\n)\nâ€‹\nÎ»\nn\n(\ni\n,\nj\n)\n,\n\\displaystyle M\\dot{v}=U+\\sum_{(i,j)\\in\\Pi}Q(q)^{\\top}n_{\\tau}^{(i,j)}(q)\\lambda_{\\mathrm{n}}^{(i,j)},\n(16b)\n0\nâ‰¤\nÎ¦\nÏ„\n(\ni\n,\nj\n)\nâ€‹\n(\nq\n)\nâŸ‚\nÎ»\nn\n(\ni\n,\nj\n)\nâ‰¥\n0\n,\n(\ni\n,\nj\n)\nâˆˆ\nÎ \n,\n\\displaystyle 0\\leq\\Phi_{\\tau}^{(i,j)}(q)\\ \\perp\\ \\lambda_{\\mathrm{n}}^{(i,j)}\\geq 0,\\quad(i,j)\\in\\Pi,\n(16c)\nMulti impact law.\n(16d)\nThe system velocity\nv\nâˆˆ\nâ„\nn\nv\nv\\in\\mathbb{R}^{n_{\\mathrm{v}}}\nis integrated into pose space through the kinematic map\nQ\nâ€‹\n(\nq\n)\nâˆˆ\nâ„\nn\nq\nÃ—\nn\nv\nQ(q)\\in\\mathbb{R}^{n_{\\mathrm{q}}\\times n_{\\mathrm{v}}}\n. It is required due to the presence of quaternion dynamics as quaternions are represented by four-dimensional vectors while the corresponding rotational velocity is given through a three-dimensional vector. The kinematic map is also used to project the contact normal vector to the velocity space. For its definition see,\ne.g.,\n[\n14\n]\n. Furthermore,\nM\nâˆˆ\nâ„\nn\nv\nÃ—\nn\nv\nM\\in\\mathbb{R}^{n_{\\mathrm{v}}\\times n_{\\mathrm{v}}}\nis the positive definite inertia matrix and\nU\nâˆˆ\nâ„\nn\nv\nU\\in\\mathbb{R}^{n_{\\mathrm{v}}}\ndenotes externally applied forces. The system state is denoted compactly by\nx\n=\n(\nq\n,\nv\n)\nx=(q,v)\n. The contact force magnitudes are denoted\nÎ»\nn\n(\ni\n,\nj\n)\nâˆˆ\nâ„\nâ‰¥\n0\n\\lambda_{\\mathrm{n}}^{(i,j)}\\in\\mathbb{R}_{\\geq 0}\n.\nIV-B\nDiscrete-Time Contact Dynamics\nDiscrete-time dynamics are derived by applying a time-stepping scheme to (\n16\n). For compact notation we define the contact normal mapped to velocity space according to (\n16b\n) as\nn\n~\nÏ„\n(\ni\n,\nj\n)\nâ€‹\n(\nq\n)\n=\nQ\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\nn\nÏ„\n(\ni\n,\nj\n)\nâ€‹\n(\nq\n)\nâˆˆ\nâ„\nn\nv\n.\n\\tilde{n}_{\\tau}^{(i,j)}(q)=Q(q)^{\\top}n_{\\tau}^{(i,j)}(q)\\in\\mathbb{R}^{n_{\\mathrm{v}}}.\nWe consider the common choice of an semi-implicit Euler time-stepping method. That is using an implicit Euler step on (\n16a\n), an explicit one on (\n16b\n) and an implicit evaluation of the algebraic equation (\n16c\n), whereby the SDF is linearized around the previous state. This scheme was originally introduced by Moreau\n[\n34\n]\nand corresponds to the optimality conditions of a convex quadratic program. The resulting discrete-time system for the time step\nÎ”\nâ€‹\nt\n>\n0\n\\Delta t>0\nis given by\nq\nk\n+\n1\n=\nq\nk\n+\nÎ”\nâ€‹\nt\nâ€‹\nQ\nâ€‹\n(\nq\nk\n+\n1\n)\nâ€‹\nv\nk\n+\n1\n,\n\\displaystyle q_{k+1}=q_{k}+\\Delta tQ(q_{k+1})v_{k+1},\n(17a)\nv\nk\n+\n1\n=\nv\nk\n+\nÎ”\nâ€‹\nt\nâ€‹\nM\nâˆ’\n1\nâ€‹\n(\nU\nk\n+\nâˆ‘\n(\ni\n,\nj\n)\nâˆˆ\nÎ \nn\n~\nÏ„\n(\ni\n,\nj\n)\nâ€‹\n(\nq\n~\nk\n)\nâ€‹\nÎ»\nn\n,\nk\n+\n1\n(\ni\n,\nj\n)\n)\n,\n\\displaystyle v_{k+1}=v_{k}+\\Delta tM^{-1}\\Big(U_{k}+\\sum_{(i,j)\\in\\Pi}\\tilde{n}_{\\tau}^{(i,j)}(\\tilde{q}_{k})\\lambda_{\\mathrm{n},k+1}^{(i,j)}\\Big),\n(17b)\n0\nâ‰¤\nÎ¦\nÏ„\n(\ni\n,\nj\n)\nâ€‹\n(\nq\n~\nk\n)\n+\nÎ”\nâ€‹\nt\nâ€‹\nn\n~\nÏ„\n(\ni\n,\nj\n)\nâ€‹\n(\nq\n~\nk\n)\nâŠ¤\nâ€‹\nv\nk\n+\n1\nâŸ‚\nÎ»\nn\n,\nk\n+\n1\n(\ni\n,\nj\n)\nâ‰¥\n0\n,\nâˆ€\n(\ni\n,\nj\n)\nâˆˆ\nÎ \n.\n\\displaystyle\\begin{split}&0\\leq\\Phi_{\\tau}^{(i,j)}(\\tilde{q}_{k})+\\Delta t\\tilde{n}_{\\tau}^{(i,j)}(\\tilde{q}_{k})^{\\top}v_{k+1}\\,\\\\\n&\\hskip 97.02399pt\\perp\\lambda_{\\mathrm{n},k+1}^{(i,j)}\\geq 0,\\quad\\forall(i,j)\\in\\Pi.\\end{split}\n(17c)\nWe introduce a slight modification of the pose given by\nq\nk\n=\n(\nÏ\nk\n,\nÎ¾\nk\n)\nq_{k}=(\\rho_{k},\\xi_{k})\nas we instead use\nq\n~\nk\n\\tilde{q}_{k}\nin (\n17\n) when evaluating the SDF and the contact normal. The modified pose is given by\nq\n~\nk\n=\n(\nÏ\nk\n,\nÎ¾\nk\nâ€–\nÎ¾\nk\nâ€–\n2\n)\n.\n\\tilde{q}_{k}=(\\rho_{k},\\frac{\\xi_{k}}{\\|\\xi_{k}\\|_{2}}).\nOn the one hand, due to the integration of quaternions in Euler space (\n17a\n) the quaternions will not maintain norm unity. This error can however be controlled by choosing a small enough\nÎ”\nâ€‹\nt\n\\Delta t\nand was not a main concern during our experiments. More importantly, since we will solve the system (\n17\n) within a trajectory optimization framework, the optimizer may use pose values in intermediate iterations that are not close to fulfilling (\n17\n) and we want to avoid evaluating the SDF implementation for quaternion values that are far from norm unity.\nDue to the complementarity conditions (\n17c\n), the solution of the time-stepping scheme can be nondifferentiable with respect to the previous position and velocity as well as the control input. In this paper, we take the approach of directly transcribing the system (\n17\n) into the optimal control problem. Thereby, the OCP solver will simultaneously solve for the optimal control input and the system dynamics. However, we still rely on relaxing the complementarity conditions to ensure a differentiable system. To this end, we utilize Scholtesâ€™ smoothing or relaxation\n[\n38\n]\n, which is a well-established method for complementarity condition relaxation and a choice particularly suitable for use in optimization applications\n[\n35\n]\n.\nBy compactly denoting the complementarity conditions (\n17c\n) by\n0\nâ‰¤\na\nl\nâŸ‚\nb\nl\nâ‰¥\n0\n,\nl\n=\n1\n,\nâ€¦\n,\n|\nÎ \n|\n,\n0\\leq a_{l}\\,\\perp\\,b_{l}\\geq 0,\\quad l=1,\\dots,|\\Pi|,\nScholtesâ€™ smoothing is given through the conditions\n0\nâ‰¤\na\nl\n,\n0\nâ‰¤\nb\nl\n,\na\nl\nâ€‹\nb\nl\n=\nÏƒ\n,\nl\n=\n1\n,\nâ€¦\n,\n|\nÎ \n|\n,\n0\\leq a_{l},\\ 0\\leq b_{l},\\ a_{l}b_{l}=\\sigma,\\quad l=1,\\dots,|\\Pi|,\nfor some\nÏƒ\n>\n0\n\\sigma>0\nand Scholtesâ€™ relaxation is given through\n0\nâ‰¤\na\nl\n,\n0\nâ‰¤\nb\nl\n,\na\nl\nâ€‹\nb\nl\nâ‰¤\nÏƒ\n,\nl\n=\n1\n,\nâ€¦\n,\n|\nÎ \n|\n.\n0\\leq a_{l},\\ 0\\leq b_{l},\\ a_{l}b_{l}\\leq\\sigma,\\quad l=1,\\dots,|\\Pi|.\nSince the system (\n17\n) corresponds to the optimality conditions of a convex quadratic problem, utilizing smoothing implied by interior-point methods is equivalent to applying Scholtesâ€™ smoothing to the LCP formulation. Scholtesâ€™ relaxation on the other hand, relaxes each complementarity condition individually, and, therefore, enables the OCP solver to use these additional degrees of freedom in the physics simulation to minimize the OCPâ€™s cost function. Using Scholtesâ€™ relaxation mirrors the idea of Todorov\n[\n42\n]\nto obtain contact-rich motions from trajectory optimization by first allowing contact forces at a distance that help to achieve the task goal and later aiming to optimize for control inputs such that the system attains positions where these contact forces become actually physical. Since system (\n17\n) in conjunction with Scholtesâ€™ smoothing/relaxation consists for any\nÏ„\n>\n0\n\\tau>0\nand\nÏƒ\n>\n0\n\\sigma>0\nof smooth functions, we can write (\n17\n) compactly as smooth equality and inequality conditions in the form\nH\nÏƒ\n,\nÏ„\nâ€‹\n(\nx\nk\n,\nx\nk\n+\n1\n,\nU\nk\n,\nÎ»\nn\n,\nk\n)\n=\nğŸ\n,\n\\displaystyle H_{\\sigma,\\tau}(x_{k},x_{k+1},U_{k},\\lambda_{\\mathrm{n},k})=\\bm{0},\nG\nÏƒ\n,\nÏ„\nâ€‹\n(\nx\nk\n,\nx\nk\n+\n1\n,\nU\nk\n,\nÎ»\nn\n,\nk\n)\nâ‰¤\nğŸ\n.\n\\displaystyle G_{\\sigma,\\tau}(x_{k},x_{k+1},U_{k},\\lambda_{\\mathrm{n},k})\\leq\\bm{0}.\nFirst- and second-order derivatives for this system, apart from SDF and contact normal evaluations, will be derived by automatic differentiation using\nCasADi\n.\nOverall, we derived a completely smooth physics simulation system, where we smoothed both the collision detection LCP and the contact resolution LCP through interior-point smoothing, which can optionally be replaced for the contact resolution LCP by Scholtesâ€™ relaxation method. This smooth approximation of the original nonsmooth physics simulation can be made arbitrarily accurate by letting\nÏ„\nâ†’\n0\n\\tau\\rightarrow 0\nand\nÏƒ\nâ†’\n0\n\\sigma\\rightarrow 0\n.\nV\nRobust Contact-Implicit Optimal Control\nIn this section, we formulate an open-loop optimal control problem that generates assembly motions which can be reliably executed on real robotic systems. To this end, we utilize a multi-scenario-based formulation that optimizes for a robust reference trajectory. The reference trajectory is optimized such that successful task completion is achieved for multiple instances of compliant trajectories that track the reference trajectory according to a Cartesian impedance law with an additional position offset. Associating a randomized position offset with each scenario achieves robust behavior. This allows one to execute the reference trajectory in conjunction with impedance-based tracking on the real system and as long as the model-reality mismatch is contained in the previously modeled perturbations reliable execution is expected. In Section\nV-A\n, the utilized Cartesian impedance law is formulated. The multi-scenario optimal control formulation is derived in Section\nV-B\n. In Section\nV-C\n, we state the utilized cost function that supports determination of a common reference trajectory that results in successful task completion for all considered scenarios. Finally, in Section\nV-D\nthe homotopy procedure is detailed that sequentially tightens the smooth approximations of the collision detection and contact resolution problem to obtain solutions that closely adhere to the original nonsmooth contact dynamics.\nV-A\nImpedance-based Feedback Controller\nCartesian impedance control is a widely used methodology to achieve compliant behavior of robots with their environment. The considered OCP formulation optimizes for a reference trajectory\nx\nr\n=\n(\nq\nr\n,\nv\nr\n)\nâˆˆ\nâ„\n13\nx_{\\mathrm{r}}=(q_{\\mathrm{r}},v_{\\mathrm{r}})\\in\\mathbb{R}^{13}\nthat is tracked by the real system\nx\nc\n=\n(\nq\nc\n,\nv\nc\n)\nâˆˆ\nâ„\n13\nx_{\\mathrm{c}}=(q_{\\mathrm{c}},v_{\\mathrm{c}})\\in\\mathbb{R}^{13}\nin a compliant manner. To formulate the impedance dynamics we follow the derivations of\n[\n8\n]\nthat introduce the concept of geometrically consistent stiffness. We make the following restrictions that simplify the impedance equations. We assume so-called isotropic stiffness both in translational as in rotational space, meaning that the translational stiffness is given by\nK\nt\n=\nk\nt\nâ€‹\nI\n3\nK_{\\mathrm{t}}=k_{\\mathrm{t}}I_{3}\n, with some stiffness parameter\nk\nt\n>\n0\nk_{\\mathrm{t}}>0\nand the rotational stiffness is given by\nK\nr\n=\nk\nr\nâ€‹\nI\n3\nK_{\\mathrm{r}}=k_{\\mathrm{r}}I_{3}\nwith\nk\nr\n>\n0\nk_{\\mathrm{r}}>0\n. The impedance law then reads as\nJ\nâ€‹\n(\nx\nr\n,\nx\nc\n)\n=\n(\nK\nt\nâ€‹\n(\nÏ\nr\nâˆ’\nÏ\nc\n)\n+\nD\nt\nâ€‹\n(\nÎ½\nr\nâˆ’\nÎ½\nc\n)\nÎ”\nâ€‹\n(\nÎ¾\nr\n,\nÎ¾\nc\n)\n+\nD\nr\nâ€‹\n(\nÏ‰\nr\nâˆ’\nÏ‰\nc\n)\n)\n,\nJ(x_{\\mathrm{r}},x_{\\mathrm{c}})=\\begin{pmatrix}K_{\\mathrm{t}}(\\rho_{\\mathrm{r}}-\\rho_{\\mathrm{c}})+D_{\\mathrm{t}}(\\nu_{\\mathrm{r}}-\\nu_{\\mathrm{c}})\\\\\n\\Delta(\\xi_{\\mathrm{r}},\\xi_{\\mathrm{c}})+D_{\\mathrm{r}}(\\omega_{\\mathrm{r}}-\\omega_{\\mathrm{c}})\\end{pmatrix},\n(18)\nwhere\nJ\nâ€‹\n(\nx\nr\n,\nx\nc\n)\nâˆˆ\nâ„\n6\nJ(x_{\\mathrm{r}},x_{\\mathrm{c}})\\in\\mathbb{R}^{6}\nis the resulting force wrench by which the compliant system has to be actuated such that is retains the reference state. We have to account for the dimension difference of quaternions and their corresponding velocity space. To this end, first the quaternion difference between reference and compliant orientation is considered and calculated by\n(\nÎ·\ncr\n,\nÎµ\ncr\n)\n\\displaystyle(\\eta_{\\mathrm{cr}},\\varepsilon_{\\mathrm{cr}})\n=\nÎ¾\nc\nâˆ’\n1\nâŠ—\nÎ¾\nr\n,\n\\displaystyle=\\xi_{\\mathrm{c}}^{-1}\\otimes\\xi_{\\mathrm{r}},\nwhere\nÎ¾\nc\nâˆ’\n1\n\\xi_{\\mathrm{c}}^{-1}\nis the inverse quaternion and\nÎ·\ncr\nâˆˆ\nâ„\n\\eta_{\\mathrm{cr}}\\in\\mathbb{R}\nis the scalar part and\nÎµ\ncr\nâˆˆ\nâ„\n3\n\\varepsilon_{\\mathrm{cr}}\\in\\mathbb{R}^{3}\nis the imaginary part of this quaternion product. The quaternion mismatch is then accounted in the impedance law by\nÎ”\nâ€‹\n(\nÎ¾\nr\n,\nÎ¾\nc\n)\n\\displaystyle\\Delta(\\xi_{\\mathrm{r}},\\xi_{\\mathrm{c}})\n=\n2\nâ€‹\n(\nÎ·\ncr\nâ€‹\nI\n3\n+\n[\nÎµ\ncr\n]\nÃ—\n)\nâ€‹\nK\nr\nâ€‹\nÎµ\ncr\n\\displaystyle=2(\\eta_{\\mathrm{cr}}I_{3}+[\\varepsilon_{\\mathrm{cr}}]_{\\times})K_{\\mathrm{r}}\\varepsilon_{\\mathrm{cr}}\n=\n2\nâ€‹\nÎ·\ncr\nâ€‹\nK\nr\nâ€‹\nÎµ\ncr\n,\n\\displaystyle=2\\eta_{\\mathrm{cr}}K_{\\mathrm{r}}\\varepsilon_{\\mathrm{cr}},\nwhere\n[\nâ‹…\n]\nÃ—\n[\\cdot]_{\\times}\nis defined via the cross product such that for\na\nâˆˆ\nâ„\n3\n,\nb\nâˆˆ\nâ„\n3\na\\in\\mathbb{R}^{3},b\\in\\mathbb{R}^{3}\nit holds\na\nÃ—\nb\n=\n[\na\n]\nÃ—\nâ€‹\nb\na\\times b=[a]_{\\times}b\n. The simplification in the second equation above holds due to the assumption of isotropic stiffness. The damping matrices\nD\nt\nâˆˆ\nâ„\n3\nÃ—\n3\nD_{\\mathrm{t}}\\in\\mathbb{R}^{3\\times 3}\nand\nD\nr\nâˆˆ\nâ„\n3\nÃ—\n3\nD_{\\mathrm{r}}\\in\\mathbb{R}^{3\\times 3}\nare designed such that critical damping is achieved, cf.\n[\n1\n]\n.\nV-B\nRobustness through Ensemble Contact-Implicit Optimal Control\nFigure 5\n:\nIllustration of impedance tracking in contact, without and with an offset pose.\nIn this section, we derive a robust optimal control problem formulation based on a multi-scenario approach which utilizes the derived contact dynamics of Section\nIV\n. To achieve robust executions on the real systems, we follow the idea of\n[\n33\n]\n, that is optimizing for a reference trajectory that is tracked by several instances of compliant trajectories through an impedance law at a constant positional offset. In the following we introduce perturbation operators that enable the generation of these tracking offsets. We define the perturbation operator for the poses\nq\n=\n(\nÏ\n,\nÎ¾\n)\nâˆˆ\nâ„\n7\nq=(\\rho,\\xi)\\in\\mathbb{R}^{7}\nand\nq\n^\n=\n(\nÏ\n^\n,\nÎ¾\n^\n)\nâˆˆ\nâ„\n7\n\\hat{q}=(\\hat{\\rho},\\hat{\\xi})\\in\\mathbb{R}^{7}\nby\nP\nq\nâ€‹\n(\nq\n,\nq\n^\n)\n=\n(\nÏ\n+\nR\nâ€‹\n(\nÎ¾\n)\nâ€‹\nÏ\n^\nÎ¾\nâŠ—\nÎ¾\n^\n)\nâˆˆ\nâ„\n7\n.\nP_{\\mathrm{q}}(q,\\hat{q})=\\begin{pmatrix}\\rho+R(\\xi)\\hat{\\rho}\\\\\n\\xi\\otimes\\hat{\\xi}\\end{pmatrix}\\in\\mathbb{R}^{7}.\nThe corresponding inverse perturbation operator is then given by\nP\nq\nâˆ’\n1\nâ€‹\n(\nq\n,\nq\n^\n)\n=\n(\nÏ\nâˆ’\nR\nâ€‹\n(\nÎ¾\nâŠ—\nÎ¾\n^\nâˆ’\n1\n)\nâ€‹\nÏ\n^\nÎ¾\nâŠ—\nÎ¾\n^\nâˆ’\n1\n)\nâˆˆ\nâ„\n7\n,\nP_{\\mathrm{q}}^{-1}(q,\\hat{q})=\\begin{pmatrix}\\rho-R(\\xi\\otimes\\hat{\\xi}^{-1})\\hat{\\rho}\\\\\n\\xi\\otimes\\hat{\\xi}^{-1}\\end{pmatrix}\\in\\mathbb{R}^{7},\nsuch that it holds\nP\nq\nâ€‹\n(\nP\nq\nâˆ’\n1\nâ€‹\n(\nq\n,\nq\n^\n)\n,\nq\n^\n)\n=\nq\n.\nP_{\\mathrm{q}}(P_{\\mathrm{q}}^{-1}(q,\\hat{q}),\\hat{q})=q.\nWe now generalize the notation such that these perturbation operators can be applied to a state\nx\n=\n(\nq\n,\nv\n)\nâˆˆ\nâ„\n13\nx=(q,v)\\in\\mathbb{R}^{13}\nas\nP\nx\nâ€‹\n(\nx\n,\nq\n^\n)\n=\n(\nP\nq\nâ€‹\n(\nq\n,\nq\n^\n)\nv\n)\nâˆˆ\nâ„\n13\n,\nP_{\\mathrm{x}}(x,\\hat{q})=\\begin{pmatrix}P_{\\mathrm{q}}(q,\\hat{q})\\\\\nv\\end{pmatrix}\\in\\mathbb{R}^{13},\nand equivalently\nP\nx\nâˆ’\n1\nâ€‹\n(\nx\n,\nq\n^\n)\n=\n(\nP\nq\nâˆ’\n1\nâ€‹\n(\nq\n,\nq\n^\n)\nv\n)\nâˆˆ\nâ„\n13\n.\nP_{\\mathrm{x}}^{-1}(x,\\hat{q})=\\begin{pmatrix}P^{-1}_{\\mathrm{q}}(q,\\hat{q})\\\\\nv\\end{pmatrix}\\in\\mathbb{R}^{13}.\nThe perturbation operator is used to perturb the actual positions of the compliant trajectory within the impedance law. Consequently, the compliant trajectories track the reference trajectory at a constant positional offset. Figure\n5\nillustrates this behavior, instead of tracking the reference precisely in free space the pose, obtained by adding the offset pose to the compliant pose, tracks the reference pose. If contact is established a virtual spring force is generated and applied to the compliant object by the impedance law which is opposed by the contact forces. For multiple perturbed compliant poses that track the reference pose a particle cloud originates, cf. Figure\n1\n(bottom left), consisting of the different instances of compliant trajectories that track the reference trajectory at constant positional offset in free space motions. To successfully solve an assembly problem for all instances of compliant trajectories, the optimizer has to select the reference trajectory such that contact forces are utilized to compress the particle cloud in a way such that the goal position is obtained for all scenario instances. To this end, we consider\nn\ns\nâˆˆ\nâ„•\nn_{\\mathrm{s}}\\in\\mathbb{N}\nscenarios with corresponding positional offsets\nq\n^\n(\nl\n)\nâˆˆ\nâ„\n7\n\\hat{q}^{(l)}\\in\\mathbb{R}^{7}\n,\nl\n=\n1\n,\nâ€¦\n,\nn\ns\nl=1,\\dots,n_{\\mathrm{s}}\n.\nThe positional offsets may be chosen at random, but since increasing the number of scenarios heavily influences computation times, selecting the offsets purposefully by hand enables more robust solutions with less computation effort. We only use translational offsets, i.e.,\nq\n^\n(\nl\n)\n=\n(\nÏ\n^\n(\nl\n)\n,\nÎ¾\nÂ¯\nid\n)\n,\n\\hat{q}^{(l)}=(\\hat{\\rho}^{(l)},\\bar{\\xi}_{\\mathrm{id}}),\nwhere the specific selection of\nÏ\n^\n(\nl\n)\nâˆˆ\nâ„\n3\n\\hat{\\rho}^{(l)}\\in\\mathbb{R}^{3}\nis detailed for each conducted experiment in Section\nVI\n. In particular, we define the translational offsets\nÏ\n^\n(\nl\n)\n\\hat{\\rho}^{(l)}\nvia a normalized direction vector\nÏ\n^\ndir\n(\nl\n)\nâˆˆ\nâ„\n3\n\\hat{\\rho}^{(l)}_{\\mathrm{dir}}\\in\\mathbb{R}^{3}\nwith\nâ€–\nÏ\n^\ndir\n(\nl\n)\nâ€–\n2\n=\n1\n\\|\\hat{\\rho}^{(l)}_{\\mathrm{dir}}\\|_{2}=1\nand an offset magnitude\nÎ´\n^\nâ‰¥\n0\n\\hat{\\delta}\\geq 0\nsuch that we have\nÏ\n^\n(\nl\n)\n=\nÎ´\n^\nâ€‹\nÏ\n^\ndir\n(\nl\n)\n.\n\\hat{\\rho}^{(l)}=\\hat{\\delta}\\,\\hat{\\rho}^{(l)}_{\\mathrm{dir}}.\nTherefore,\nÎ´\n^\n\\hat{\\delta}\nindicates how robust a solution of the optimal control problem is but also how difficult it is to solve.\nFor a given initial state\nx\nÂ¯\n0\nâˆˆ\nâ„\n13\n\\bar{x}_{0}\\in\\mathbb{R}^{13}\n, a goal state\nx\nÂ¯\ngoal\nâˆˆ\nâ„\n13\n\\bar{x}_{\\mathrm{goal}}\\in\\mathbb{R}^{13}\nand an optimization horizon\nN\nâˆˆ\nâ„•\nN\\in\\mathbb{N}\n, the multi-scenario-based optimal control formulation is now given by\nmin\nğ±\n,\nğ€\nn\nC\nâ€‹\n(\nğ±\n,\nx\nÂ¯\ngoal\n)\n\\displaystyle\\underset{\\bm{\\mathrm{x}},\\bm{\\mathrm{\\lambda}}_{\\mathrm{n}}}{\\mathrm{min}}\\quad C(\\bm{\\mathrm{x}},\\bar{x}_{\\mathrm{goal}})\\phantom{aaaaaaaaaaaaaaaaaaaa}\\hfil\\hfil\\hfil\\hfil\n(19)\ns\n.\nt\n.\n\\displaystyle\\mathmakebox[\\widthof{$\\underset{\\phantom{\\bm{\\mathrm{x}}, \\bm{\\mathrm{\\lambda}}_{\\mathrm{n}}}}{\\mathrm{min}}$}][c]{\\mathmakebox[\\widthof{$\\mathrm{min}$}][c]{\\mathrm{\\kern 1.00006pts.t.}}}\\quad\nx\nr\n,\n0\n=\nx\nÂ¯\n0\n,\n,\n\\displaystyle x_{\\mathrm{r},0}=\\bar{x}_{0},,\\hfil\\hfil\nq\nr\n,\nk\n+\n1\n=\nq\nr\n,\nk\n+\nÎ”\nâ€‹\nt\nâ€‹\nQ\nâ€‹\n(\nq\nr\n,\nk\n)\nâ€‹\nv\nr\n,\nk\n+\n1\n,\n,\n\\displaystyle q_{\\mathrm{r},k+1}=q_{\\mathrm{r},k}+\\Delta tQ(q_{\\mathrm{r},k})v_{\\mathrm{r},k+1},,\\hfil\\hfil\nfor\nâ€‹\nk\n=\n0\n,\nâ€¦\n,\nN\nâˆ’\n1\n,\n,\n\\displaystyle\\text{for }k=0,\\dots,N-1,,\\hfil\\hfil\nx\nc\n,\n0\n(\nl\n)\n=\nP\nx\nâˆ’\n1\nâ€‹\n(\nx\nÂ¯\n0\n,\nq\n^\n(\nl\n)\n)\n,\n,\n\\displaystyle x_{\\mathrm{c},0}^{(l)}=P_{\\mathrm{x}}^{-1}(\\bar{x}_{0},\\hat{q}^{(l)}),,\\hfil\\hfil\nH\nÏƒ\n,\nÏ„\nâ€‹\n(\nx\nc\n,\nk\n(\nl\n)\n,\nx\nc\n,\nk\n+\n1\n(\nl\n)\n,\nU\nk\n(\nl\n)\n,\nÎ»\nn\n,\nk\n(\nl\n)\n)\n=\nğŸ\n,\n,\n\\displaystyle H_{\\sigma,\\tau}(x_{\\mathrm{c},k}^{(l)},x_{\\mathrm{c},k+1}^{(l)},U_{k}^{(l)},\\lambda_{\\mathrm{n},k}^{(l)})=\\bm{0},,\\hfil\\hfil\nG\nÏƒ\n,\nÏ„\nâ€‹\n(\nx\nc\n,\nk\n(\nl\n)\n,\nx\nc\n,\nk\n+\n1\n(\nl\n)\n,\nU\nk\n(\nl\n)\n,\nÎ»\nn\n,\nk\n(\nl\n)\n)\nâ‰¤\nğŸ\n,\n,\n\\displaystyle G_{\\sigma,\\tau}(x_{\\mathrm{c},k}^{(l)},x_{\\mathrm{c},k+1}^{(l)},U_{k}^{(l)},\\lambda_{\\mathrm{n},k}^{(l)})\\leq\\bm{0},,\\hfil\\hfil\nU\nk\n(\nl\n)\n\\displaystyle U_{k}^{(l)}\n=\nJ\nâ€‹\n(\nx\nr\n,\nk\n+\n1\n,\nP\nx\nâ€‹\n(\nx\nc\n,\nk\n+\n1\n(\nl\n)\n,\nq\n^\n(\nl\n)\n)\n)\n,\n\\displaystyle=J(x_{\\mathrm{r},k+1},P_{\\mathrm{x}}(x_{\\mathrm{c},k+1}^{(l)},\\hat{q}^{(l)})),\\hfil\\hfil\nfor\nâ€‹\nk\n=\n0\n,\nâ€¦\n,\nN\nâˆ’\n1\n,\nl\n=\n1\n,\nâ€¦\n,\nn\ns\n,\n\\displaystyle\\text{for }k=0,\\dots,N-1,\\ l=1,\\dots,n_{\\mathrm{s}},\\\nwhere\nğ±\n=\n(\nx\nc\n,\n0\n(\n1\n)\n,\nâ€¦\n,\nx\nc\n,\nN\n(\n1\n)\n,\nâ€¦\n,\nx\nc\n,\nN\n(\nn\ns\n)\n,\nx\nr\n,\n0\n,\nâ€¦\n,\nx\nr\n,\nN\n)\n\\bm{\\mathrm{x}}=(x_{\\mathrm{c},0}^{(1)},\\dots,x_{\\mathrm{c},N}^{(1)},\\dots,x_{\\mathrm{c},N}^{(n_{\\mathrm{s}})},x_{\\mathrm{r},0},\\dots,x_{\\mathrm{r},N})\ncaptures all occurring states of compliant and reference trajectories and\nğ€\nn\n=\n(\nÎ»\nn\n,\n0\n(\n1\n)\n,\nâ€¦\n,\nÎ»\nn\n,\nN\n(\n1\n)\n,\nâ€¦\n,\nÎ»\nn\n,\nN\n(\nn\ns\n)\n)\n\\bm{\\mathrm{\\lambda}}_{\\mathrm{n}}=(\\lambda_{\\mathrm{n},0}^{(1)},\\dots,\\lambda_{\\mathrm{n},N}^{(1)},\\dots,\\lambda_{\\mathrm{n},N}^{(n_{\\mathrm{s}})})\ncaptures all occurring contact forces. The effective control input are the reference velocities\nv\nr\n,\nk\n+\n1\n,\nk\n=\n0\n,\nâ€¦\n,\nN\nâˆ’\n1\nv_{\\mathrm{r},k+1},k=0,\\dots,N-1\n, which uniquely define all other variables in the case of using Scholtesâ€™ smoothing. If Scholtesâ€™ relaxation is used, additional degrees of freedom are introduced due to the relaxed force-distance complementarity conditions which can be interpreted as additional control inputs that the optimizer utilizes to optimize the cost function.\nV-C\nCost Function\nIn the following, we discuss cost terms used to produce robust assembly motions. The considered cost function contains several differently weighted terms that aim at facilitating motions that can be reliably executed on real hardware. We first introduce two running cost terms\nL\nÂ¯\nrun\n,\n1\nâ€‹\n(\nx\n)\n\\displaystyle\\bar{L}_{\\mathrm{run},1}(x)\n=\nâ€–\nÎ½\nâ€–\n2\n2\n,\n\\displaystyle=\\|\\nu\\|_{2}^{2},\nL\nÂ¯\nrun\n,\n2\nâ€‹\n(\nx\n)\n\\displaystyle\\bar{L}_{\\mathrm{run},2}(x)\n=\nâ€–\nÏ‰\nâ€–\n2\n2\n,\n\\displaystyle=\\|\\omega\\|_{2}^{2},\nwhich quadratically penalize translational and rotational velocities. These terms effectively penalize the geometric lengths of the resulting trajectories. We further define two terminal cost terms\nL\nÂ¯\ntrm\n,\n1\nâ€‹\n(\nx\n,\nx\nÂ¯\ngoal\n)\n\\displaystyle\\bar{L}_{\\mathrm{trm},1}(x,\\bar{x}_{\\mathrm{goal}})\n=\nâ€–\nÏ\nâˆ’\nÏ\nÂ¯\ngoal\nâ€–\n2\n2\n,\n\\displaystyle=\\|\\rho-\\bar{\\rho}_{\\mathrm{goal}}\\|_{2}^{2},\nL\nÂ¯\ntrm\n,\n2\nâ€‹\n(\nx\n,\nx\nÂ¯\ngoal\n)\n\\displaystyle\\bar{L}_{\\mathrm{trm},2}(x,\\bar{x}_{\\mathrm{goal}})\n=\nâ€–\nR\nâ€‹\n(\nÎ¾\nâ€–\nÎ¾\nâ€–\n2\n)\nâˆ’\nR\nâ€‹\n(\nÎ¾\nÂ¯\ngoal\n)\nâ€–\nF\n2\n,\n\\displaystyle=\\left\\|R\\left(\\frac{\\xi}{\\|\\xi\\|_{2}}\\right)-R(\\bar{\\xi}_{\\mathrm{goal}})\\right\\|_{\\mathrm{F}}^{2},\nwhere\nâˆ¥\nâ‹…\nâˆ¥\nF\n\\|\\cdot\\|_{\\mathrm{F}}\ndenotes the Frobenius norm and, as a remainder,\nR\nâ€‹\n(\nâ‹…\n)\nR(\\cdot)\nis the rotation matrix associated with a quaternion. These two cost terms penalize translational and rotational mismatch to the desired goal state. Note that all of these cost terms naturally allow to construct a Gauss-Newton Hessian approximation.\nGiven the various cost terms, we now define the running cost for the compliant and reference trajectories as\nL\nrun\n,\nc\nâ€‹\n(\nx\n)\n\\displaystyle L_{\\mathrm{run,c}}(x)\n=\nÎ²\nc\n,\n1\nâ€‹\nL\nÂ¯\nrun\n,\n1\nâ€‹\n(\nx\n)\n+\nÎ²\nc\n,\n2\nâ€‹\nL\nÂ¯\nrun\n,\n2\nâ€‹\n(\nx\n)\n,\n\\displaystyle=\\beta_{\\mathrm{c},1}\\bar{L}_{\\mathrm{run},1}(x)+\\beta_{\\mathrm{c},2}\\bar{L}_{\\mathrm{run},2}(x),\nL\nrun\n,\nr\nâ€‹\n(\nx\n)\n\\displaystyle L_{\\mathrm{run,r}}(x)\n=\nÎ²\nr\n,\n1\nâ€‹\nL\nÂ¯\nrun\n,\n1\nâ€‹\n(\nx\n)\n+\nÎ²\nr\n,\n2\nâ€‹\nL\nÂ¯\nrun\n,\n2\nâ€‹\n(\nx\n)\n,\n\\displaystyle=\\beta_{\\mathrm{r},1}\\bar{L}_{\\mathrm{run},1}(x)+\\beta_{\\mathrm{r},2}\\bar{L}_{\\mathrm{run},2}(x),\nwith scalar weights\nÎ²\nc\n,\n1\n,\nÎ²\nc\n,\n2\n,\nÎ²\nr\n,\n1\n,\nÎ²\nr\n,\n2\nâ‰¥\n0\n\\beta_{\\mathrm{c},1},\\beta_{\\mathrm{c},2},\\beta_{\\mathrm{r},1},\\beta_{\\mathrm{r},2}\\geq 0\n. For the terminal costs we have\nL\ntrm\n,\nc\nâ€‹\n(\nx\n,\nx\nÂ¯\ngoal\n)\n\\displaystyle L_{\\mathrm{trm,c}}(x,\\bar{x}_{\\mathrm{goal}})\n=\nÎ²\nc\n,\n3\nâ€‹\nL\nÂ¯\ntrm\n,\n1\nâ€‹\n(\nx\n,\nx\nÂ¯\ngoal\n)\n+\nÎ²\nc\n,\n4\nâ€‹\nL\nÂ¯\ntrm\n,\n2\nâ€‹\n(\nx\n,\nx\nÂ¯\ngoal\n)\n\\displaystyle=\\beta_{\\mathrm{c,3}}\\bar{L}_{\\mathrm{trm},1}(x,\\bar{x}_{\\mathrm{goal}})+\\beta_{\\mathrm{c,4}}\\bar{L}_{\\mathrm{trm},2}(x,\\bar{x}_{\\mathrm{goal}})\nL\ntrm\n,\nr\nâ€‹\n(\nx\n,\nx\nÂ¯\ngoal\n)\n\\displaystyle L_{\\mathrm{trm,r}}(x,\\bar{x}_{\\mathrm{goal}})\n=\nÎ²\nr\n,\n3\nâ€‹\nL\nÂ¯\ntrm\n,\n1\nâ€‹\n(\nx\n,\nx\nÂ¯\ngoal\n)\n+\nÎ²\nr\n,\n4\nâ€‹\nL\nÂ¯\ntrm\n,\n2\nâ€‹\n(\nx\n,\nx\nÂ¯\ngoal\n)\n,\n\\displaystyle=\\beta_{\\mathrm{r,3}}\\bar{L}_{\\mathrm{trm},1}(x,\\bar{x}_{\\mathrm{goal}})+\\beta_{\\mathrm{r,4}}\\bar{L}_{\\mathrm{trm},2}(x,\\bar{x}_{\\mathrm{goal}}),\nwith weights\nÎ²\nc\n,\n3\n,\nÎ²\nc\n,\n4\n,\nÎ²\nr\n,\n3\n,\nÎ²\nr\n,\n4\nâ‰¥\n0\n\\beta_{\\mathrm{c,3}},\\beta_{\\mathrm{c,4}},\\beta_{\\mathrm{r,3}},\\beta_{\\mathrm{r,4}}\\geq 0\n. Generally, the main goal when solving the OCP (\n19\n) is to bring all compliant trajectories to the goal state, thus, in the experiments in\nSection\nVI\n, the terminal cost terms are weighted substantially more heavily than the running cost terms. The final cost function is now obtained by\nC\nâ€‹\n(\nğ±\n,\nx\nÂ¯\ngoal\n)\n\\displaystyle C(\\bm{\\mathrm{x}},\\bar{x}_{\\mathrm{goal}})\n=\nâˆ‘\nk\n=\n0\nN\nâˆ’\n1\nâˆ‘\nl\n=\n1\nn\ns\nL\nrun\n,\nc\nâ€‹\n(\nx\nc\n,\nk\n+\n1\n(\nl\n)\n)\n\\displaystyle=\\sum_{k=0}^{N-1}\\sum_{l=1}^{n_{\\mathrm{s}}}L_{\\mathrm{run,c}}(x_{\\mathrm{c},k+1}^{(l)})\n+\nâˆ‘\nl\n=\n1\nn\ns\nL\ntrm\n,\nc\nâ€‹\n(\nx\nc\n,\nN\n(\nl\n)\n,\nx\nÂ¯\ngoal\n)\n\\displaystyle+\\sum_{l=1}^{n_{\\mathrm{s}}}L_{\\mathrm{trm,c}}(x_{\\mathrm{c},N}^{(l)},\\bar{x}_{\\mathrm{goal}})\n+\nâˆ‘\nk\n=\n0\nN\nâˆ’\n1\nL\nrun\n,\nr\nâ€‹\n(\nx\nr\n,\nk\n+\n1\n)\n\\displaystyle+\\sum_{k=0}^{N-1}L_{\\mathrm{run,r}}(x_{\\mathrm{r},k+1})\n+\nL\ntrm\n,\nr\nâ€‹\n(\nx\nr\n,\nN\n,\nx\nÂ¯\ngoal\n)\n.\n\\displaystyle+L_{\\mathrm{trm,r}}(x_{\\mathrm{r},N},\\bar{x}_{\\mathrm{goal}}).\nV-D\nHomotopy Procedure\nTo facilitate the solution process, we apply a homotopy procedure to enable first exploration and then refinement of contact-rich motions. Initially the problem is solved for large\nÏ„\n1\nâ‰«\n0\n\\tau_{1}\\gg 0\nand\nÏƒ\n1\nâ‰«\n0\n\\sigma_{1}\\gg 0\n, resulting in relaxed object shapes and force distance complementarities, cf. Figure\n1\n. The smoothing/relaxation parameters are then reduced by update rates\nÎº\nÏ„\nâˆˆ\n(\n0\n,\n1\n)\n\\kappa_{\\tau}\\in(0,1)\nand\nÎº\nÏƒ\nâˆˆ\n(\n0\n,\n1\n)\n\\kappa_{\\sigma}\\in(0,1)\nand the problem is solved again using the previous solution as a warm-start for both primal and dual variables of (\n19\n). We use\nIPOPT\n[\n47\n]\nas solver and additionally decrease\nIPOPT\nâ€™s initial barrier parameter\nÎ¼\ninit\n,\n1\nâ‰«\n0\n\\mu_{\\mathrm{init},1}\\gg 0\n. Therefore, we consider the update rate\nÎº\nÎ¼\nâˆˆ\n(\n0\n,\n1\n)\n\\kappa_{\\mu}\\in(0,1)\n. For a fixed number of homotopy iterations\nn\nhom\nâˆˆ\nâ„•\nn_{\\mathrm{hom}}\\in\\mathbb{N}\n, in each homotopy iteration the parameters are updated as\nÏ„\nn\n+\n1\n\\displaystyle\\tau_{n+1}\n=\nÎº\nÏ„\nâ€‹\nÏ„\nn\n,\n\\displaystyle=\\kappa_{\\tau}\\tau_{n},\nÏƒ\nn\n+\n1\n\\displaystyle\\sigma_{n+1}\n=\nÎº\nÏƒ\nâ€‹\nÏƒ\nn\n,\n\\displaystyle=\\kappa_{\\sigma}\\sigma_{n},\nÎ¼\ninit\n,\nn\n+\n1\n\\displaystyle\\mu_{\\mathrm{init},n+1}\n=\nÎº\nÎ¼\nâ€‹\nÎ¼\ninit\n,\nn\n,\n\\displaystyle=\\kappa_{\\mu}\\mu_{\\mathrm{init},n},\nfor\nn\n=\n1\n,\nâ€¦\n,\nn\nhom\nâˆ’\n1\nn=1,\\dots,n_{\\mathrm{hom}}-1\n.\nVI\nNumerical Evaluation and Real-world Experiments\nIn the following, we first discuss the implementation framework and give results on the computational efficiency of our SDF implementation, comparing it to the performance reported on a state-of-the-art GJK-based method. We then discuss results on several peg-in-hole tasks, where we investigate required solver iterations and solving times, and illustrate the benefit of using exact Hessians compared to Gauss-Newton or L-BFGS approximations as well as using Scholtesâ€™ relaxation compared to Scholtesâ€™ smoothing. Finally, we discuss results on real-world experiments with an UR10e robot. To this end, we examine the reliability of successful task completion in dependence of the modeled uncertainty\nÎ´\n^\n\\hat{\\delta}\nand the amount of utilized smoothing\nÏ„\n,\nÏƒ\n\\tau,\\sigma\n. A video illustrating the experiments is available here:\nhttps://youtu.be/g4E83bjs7lg\n.\nVI-A\nImplementation Framework\nThe code is completely written in\nC/C++\nand all computations are carried out on a Lenovo ThinkPad P15 Laptop with Intel i7-11850H CPU and 32 GB RAM. We use\nIPOPT\n[\n47\n]\nas optimization solver with the linear solver\nMA27\nfrom the\nC++\ninterface of\nCasADi\n[\n3\n]\n. For contact information and corresponding derivative evaluations, we use the high-performance linear algebra library\nBLASFEO\n[\n12\n]\n. It provides performance-optimized linear algebra routines for matrices up to a couple hundreds elements, as typically encountered in embedded optimization. The signed distance problem (\n1\n) is solved by using the high-performance interior-point implementation\nHPIPM\n[\n11\n]\n, which is based on\nBLASFEO\n. The nominal evaluation of the contact information vector\nw\nw\n(\n8\n) and all first- and second-order derivatives as occurring in Section\nIII\nare analytically derived and evaluated using\nBLASFEO\n. Within the OCP (\n19\n) a total of\n|\nÎ \n|\nâ‹…\nn\ns\nâ‹…\nN\n|\\Pi|\\cdot n_{\\mathrm{s}}\\cdot N\ncontact information vectors and corresponding derivatives are evaluated per solver iteration. To expose the distance information to\nCasADi\n, we utilize\nCasADi\nâ€™s\nCallback\nclass. To speed up the SDF evaluation procedure, we use\nOpenMP\nfor parallel computations in combination with a batched version of the\nCallback\nclass, which takes all\nn\ns\nâ‹…\nN\nn_{\\mathrm{s}}\\cdot N\nobject positions occuring in (\n19\n) and returns all the corresponding contact information at once.\nVI-B\nEfficiency of SDF\nFigure 6\n:\nComputation time for a single cube-cube distance (averaged from 1000 evaluations). Here,\nx\nâˆˆ\n{\nq\n,\nÎ³\n}\nx\\in\\{q,\\gamma\\}\nis a placeholder for the respective derivatives detailed in\nSection\nIII\n.\nFirst, we give an analysis of computation time required for our SDF implementation to evaluate signed distances and to calculate first- and second-order directional derivatives. To this end, we evaluate 1000 cube-cube distances, where one cube has a fixed position and one cube is placed at a randomly generated position. Figure\n6\nshows the average time required for one LP solution, its Jacobian and the directional Hessian for a randomly generated seed. We can deduce that evaluating first-derivatives for this problem is approximately three times cheaper than solving the distance problem itself. Moreover, evaluating second-derivatives is only slightly more expensive than evaluating first-derivatives in terms of computation times, making derivative evaluations in this setup overall very cheap compared to the computational effort for nominal evaluations.\nIn\n[\n31\n]\n, the state-of-the-art QP solver\nProxQP\n[\n5\n]\nhas been used to solve similiar distance problems, where a computation time of\n5\nâ€‹\nÎ¼\nâ€‹\ns\n5\\mu\\mathrm{s}\nhas been reported.\nProxQP\nis a first-order method not relying on the inversion of the KKT system to solve QPs, making it cheap in computation. However, it does not provide an inherent smoothing mechanism as an interior-point method does. The efficiency of\nHPIPM\nis illustrated as we only require\n10\nâ€‹\nÎ¼\nâ€‹\ns\n10\\mu\\mathrm{s}\nto solve a distance problem in a smooth manner. Arguably, state-of-the-art GJK algorithms report computation times for similar distance problems of\n0.2\nâ€‹\nÎ¼\nâ€‹\ns\n0.2\\mu\\mathrm{s}\n[\n31\n]\n. This points to an interesting area of research that aims at combining the advantages of smoothing using interior-point methods with the efficiency of GJK methods.\nVI-C\nPeg-in-Hole Assembly with Randomized Shapes\n(a)\nPeg1\n:\n|\nÎ \n|\n=\n6\n|\\Pi|=6\n(b)\nPeg2\n:\n|\nÎ \n|\n=\n10\n|\\Pi|=10\n(c)\nPeg3\n:\n|\nÎ \n|\n=\n14\n|\\Pi|=14\n(d)\nPeg4\n:\n|\nÎ \n|\n=\n18\n|\\Pi|=18\n(e)\nPeg5\n:\n|\nÎ \n|\n=\n24\n|\\Pi|=24\nFigure 7\n:\nFive different considered Peg-in-Hole problems with increasing numbers of contact pairs.\nTABLE II\n:\nAverage total computation time for the peg-in-hole experiments.\nProblem instance time\nPeg1\nPeg2\nPeg3\nPeg4\nPeg5\nTotal wall time (\ns\n\\mathrm{s}\n)\n85.76\n171.33\n391.22\n380.18\n343.57\n(a)\nAverage number of\nIPOPT\niterations during each homotopy iteration.\n(b)\nAverage wall time per\nIPOPT\niteration splitted into time required for SDF, contact normal and corresponding derivative evaluations,\nCasADi\nevaluations for terms in the OCP (\n19\n) unrelated to the SDF, and remaining time spent by\nIPOPT\nfor computing the next iterate.\nFigure 8\n:\nEach peg-in-hole problem is solved for five starting positions with different orientations. The figures show the average results across these five solves. Parameters used for these experiments are denoted in Table\nIII\nin Appendix\nB\n.\nWe analyze the performance of the considered methodology on five different peg-in-hole problems as shown in Figure\n7\n. The shapes of the pegs have been randomly generated, where the number of resulting contact pairs ranges from\n|\nÎ \n|\n=\n6\n|\\Pi|=6\nto\n|\nÎ \n|\n=\n24\n|\\Pi|=24\n. Each peg-in-hole problem is solved for five different initial poses, where the translational position was kept equal and only the orientation was altered. Table\nIII\nin Appendix\nB\ndenotes all parameters that were used to solve the corresponding instances of the OCP (\n19\n).\nFigure\n8\nshows the results of this experiment. We observe in Figure\n8(a)\nthat the geometric complexity of the pegs shapes is not directly proportional to the required iterations to achieve convergence. This is reasonable as robust assembly behavior for pegs is achieved by tilting the peg and consecutively pushing it into one corner of the hole, whether there are a few or many more other corners does not directly influence the complexity of the motion (illustrated in the accompanying video).\nIn contrast, the required computation times per iteration as shown in Figure\n8(b)\nare directly proportional to the complexity of the pegâ€™s shapes since more considered contact pairs increase the number of contact information evaluations as well as the number of optimization variables and constraints in the OCP (\n19\n). This directly influences\nIPOPT\n,\nCasADi\nand SDF computation times.\nIPOPT\nis currently used with the linear solver\nMA27\nwhich does exploit generic sparsity but is not tailored to the specific sparsity implied by the optimal control problem. Thus, there is room for improvement by using sparsity exploiting linear solvers tailored to optimal control as, e.g., done in\n[\n45\n]\n. Nevertheless, the proposed method is already highly efficient, as can be deduced from Table\nII\n, where we demonstrate that robust assembly motions can be determined for the considered peg-in-hole instances in a matter of one to seven minutes on a standard laptop CPU.\nIn\n[\n46\n]\n, a gradient-free reinforcement learning approach in conjunction with the\nMuJoCo\nphysics engine is utilized to solve peg-in-hole problems, requiring a number of simulation steps in the order of\n10\n8\n10^{8}\nfor successful task completion. This also means that all the collision detection problems required for a simulation step must be solved as many times as the total number of simulation steps. With our optimal control approach, we require an order of\n10\n3\n10^{3}\niterations to converge to a solution, where in each iteration\nN\n=\n10\n2\nN=10^{2}\nsimulation steps are approximately evaluated by calculating one Newton step on the dynamics, causing overall an order of\n10\n5\n10^{5}\ncalls to the collision detection pipeline. This supports the potential of increased sample-efficiency that optimal control approaches inherit compared to methods that use less derivative information of the dynamic model.\nWe now also investigate whether using exact second-order derivatives over commonly used Hessian approximations is beneficial in the presented optimal control approach. Further, we compare computational performance achieved with Scholtesâ€™ relaxation vs. Scholtesâ€™ smoothing. To this end, Figure\n9\nshows the results for solving the\nPeg1\nproblem with Scholtesâ€™ relaxation and Scholtesâ€™ smoothing as well as with exact, Gauss-Newton or L-BFGS Hessians. The best and worst run in terms of iteration numbers out of five problem instances with different initial peg poses is shown for two different values of\nIPOPT\nâ€™s convergence tolerance parameter\nIPOPT.tol\n. We deduce that Scholtesâ€™ relaxation improves convergence speed compared to using Scholtesâ€™ smoothing. This illustrates that derivative-based planning and control approaches using differentiable physic simulations can strongly benefit if they can influence additional degrees of freedom in the physics simulation.\nFurthermore, these results emphasize clearly the benefit of using exact Hessians compared to using a Gauss-Newton or L-BFGS approximation for the conducted experiments. In case of the loose convergence tolerance\nIPOPT.tol\n=\n10\nâˆ’\n2\n=10^{-2}\nexact Hessians result in 5 times faster convergence than for the Gauss-Newton Hessian and 10 times faster convergence than for the L-BFGS Hessian. In case of\nIPOPT\nâ€™s default convergence tolerance\nIPOPT.tol\n=\n10\nâˆ’\n6\n=10^{-6}\n, both Hessian approximations lead to failed convergence, where for Gauss-Newton three out of five optimization attempts fail while for L-BFGS all optimization attempts fail.\nFigure 9\n:\nComparison of Scholtesâ€™ relaxation (rel.) vs Scholtesâ€™ smoothing (smth.) and utilization of exact, Gauss-Newton and L-BFGS Hessians for the solution of the OCP (\n19\n). The\nPeg1\nproblem is solved for five different starting positions for each of the considered instances, where the best (b) and the worst (w) trial in terms of solver iterations is shown. The experiments are repeated for two different values of the convergence tolerance\nIPOPT.tol\n.\nVI-D\nClamp Assembly\nFigure 10\n:\nSolution trajectory for the considered benchmark problem. Orange arrow indicates the current moving direction. Best understood by viewing the accompanying video.\n(a)\nOverview of robotic setup.\n(b)\nClamp1\nassembly.\n(c)\nClamp2\nassembly.\n(d)\nClamp3\nassembly.\nFigure 11\n:\nThe robotic setup for the conducted experiments. An UR10e is used in conjunction with the proposed methodology to robustly assemble three different parts onto an H-strut.\nNext, we conduct experiments that test the reliability of the calculated robust assembly motions on real robotic hardware, cf. Figure\n11\nfor the robotic setup. In particular, we investigate what influence the smoothing parameters\nÏ„\n\\tau\nand\nÏƒ\n\\sigma\nused for the final homotopy iteration and the magnitude of the modeled uncertainty\nÎ´\n^\n\\hat{\\delta}\nhave on the task success rates. To this end, an UR10e manipulator is controlled via the\nur_rtde\ninterface\n[\n28\n]\n. We control the robot via the\nforceMode\n, which allows one to command a six-dimensional Cartesian wrench that the end-effector tries to exhibit on its environment. The commanded wrench is exactly the one computed by the impedance law (\n18\n). However, since on the real system this force wrench does not only accelerate the part but also the whole robot, we increase the stiffness values to\nk\nt\n,\nrobot\n=\n1500\nk_{\\mathrm{t},\\mathrm{robot}}=1500\nand\nk\nr\n,\nrobot\n=\n200\nk_{\\mathrm{r},\\mathrm{robot}}=200\nwhich differ from the values used in simulation\nk\nt\n,\nsim\n=\n100\nk_{\\mathrm{t},\\mathrm{sim}}=100\nand\nk\nr\n,\nsim\n=\n10\nk_{\\mathrm{r},\\mathrm{sim}}=10\nto account for this mismatch.\nWe consider the task of assembling a clamp onto a H-formed strut, cf. Figure\n10\n. The wall thickness of the strut is 5mm while the gap width of the clamp is 5.5mm, whereby due to 3D printing imprecision the final clearance between clamp and strut is less than 0.5mm. We carefully measured the relative position of the robot and the H-formed strut in the real-world to reduce the unknown positional deviations between the model and reality as much as possible.\nThe assembly problem is then solved 30 times, where 5 different starting positions and 6 different magnitudes\nÎ´\n^\n\\hat{\\delta}\nfor the positional offsets\nq\n^\n(\nl\n)\n\\hat{q}^{(l)}\nare considered. Every problem is solved with up to\nn\nhom\n=\n6\nn_{\\mathrm{hom}}=6\nhomotopy iterations, resulting in\n30\nÃ—\n6\n=\n180\n30\\times 6=180\ndistinct reference trajectories. Table\nIV\nin Appendix\nB\ndenotes the utilized parameters for these experiments.\nThese reference trajectories are executed on the real robot by tracking them with the Cartesian impedance controller. To verify the robustness, we inject virtual model-reality mismatches by changing the position of the part within the gripper in the virtual model. This injected mismatch is precisely what is replicated by the robust OCP formulation (\n19\n), as now the part in the real system does not directly track the reference trajectory, but instead tracks it at a constant positional offset. We inject two different positional offsets, one in distribution\nq\ninject\n,\n(\n1\n)\nq^{\\mathrm{inject},(1)}\n, meaning there is a\nq\n^\n(\nl\n)\n\\hat{q}^{(l)}\nequivalent to\nq\ninject\n,\n(\n1\n)\nq^{\\mathrm{inject},(1)}\n, and one out of distribution\nq\ninject\n,\n(\n2\n)\nq^{\\mathrm{inject},(2)}\n, on the real system.\nFigure 12\n:\nResults of real-world experiments with an UR10e. Robust reference trajectories where calculated for different magnitudes of modeled uncertainty\nÎ´\n^\n\\hat{\\delta}\nand final smoothing parameters\nÏ„\n,\nÏƒ\n\\tau,\\sigma\n. The figure shows the amount of successful completions of the assembly tasks. A run was termed successful if the final position error to the goal position was sufficiently small. See the videos for more details on the experiments. We observe a success rate of 80-90 % if the model-reality mismatch matches the modeled positional uncertainty (orange highlights), and an over\n99\n%\n99\\%\nsuccess rate if the modeled positional uncertainty is at least 1mm larger than the actual model-reality mismatch (lower right triangular submatrix of top plot).\nFigure\n12\nshows the success rates of tested assembly motions across 720 executed motions. The top figure shows the success rates for different combinations of values of modeled positional uncertainty\nÎ´\n^\n\\hat{\\delta}\nand injected model-reality mismatches. For each combination the trajectories for the five different starting positions in conjunction with the two considered injected positional offsets are excuted, making up 10 trials per combination. If there would be no sim-to-real gap at all, one would expect that the main diagonal of the plot admits to a 100% success rate. Since contact dynamics and the impedance controller behave differently on the real system than in simulation, less success rate is expected, in our experiments we achieve 80-90%.\nHowever, the more important result is that the success rates are almost constant along the main and subdiagonals. The average result on these diagonals may be easily shifted to the left by making the assembly problem easier, e.g., through introducing larger clearances, or to the right by making the problem harder, e.g., generating more mismatch between simulated and real-world controller. Since the success rates stay constant along the diagonals, this indeed supports the hypothesis that increased model-reality mismatches can be counteracted by modeling more positional uncertainty. On top, if one estimates an upper bound for the model-reality mismatch present in ones system, one can choose the modeled positional uncertainty with large enough margin to guarantee an almost 100% success rate. For example, in our case, by choosing the modeled uncertainty such that it is at least 1mm larger than the actual model-reality mismatches guarantees successful completion of the task in 149 out of 150 trials (this refers to the lower-right triangular submatrix).\nThe bottom figure now investigates what influence the final utilized smoothing parameters have on the real-world success rates. The magnitude of smoothing is naturally directly proportional to the number of utilized homotopy iterations. The solutions are calculated for a fixed modeled uncertainty\nÎ´\n^\n=\n5\n\\hat{\\delta}=5\nmm. Thus, the right most column of the top and bottom figure admit to the same motions that where executed on the robot. The results in this right column differ by the success of one motion, this difference likely being due to wear and tear of the 3D printed parts between the execution of the first 360 motions an the second 360 motions. Now, one can observe that the magnitude of the final smoothing parameters is directly inverse proportional to the success rates on the real system, meaning smaller smoothing of the physics simulation results in more reliable execution on the real-system.\nThis implies room for interesting trade-offs, as for example to guarantee a 100% success rate on our system with a 2mm model reality-mismatch, we could either model 3mm uncertainty and use six homotopy iterations to obtain a solution with small final smoothing parameters, or instead model 5mm uncertainty while only using four homotopy iterations to obtain a solution with larger final smoothing of contact dynamics. I.e., the in this paper presented robust formulation for contact-rich optimal control allows one to flexibly swap robust modeling for contact simulation precision. This can also be particularly interesting for other control approaches such as MPC, which often relies on Gauss-Newton Hessians, which particularly struggled at homotopy iterations with small smoothing parameters as seen in Figure\n9\n.\nVII\nConclusion\nWe proposed a robust optimal control approach which determines contact-rich assembly motions that can be reliably executed on real robotics hardware. In particular, we have demonstrated the ability of second-order optimization methods to solve difficult contact-rich problems in a sample-efficient manner, as well as the advantage of using exact Hessians over commonly used Hessian approximations for the considered use cases. We also showed in real-world experiments that robust modeling enables transition of solutions for smoothed contact dynamics to real-world problems. Overall, the results illustrate that there is great potential for derivative-based optimization methods in conjuncture with contact-rich systems if collision detection, contact dynamics and corresponding control methods are carefully constructed.\nCurrent limitations are as follows. The size of the collision detection LP subproblems scales proportionally with the number of halfspaces required to represent the convex polytopes, and the number of constraints in the OCP scales proportional to the number of considered collision pairs. For problems with complex convex subshapes or many collision pairs this results in extensive computation times. Furthermore, state-of-the-art physic simulation approaches commonly include a Coulomb friction model which was not considered in this paper.\nVIII\nFuture Work\nIn future work, we aim to transfer the proposed method to the multiple shooting case where the dynamics evaluation is hidden from the OCP. Solving for collision detection and contact resolution problems in an isolated manner allows one to only consider locally relevant constraints in the subproblems and, therefore, decrease computational cost for assembly problems with complex polytopic shapes and many collision pairs. Furthermore, a Coulomb friction model should be considered, a suitable formulation is, e.g., Anitescuâ€™s contact dynamics given by a quadratically constrained quadratic program\n[\n4\n]\n. The benefit of simulating friction effects is likely problem dependent, nevertheless a study how these effects can be used together with robust modeling to achieve improved real-world execution reliability should be conducted. Furthermore, computation speed of the method should be improved by using OCP-structure exploiting linear system solvers within the optimization method.\nAcknowledgments\nWe thank Florian Braun for advice on the C++ implementation framework and the visual presentation. We further thank Daniel Larin for exchange on formulations aspect of contact-rich dynamics.\nThis research was supported by BMWK via 20D2123B, 03EI4057A and 03EN3054B, by DFG via Research Unit FOR 2401, project 424107692 and 525018088, and by the EU via ELO-X 953348.\nAppendix A\nDerivation of Second-Order Directional Derivatives for an Implicit Function\nWe construct second-order directional derivatives for the primal-dual variables\nÎ³\n\\gamma\n. These variables are defined as an implicit function according of the KKT system (\n2\n), dropping the dependence on\nÏ„\n\\tau\nwe have\nF\nâ€‹\n(\nÎ³\n,\nq\n)\n=\nğŸ\n.\nF(\\gamma,q)=\\bm{0}.\nAs already noted in (\n10\n), the Jacobian of the primal-dual variables is obtained through solving the following linear system\nâˆ‚\nÎ³\nF\nâ€‹\n(\nÎ³\nâ€‹\n(\nq\n)\n,\nq\n)\nâ€‹\nD\nq\nâ€‹\nÎ³\nâ€‹\n(\nq\n)\n=\nâˆ’\nâˆ‚\nq\nF\nâ€‹\n(\nÎ³\nâ€‹\n(\nq\n)\n,\nq\n)\n.\n\\partial_{\\gamma}F(\\gamma(q),q)\\,\\mathrm{D}_{q}\\gamma(q)=-\\partial_{q}F(\\gamma(q),q).\n(20)\nGiven the seed vector\ns\nÎ³\nâˆˆ\nâ„\nn\nÎ³\ns_{\\gamma}\\in\\mathbb{R}^{n_{\\gamma}}\n, we now want to obtain the directional second-order derivatives\nâŸ¨\ns\nÎ³\n,\nD\nq\n,\nq\n2\nâ€‹\nÎ³\nâ€‹\n(\nq\n)\nâŸ©\n=\nD\nq\nâ€‹\n(\nD\nq\nâ€‹\nÎ³\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\ns\nÎ³\n)\n.\n\\langle s_{\\gamma}\\,,\\,\\mathrm{D}^{2}_{q,q}\\gamma(q)\\rangle=\\mathrm{D}_{q}(\\mathrm{D}_{q}\\gamma(q)^{\\top}s_{\\gamma}).\nTo this end, we write for simplicity\nA\nâ€‹\n(\nq\n)\n=\nâˆ‚\nÎ³\nF\nâ€‹\n(\nÎ³\nâ€‹\n(\nq\n)\n,\nq\n)\n,\nX\nâ€‹\n(\nq\n)\n=\nD\nq\nâ€‹\nÎ³\nâ€‹\n(\nq\n)\n,\nB\nâ€‹\n(\nq\n)\n=\nâˆ’\nâˆ‚\nq\nF\nâ€‹\n(\nÎ³\nâ€‹\n(\nq\n)\n,\nq\n)\n.\n\\begin{split}&A(q)=\\partial_{\\gamma}F(\\gamma(q),q),\\\\\n&X(q)=\\mathrm{D}_{q}\\gamma(q),\\\\\n&B(q)=-\\partial_{q}F(\\gamma(q),q).\\end{split}\n(21)\nThen (\n20\n) takes the form of the block linear system\nA\nâ€‹\n(\nq\n)\nâ€‹\nX\nâ€‹\n(\nq\n)\n=\nB\nâ€‹\n(\nq\n)\n.\nA(q)X(q)=B(q).\n(22)\nDifferentiating with respect to a scalar component of the pose\nq\nk\nq_{k}\n, we obtain by the chain rule\nD\nq\nk\nâ€‹\nA\nâ€‹\n(\nq\n)\nâ€‹\nX\nâ€‹\n(\nq\n)\n+\nA\nâ€‹\n(\nq\n)\nâ€‹\nD\nq\nk\nâ€‹\nX\nâ€‹\n(\nq\n)\n=\nD\nq\nk\nâ€‹\nB\nâ€‹\n(\nq\n)\n\\displaystyle\\mathrm{D}_{q_{k}}A(q)X(q)+A(q)\\mathrm{D}_{q_{k}}X(q)=\\mathrm{D}_{q_{k}}B(q)\nâ‡”\n\\displaystyle\\Leftrightarrow\\ \\\nD\nq\nk\nâ€‹\nX\nâ€‹\n(\nq\n)\n=\nA\nâ€‹\n(\nq\n)\nâˆ’\n1\nâ€‹\n(\nD\nq\nk\nâ€‹\nB\nâ€‹\n(\nq\n)\nâˆ’\nD\nq\nk\nâ€‹\nA\nâ€‹\n(\nq\n)\nâ€‹\nX\nâ€‹\n(\nq\n)\n)\n\\displaystyle\\mathrm{D}_{q_{k}}X(q)=A(q)^{-1}(\\mathrm{D}_{q_{k}}B(q)-\\mathrm{D}_{q_{k}}A(q)X(q))\nâ‡’\n\\displaystyle\\Rightarrow\\ \\\ns\nÎ³\nâŠ¤\nâ€‹\nD\nq\nk\nâ€‹\nX\nâ€‹\n(\nq\n)\n=\ns\nÎ³\nâŠ¤\nâ€‹\nA\nâ€‹\n(\nq\n)\nâˆ’\n1\nâ€‹\n(\nD\nq\nk\nâ€‹\nB\nâ€‹\n(\nq\n)\nâˆ’\nD\nq\nk\nâ€‹\nA\nâ€‹\n(\nq\n)\nâ€‹\nX\nâ€‹\n(\nq\n)\n)\n.\n\\displaystyle s_{\\gamma}^{\\top}\\mathrm{D}_{q_{k}}X(q)=s_{\\gamma}^{\\top}A(q)^{-1}(\\mathrm{D}_{q_{k}}B(q)-\\mathrm{D}_{q_{k}}A(q)X(q)).\nThus, the adjoint equation (\n12\n) originates given by\nA\nâ€‹\n(\nq\n)\nT\nâ€‹\nr\nÎ³\n=\ns\nÎ³\n.\nA(q)^{T}r_{\\gamma}=s_{\\gamma}.\nWe can now substitute\nr\nÎ³\nr_{\\gamma}\nand transpose the equations to obtain column vectors\nD\nq\nk\nâ€‹\nX\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\ns\nÎ³\n=\nD\nq\nk\nâ€‹\nB\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\nr\nÎ³\nâˆ’\nX\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\nD\nq\nk\nâ€‹\nA\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\nr\nÎ³\n\\displaystyle\\mathrm{D}_{q_{k}}X(q)^{\\top}s_{\\gamma}=\\mathrm{D}_{q_{k}}B(q)^{\\top}r_{\\gamma}-X(q)^{\\top}\\mathrm{D}_{q_{k}}A(q)^{\\top}r_{\\gamma}\nConcatenating the scalar derivatives w.r.t.\nq\nk\nq_{k}\nlets one obtain the full directional Hessian\nD\nq\nâ€‹\nX\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\ns\nÎ³\n=\nD\nq\nâ€‹\nB\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\nr\nÎ³\nâˆ’\nX\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\nD\nq\nâ€‹\nA\nâ€‹\n(\nq\n)\nâŠ¤\nâ€‹\nr\nÎ³\n.\n\\mathrm{D}_{q}X(q)^{\\top}s_{\\gamma}=\\mathrm{D}_{q}B(q)^{\\top}r_{\\gamma}-X(q)^{\\top}\\mathrm{D}_{q}A(q)^{\\top}r_{\\gamma}.\n(23)\nSubstituting (\n21\n) into (\n23\n) and evaluation of the right-hand side total derivatives results in the expression (\n13\n) used in Section\nIII-C\n.\nAppendix B\nParameters for conducted experiments.\nTABLE III\n:\nParameters for the peg-in-hole experiments of Section\nVI-C\n.\nParameter\nValue\nParameter\nValue\nN\nN\n100\nÎ²\nr\n,\n1\n\\beta_{\\mathrm{r},1}\n1\nÎ”\nâ€‹\nt\n\\Delta t\n0.04\nÎ²\nr\n,\n2\n\\beta_{\\mathrm{r},2}\n0.1\nn\ns\nn_{\\mathrm{s}}\n3\nÎ²\nr\n,\n3\n\\beta_{\\mathrm{r},3}\n100\n|\nÎ \n|\n|\\Pi|\nfillllll\ncf. Figure\n7\nÎ²\nr\n,\n4\n\\beta_{\\mathrm{r},4}\n10\nk\nt\nk_{\\mathrm{t}}\n50\nÎ²\nc\n,\n1\n\\beta_{\\mathrm{c},1}\n1\nk\nr\nk_{\\mathrm{r}}\n5\nÎ²\nc\n,\n2\n\\beta_{\\mathrm{c},2}\n0.1\nn\nhom\nn_{\\mathrm{hom}}\n5\nÎ²\nc\n,\n3\n\\beta_{\\mathrm{c},3}\n10000\nÏ„\n1\n\\tau_{1}\n0.0025\nÎ²\nc\n,\n4\n\\beta_{\\mathrm{c},4}\n1000\nÏƒ\n1\n\\sigma_{1}\n0.00125\nÎ´\n^\n\\hat{\\delta}\n0.02\nÎ¼\ninit\n,\n1\n\\mu_{\\mathrm{init},1}\n1\nÏ\n^\n(\n1\n)\n\\hat{\\rho}^{(1)}\n(\n0.7071\n,\nâˆ’\n0.7071\n,\n0\n)\n(0.7071,\\,-0.7071,\\,0)\nÎº\nÏ„\n\\kappa_{\\tau}\n0.5\nÏ\n^\n(\n2\n)\n\\hat{\\rho}^{(2)}\n(\nâˆ’\n0.7071\n,\nâˆ’\n0.7071\n,\n0\n)\n(-0.7071,\\,-0.7071,\\,0)\nÎº\nÏƒ\n\\kappa_{\\sigma}\n0.5\nÏ\n^\n(\n3\n)\n\\hat{\\rho}^{(3)}\n(\n0\n,\n1\n,\n0\n)\n(0,\\,1,\\,0)\nÎº\nÎ¼\n\\kappa_{\\mu}\n0.1\nTABLE IV\n:\nParameters for the clamp experiments of Section\nVI-D\n.\nParameter\nValue\nParameter\nValue\nN\nN\n120\nÎ²\nr\n,\n1\n\\beta_{\\mathrm{r},1}\n1\nÎ”\nâ€‹\nt\n\\Delta t\n0.033\nÎ²\nr\n,\n2\n\\beta_{\\mathrm{r},2}\n0.1\nn\ns\nn_{\\mathrm{s}}\n5\nÎ²\nr\n,\n3\n\\beta_{\\mathrm{r},3}\n100\n|\nÎ \n|\n|\\Pi|\n6\nÎ²\nr\n,\n4\n\\beta_{\\mathrm{r},4}\n10\nk\nt\nk_{\\mathrm{t}}\n100\nÎ²\nc\n,\n1\n\\beta_{\\mathrm{c},1}\n1\nk\nr\nk_{\\mathrm{r}}\n10\nÎ²\nc\n,\n2\n\\beta_{\\mathrm{c},2}\n0.1\nn\nhom\nn_{\\mathrm{hom}}\n6\nÎ²\nc\n,\n3\n\\beta_{\\mathrm{c},3}\n10000\nÏ„\n1\n\\tau_{1}\n0.0005\nÎ²\nc\n,\n4\n\\beta_{\\mathrm{c},4}\n1000\nÏƒ\n1\n\\sigma_{1}\nfillllllllllll\n0.00025\nÎ´\n^\n\\hat{\\delta}\ncf. Figure\n12\nÎ¼\ninit\n,\n1\n\\mu_{\\mathrm{init},1}\n1\nÏ\n^\n(\n1\n)\n\\hat{\\rho}^{(1)}\n(\n0\n,\n0\n,\n0\n)\n(0,\\,0,\\,0)\nÎº\nÏ„\n\\kappa_{\\tau}\n0.5\nÏ\n^\n(\n2\n)\n\\hat{\\rho}^{(2)}\n(\n0.7071\n,\n0.7071\n,\n0\n)\n(0.7071,\\,0.7071,\\,0)\nÎº\nÏƒ\n\\kappa_{\\sigma}\n0.5\nÏ\n^\n(\n3\n)\n\\hat{\\rho}^{(3)}\nâˆ’\n-\n(\nâˆ’\n0.7071\n,\n0.7071\n,\n0\n)\n(-0.7071,\\,0.7071,\\,0)\nÎº\nÎ¼\n\\kappa_{\\mu}\n0.1\nÏ\n^\n(\n4\n)\n\\hat{\\rho}^{(4)}\n(\n0\n,\n1\n,\n0\n)\n(0,\\,1,\\,0)\nÏ\n^\n(\n5\n)\n\\hat{\\rho}^{(5)}\n(\n0\n,\nâˆ’\n1\n,\n0\n)\n(0,\\,-1,\\,0)\nReferences\n[1]\nA. Albu-Schaffer, C. Ott, U. Frese, and G. Hirzinger\n(2003)\nCartesian impedance control of redundant robots: recent results with the dlr-light-weight-arms\n.\nIEEE International Conference on Robotics and Automation\n.\nCited by:\nÂ§\nV-A\n.\n[2]\nJ. Alvarez-Padilla, J. Z. Zhang, S. Kwok, J. M. Dolan, and Z. Manchester\n(2024)\nReal-time whole-body control of legged robots with model-predictive path integral control\n.\nNote:\narXiv preprint\narXiv:2409.10469\nExternal Links:\n2409.10469\n,\nLink\nCited by:\nÂ§\nII-C\n.\n[3]\nJ. A. E. Andersson, J. Gillis, G. Horn, J. B. Rawlings, and M. Diehl\n(2019)\nCasADi â€“ A software framework for nonlinear optimization and optimal control\n.\nMathematical Programming Computation\n.\nCited by:\nitem\nâˆ™\n\\bullet\n,\nÂ§\nVI-A\n.\n[4]\nM. Anitescu\n(2006)\nOptimization-based simulation of nonsmooth rigid multibody dynamics\n.\nMathematical Programming\n.\nCited by:\nÂ§VIII\n.\n[5]\nA. Bambade, F. Schramm, S. El-Kazdadi, S. Caron, A. Taylor, and J. Carpentier\n(2025)\nProxQP: an efficient and versatile quadratic programming solver for real-time robotics applications and beyond\n.\nIEEE Transactions on Robotics\n.\nExternal Links:\nDocument\nCited by:\nÂ§\nVI-B\n.\n[6]\nD. P. Bertsekas\n(2016)\nNonlinear programming\n.\nAthena Scientific\n.\nCited by:\nÂ§\nIII-B\n.\n[7]\nB. Brogliato\n(2016)\nNonsmooth mechanics\n.\nSpringer\n.\nCited by:\nÂ§I\n,\nÂ§\nIII-B\n,\nÂ§\nIV-A\n.\n[8]\nF. Caccavale, P. Chiacchio, A. Marino, and L. Villani\n(2008)\nSix-dof impedance control of dual-arm cooperative manipulators\n.\nIEEE/ASME Transactions on Mechatronics\n.\nCited by:\nÂ§\nV-A\n.\n[9]\nJ. Carpentier, Q. L. Lidec, L. Montaut, J. Vaillant, Y. de Mont-Marin, A. Sathya, and F. Schramm\n(2025)\nSimple simulator\n.\nNote:\nhttps://github.com/Simple-Robotics/Simple\nCited by:\nÂ§\nII-A\n.\n[10]\nC. Dietz, S. Albrecht, A. NurkanoviÄ‡, and M. Diehl\n(2025)\nSmoothed distance functions for direct optimal control of contact-rich systems\n.\nEuropean Control Conference\n.\nCited by:\nÂ§\nIII-A\n,\nÂ§\nIII-A\n,\nÂ§\nIII-B\n.\n[11]\nG. Frison and M. Diehl\n(2020)\nHPIPM: a high-performance quadratic programming framework for model predictive control\n.\nIFAC-PapersOnLine\n.\nCited by:\nitem\nâˆ™\n\\bullet\n,\nÂ§\nIII-D\n,\nÂ§\nVI-A\n.\n[12]\nG. Frison, D. Kouzoupis, A. Zanelli, and M. Diehl\n(2018)\nBLASFEO: Basic linear algebra subroutines for embedded optimization\n.\nACM Transactions on Mathematical Software\n.\nCited by:\nitem\nâˆ™\n\\bullet\n,\nÂ§\nVI-A\n.\n[13]\nE.G. Gilbert, D.W. Johnson, and S.S. Keerthi\n(1988)\nA fast procedure for computing the distance between complex objects in three-dimensional space\n.\nIEEE Journal on Robotics and Automation\n.\nCited by:\nÂ§\nII-A\n.\n[14]\nS. Gros, M. Zanon, and M. Diehl\n(2015)\nBaumgarte stabilisation over the so(3) rotation group for control\n.\nIEEE Conference on Decision and Control\n.\nCited by:\nÂ§\nIV-A\n.\n[15]\nW. Hogan\n(1973)\nDirectional derivatives for extremal-value functions with applications to the completely convex case\n.\nOperations Research\n.\nCited by:\nÂ§\nIII-B\n.\n[16]\nT. A. Howell, S. L. Cleacâ€™h, J. BrÃ¼digam, J. Z. Kolter, M. Schwager, and Z. Manchester\n(2023)\nDojo: a differentiable physics engine for robotics\n.\nNote:\narXiv preprint\narXiv:2203.00806\nExternal Links:\n2203.00806\nCited by:\nÂ§I\n,\nÂ§\nII-B\n.\n[17]\nT. Howell, N. Gileadi, S. Tunyasuvunakool, K. Zakka, T. Erez, and Y. Tassa\n(2022)\nPredictive sampling: real-time behaviour synthesis with mujoco\n.\nNote:\narXiv preprint\narXiv:2212.00541\nExternal Links:\n2212.00541\n,\nLink\nCited by:\nÂ§\nII-C\n.\n[18]\nY. Jiang, M. Yu, X. Zhu, M. Tomizuka, and X. Li\n(2024)\nContact-implicit model predictive control for dexterous in-hand manipulation: a long-horizon and robust approach\n.\nIEEE International Conference on Intelligent Robots and Systems\n.\nCited by:\nÂ§\nII-C\n.\n[19]\nG. Kim, D. Kang, J. Kim, S. Hong, and H. Park\n(2024)\nContact-implicit model predictive control: controlling diverse quadruped motions without pre-planned contact modes or trajectories\n.\nInternational Journal of Robotics Research\n.\nCited by:\nÂ§I\n,\nÂ§\nII-C\n.\n[20]\nG. Kim, D. Kang, J. Kim, S. Hong, and H. Park\n(2025)\nContact-implicit model predictive control: controlling diverse quadruped motions without pre-planned contact modes or trajectories\n.\nInternational Journal of Robotics Research\n.\nCited by:\nÂ§\nII-C\n.\n[21]\nV. Kurtz, A. Castro, A. Ã–. Ã–nol, and H. Lin\n(2025)\nInverse dynamics trajectory optimization for contact-implicit model predictive control\n.\nInternational Journal of Robotics Research\n.\nCited by:\nÂ§\nII-C\n.\n[22]\nG. Lee, J. Lee, S. Noh, M. Ko, K. Kim, and K. Lee\n(2024)\nPolyFit: a peg-in-hole assembly framework for unseen polygon shapes via sim-to-real adaptation\n.\nIEEE International Conference on Intelligent Robots and Systems\n.\nCited by:\nÂ§I\n,\nÂ§\nII-C\n.\n[23]\nS. Levine and V. Koltun\n(2013)\nGuided policy search\n.\nInternational Conference on Machine Learning\n.\nCited by:\nÂ§I\n,\nÂ§\nII-C\n.\n[24]\nZ. Li, X. B. Peng, P. Abbeel, S. Levine, G. Berseth, and K. Sreenath\n(2025)\nReinforcement learning for versatile, dynamic, and robust bipedal locomotion control\n.\nInternational Journal of Robotics Research\n.\nCited by:\nÂ§\nII-C\n.\n[25]\nQ. L. Lidec, W. Jallet, L. Montaut, I. Laptev, C. Schmid, and J. Carpentier\n(2024)\nContact models in robotics: a comparative analysis\n.\nNote:\narXiv preprint\narXiv:2304.06372\nExternal Links:\n2304.06372\n,\nLink\nCited by:\nÂ§\nII-B\n.\n[26]\nQ. L. Lidec, L. Montaut, Y. de Mont-Marin, F. Schramm, and J. Carpentier\n(2025)\nEnd-to-end and highly-efficient differentiable simulation for robotics\n.\nNote:\narXiv preprint\narXiv:2409.07107\nExternal Links:\n2409.07107\n,\nLink\nCited by:\nÂ§I\n,\nÂ§\nII-B\n.\n[27]\nQ. L. Lidec, F. Schramm, L. Montaut, C. Schmid, I. Laptev, and J. Carpentier\n(2024)\nLeveraging randomized smoothing for optimal control of nonsmooth dynamical systems\n.\nNonlinear Analysis: Hybrid Systems\n.\nCited by:\nÂ§I\n,\nÂ§\nII-B\n.\n[28]\nA. P. Lindvig, I. Iturrate, U. Kindler, and C. Sloth\n(2025)\nUr\n_\n\\_\nrtde: an interface for controlling universal robots (ur) using the real-time data exchange(rtde)\n.\nIEEE International Symposium on System Integration\n.\nCited by:\nÂ§\nVI-D\n.\n[29]\nF. Liu, Z. Gu, Y. Cai, Z. Zhou, H. Jung, J. Jang, S. Zhao, S. Ha, Y. Chen, D. Xu, and Y. Zhao\n(2025)\nOpt2Skill: imitating dynamically-feasible whole-body trajectories for versatile humanoid loco-manipulation\n.\nNote:\narXiv preprint\narXiv:2409.20514\nExternal Links:\n2409.20514\n,\nLink\nCited by:\nÂ§\nII-C\n.\n[30]\nJ. Y. Luo, Y. Song, V. Klemm, F. Shi, D. Scaramuzza, and M. Hutter\n(2024)\nResidual policy learning for perceptive quadruped control using differentiable simulation\n.\nNote:\narXiv preprint\narXiv:2410.03076\nExternal Links:\n2410.03076\n,\nLink\nCited by:\nÂ§I\n.\n[31]\nL. Montaut, Q. Le Lidec, V. Petrik, J. Sivic, and J. Carpentier\n(2024)\nGJK++: leveraging acceleration methods for faster collision detection\n.\nIEEE Transactions on Robotics\n.\nCited by:\nÂ§\nII-A\n,\nÂ§\nVI-B\n.\n[32]\nL. Montaut, Q. L. Lidec, A. Bambade, V. Petrik, J. Sivic, and J. Carpentier\n(2023)\nDifferentiable collision detection: a randomized smoothing approach\n.\nIEEE International Conference on Robotics and Automation\n.\nCited by:\nÂ§I\n,\nÂ§\nII-A\n,\nÂ§\nII-A\n.\n[33]\nI. Mordatch, K. Lowrey, and E. Todorov\n(2015)\nEnsemble-cio: full-body dynamic motion planning that transfers to physical humanoids\n.\nIEEE International Conference on Intelligent Robots and Systems\n.\nCited by:\nÂ§\nII-C\n,\nÂ§\nV-B\n.\n[34]\nJ. J. Moreau\n(1988)\nUnilateral contact and dry friction in finite freedom dynamics\n.\nNonsmooth Mechanics and Applications\n.\nCited by:\nÂ§I\n,\nÂ§I\n,\nÂ§\nIV-B\n.\n[35]\nA. NurkanoviÄ‡, A. Pozharskiy, and M. Diehl\n(2024)\nSolving mathematical programs with complementarity constraints arising in nonsmooth optimal control\n.\nVietnam Journal of Mathematics\n.\nCited by:\nÂ§\nIV-B\n.\n[36]\nC. J. Ong and E.G. Gilbert\n(1996)\nGrowth distances: new measures for object separation and penetration\n.\nTransactions on Robotics and Automation\n.\nCited by:\nÂ§I\n,\nÂ§\nII-A\n,\nFigure 3\n,\nFigure 3\n,\nÂ§\nIII-A\n,\nÂ§\nIII-A\n,\nÂ§\nIII-B\n,\nÂ§III\n.\n[37]\nT. Pang, H. J. T. Suh, L. Yang, and R. Tedrake\n(2023)\nGlobal planning for contact-rich manipulation via local smoothing of quasi-dynamic contact models\n.\nIEEE Transactions on Robotics\n.\nCited by:\nÂ§\nII-A\n,\nÂ§\nII-C\n.\n[38]\nS. Scholtes\n(2001)\nConvergence properties of a regularization scheme for mathematical programs with complementarity constraints\n.\nSIAM Journal on Optimization\n.\nCited by:\nÂ§I\n,\nÂ§\nIV-B\n.\n[39]\nY. Seo, C. Sferrazza, H. Geng, M. Nauman, Z. Yin, and P. Abbeel\n(2025)\nFastTD3: simple, fast, and capable reinforcement learning for humanoid control\n.\nNote:\narXiv preprint\narXiv:2505.22642\nExternal Links:\n2505.22642\n,\nLink\nCited by:\nÂ§\nII-C\n.\n[40]\nY. Tassa, T. Erez, and E. Todorov\n(2012)\nSynthesis and stabilization of complex behaviors through online trajectory optimization\n.\nIEEE International Conference on Intelligent Robots and Systems\n.\nExternal Links:\nDocument\nCited by:\nÂ§I\n,\nÂ§\nII-C\n.\n[41]\nE. Todorov, T. Erez, and Y. Tassa\n(2012)\nMuJoCo: A physics engine for model-based control\n.\nIEEE International Conference on Intelligent Robots and Systems\n.\nCited by:\nÂ§\nII-A\n,\nÂ§\nII-B\n.\n[42]\nE. Todorov\n(2019)\nOptico: a framework for model-based optimization with mujoco physics\n.\nConference on Neural Information Processing Systems\n.\nCited by:\nÂ§\nIV-B\n.\n[43]\nK. Tracy, T. A. Howell, and Z. Manchester\n(2023)\nDifferentiable collision detection for a set of convex primitives\n.\nIEEE International Conference on Robotics and Automation\n.\nExternal Links:\nDocument\nCited by:\nÂ§I\n,\nÂ§\nII-A\n,\nFigure 3\n,\nFigure 3\n,\nÂ§\nIII-B\n.\n[44]\nK. Tracy and Z. Manchester\n(2024)\nOn the differentiability of the primal-dual interior-point method\n.\nNote:\narXiv preprint\narXiv:2406.11749\nExternal Links:\n2406.11749\nCited by:\nÂ§\nII-A\n.\n[45]\nL. Vanroye, A. Sathya, J. D. Schutter, and W. DecrÃ©\n(2023)\nFATROP : a fast constrained optimal control problem solver for robot trajectory optimization and control\n.\nNote:\narXiv preprint\narXiv:2303.16746\nExternal Links:\n2303.16746\n,\nLink\nCited by:\nÂ§\nVI-C\n.\n[46]\nN. Vuong and Q. Pham\n(2023)\nReinforcement learning with parameterized manipulation primitives for robotic assembly\n.\nNote:\narXiv preprint\narXiv:2306.06679\nExternal Links:\n2306.06679\n,\nLink\nCited by:\nÂ§I\n,\nÂ§\nII-C\n,\nÂ§\nVI-C\n.\n[47]\nA. WÃ¤chter and L. T. Biegler\n(2006)\nOn the implementation of an interior-point filter line-search algorithm for large-scale nonlinear programming\n.\nMathematical Programming\n.\nCited by:\nÂ§\nV-D\n,\nÂ§\nVI-A\n.\n[48]\nK. Werling, D. Omens, J. Lee, I. Exarchos, and C. K. Liu\n(2021)\nFast and feature-complete differentiable physics for articulated rigid bodies with contact\n.\nRobotics: Science and Systems\n.\nCited by:\nÂ§I\n,\nÂ§I\n,\nÂ§\nII-B\n.\n[49]\nF. Wirnshofer, P. S. Schmitt, W. Feiten, G. von Wichert, and W. Burgard\n(2018)\nRobust, compliant assembly via optimal belief space planning\n.\nIEEE International Conference on Robotics and Automation\n.\nCited by:\nÂ§\nII-C\n.\n[50]\nJ. Xu, V. Makoviychuk, Y. Narang, F. Ramos, W. Matusik, A. Garg, and M. Macklin\n(2022)\nAccelerated policy learning with parallel differentiable simulation\n.\nInternational Conference on Learning Representations\n.\nCited by:\nÂ§I\n,\nÂ§\nII-C\n.\n[51]\nW. Yang and W. Jin\n(2025)\nContactSDF: signed distance functions as multi-contact models for dexterous manipulation\n.\nNote:\narXiv preprint\narXiv:2408.09612\nExternal Links:\n2408.09612\n,\nLink\nCited by:\nÂ§\nII-A\n.\n[52]\nX. Zhang, A. Liniger, and F. Borrelli\n(2021)\nOptimization-based collision avoidance\n.\nIEEE Transactions on Control Systems Technology\n.\nCited by:\nÂ§\nIII-A\n.\nAppendix C\nBiography Section\nChristian Dietz\nreceived both a bachelorâ€™s and a masterâ€™s degree in mathematics from the Technical University of Munich, Germany, in 2019 and 2022, respectively. Since 2022 he is an industrial PhD student associated with both Siemens and the Systems Control and Optimization Laboratory at the University of Freiburg, Germany. His research concentrates on numerical optimal control methods for contact-rich systems, with an application focus on industrial assembly planning.\nSebastian Albrecht\nreceived the Ph.D. degree in Mathematics from Technische UniversitÃ¤t MÃ¼nchen, Germany, in 2014. He joined Siemens AG, Munich, in 2015 as a Research Scientist, working in the areas of robotics, autonomous systems, and control. His research interests include numerical methods for nonlinear optimization and control, with a focus on their application to complex realâ€‘world problems.\nGianluca Frison\nobtained a MSc in Automatic Control Engineering from the University of Padua (Italy), and a MSc in Mathematical Modeling and Computation from the Technical University of Denmark in 2012. In 2016 he obtained a PhD degree from Technical University of Denmark, with a doctoral thesis on algorithms and methods for high-performance model predictive control. He is currently employed as a post-doc at the University of Freiburg (Germany), working on high-performance linear algebra for embedded optimization with application to solvers for model predictive control, and as a senior developer at Mosek, working on the implementation of mathematical optimization algorithms.\nMoritz Diehl\n(Member, IEEE) received the dual\nDiploma degree in mathematics and physics from\nHeidelberg University, Heidelberg, Germany, and\nCambridge University, Cambridge, U.K., in 1999,\nand the Ph.D. degree in optimization and nonlinear\nmodel predictive control from the Interdisciplinary\nCenter for Scientific Computing, Heidelberg University, in 2001.\nFrom 2006 to 2013, he was a Professor with the\nDepartment of Electrical Engineering, KU Leuven\nUniversity, Leuven, Belgium, where he was the\nPrincipal Investigator with the Optimization in Engineering Center (OPTEC).\nIn 2013, he moved to the University of Freiburg, Freiburg, Germany, where\nhe heads the Systems Control and Optimization Laboratory, Department of\nMicrosystems Engineering (IMTEK), and is also with the Department of\nMathematics. His research interests include optimization and control, spanning\nfrom numerical method development to applications in different branches of\nengineering, with a focus on embedded and renewable energy systems.\nArmin NurkanoviÄ‡\nreceived the B.Sc. degree from the Faculty of Electrical Engineering, Tuzla, Bosnia and Herzegovina, in 2015, and the M.Sc. degree in Electrical and Computer Engineering, Technical University of Munich, Munich, Germany, in 2018. In 2023, he received his Ph.D. degree in Engineering from the University of Freiburg, Freiburg, Germany. He received the IEEE Control Systems Letters Outstanding Paper Award in 2022 and was a finalist for the 2024 European Systems & Control PhD Thesis Award. In 2025, he served as an interim professor of mathematical optimization at TU Braunschweig. His research interests include numerical methods for model predictive control, nonlinear optimization, and optimal control of nonsmooth and hybrid dynamical systems.",
    "preview_text": "Efficient planning of assembly motions is a long standing challenge in the field of robotics that has been primarily tackled with reinforcement learning and sampling-based methods by using extensive physics simulations. This paper proposes a sample-efficient robust optimal control approach for the determination of assembly motions, which requires significantly less physics simulation steps during planning through the efficient use of derivative information. To this end, a differentiable physics simulation is constructed that provides second-order analytic derivatives to the numerical solver and allows one to traverse seamlessly from informative derivatives to accurate contact simulation. The solution of the physics simulation problem is made differentiable by using smoothing inspired by interior-point methods applied to both the collision detection as well as the contact resolution problem. We propose a modified variant of an optimization-based formulation of collision detection formulated as a linear program and present an efficient implementation for the nominal evaluation and corresponding first- and second-order derivatives. Moreover, a multi-scenario-based trajectory optimization problem that ensures robustness with respect to sim-to-real mismatches is derived. The capability of the considered formulation is illustrated by results where over 99\\% successful executions are achieved in real-world experiments. Thereby, we carefully investigate the effect of smooth approximations of the contact dynamics and robust modeling on the success rates. Furthermore, the method's capability is tested on different peg-in-hole problems in simulation to show the benefit of using exact Hessians over commonly used Hessian approximations.\n\nRobust Rigid Body Assembly via Contact-Implicit\nOptimal Control with Exact Second-Order Derivatives\nChristian Dietz\n1,2\n, Sebastian Albrecht\n1\n, Gianluca Frison\n2\n, Moritz Diehl\n2,3\n, Armin NurkanoviÄ‡\n2\n1\nAutonomous Systems and Control, Siemens ",
    "is_relevant": false,
    "relevance_score": 2.0,
    "extracted_keywords": [
        "constrained reinforcement learning",
        "safe reinforcement learning",
        "world model"
    ],
    "one_line_summary": "è¯¥è®ºæ–‡æå‡ºäº†ä¸€ç§åŸºäºæ¥è§¦éšå¼æœ€ä¼˜æ§åˆ¶å’Œç²¾ç¡®äºŒé˜¶å¯¼æ•°çš„é²æ£’åˆšä½“è£…é…æ–¹æ³•ï¼Œä¸»è¦å…³æ³¨ä¼˜åŒ–æ§åˆ¶ã€ç‰©ç†æ¨¡æ‹Ÿå’Œè½¨è¿¹ä¼˜åŒ–ï¼Œè€Œéå¼ºåŒ–å­¦ä¹ æˆ–è§†è§‰è¯­è¨€åŠ¨ä½œæ¨¡å‹ã€‚",
    "detailed_summary": "",
    "qa_pairs": [],
    "is_hidden": false,
    "is_starred": false,
    "flag": true,
    "published_date": "2026-01-30T11:21:20Z",
    "created_at": "2026-02-03T15:53:07.838779",
    "updated_at": "2026-02-03T15:53:07.838787"
}